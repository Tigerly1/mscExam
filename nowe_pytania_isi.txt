[#1] (#1) KtÃ³re z poniÅ¼szych twierdzeÅ„ jest prawdziwe dotyczÄ…ce zÅ‚oÅ¼onoÅ›ci Quicksort?
a) Pesymistyczna zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa dla sortowania Quicksort to O(n log n)
>>b) Pesymistyczna zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa dla sortowania Quicksort to O(n^2)
c) Åšrednia zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa dla sortowania Quicksort to O(n^2)
d) Najlepsza zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa dla sortowania Quicksort to O(n!)
e) Quicksort jest algorytmem stabilnym
f) Quicksort zawsze wymaga O(n) dodatkowej pamiÄ™ci


[#2] (#2) WskaÅ¼ zdania prawdziwe dotyczÄ…ce algorytmu Dijkstry:
a) Algorytm Dijkstry znajdowania najkrÃ³tszych Å›cieÅ¼ek jest algorytmem heurystycznym o zÅ‚oÅ¼onoÅ›ci O(n2 log n).
>>b) Algorytm Dijkstry znajduje najkrÃ³tsze Å›cieÅ¼ki z jednego ÅºrÃ³dÅ‚a w grafie o nieujemnych wagach krawÄ™dzi.
c) Algorytm Dijkstry poprawnie obsÅ‚uguje grafy z ujemnymi wagami krawÄ™dzi.
>>d) ZÅ‚oÅ¼onoÅ›Ä‡ algorytmu Dijkstry przy uÅ¼yciu kopca binarnego wynosi O(E log V).
e) Algorytm Dijkstry sÅ‚uÅ¼y do wyznaczania minimalnego drzewa rozpinajÄ…cego.
f) Algorytm Dijkstry jest algorytmem typu "dziel i zwyciÄ™Å¼aj".


[#3] (#3) KtÃ³re z poniÅ¼szych stwierdzeÅ„ jest prawdziwe dotyczÄ…ce algorytmu DFS?
a) Algorytm DFS sÅ‚uÅ¼y do wyznaczania minimalnego drzewa rozpinajÄ…cego dla grafu skierowanego.
>>b) Algorytm DFS (Depth-First Search) moÅ¼e byÄ‡ wykorzystany do wykrywania cykli w grafie.
c) Algorytm DFS zawsze znajduje najkrÃ³tszÄ… Å›cieÅ¼kÄ™ w grafie nieskierowanym bez wag.
d) Algorytm DFS wykorzystuje kolejkÄ™ FIFO jako podstawowÄ… strukturÄ™ danych.
e) ZÅ‚oÅ¼onoÅ›Ä‡ czasowa DFS wynosi O(V^2) dla reprezentacji listowej.
f) DFS nie pozwala na wyznaczenie czasu wejÅ›cia i wyjÅ›cia z wÄ™zÅ‚a.


[#4] (#4) KtÃ³re z poniÅ¼szych twierdzeÅ„ jest prawdziwe dotyczÄ…ce tablic mieszajÄ…cych?
>>a) Adresowanie otwarte to jedna ze strategii rozwiÄ…zywania kolizji w tablicach haszujÄ…cych (tablicach mieszajÄ…cych).
b) Adresowanie otwarte polega na tworzeniu listy wiÄ…zanej dla kaÅ¼dego indeksu tablicy.
c) Funkcja mieszajÄ…ca musi zawsze zwracaÄ‡ unikalnÄ… wartoÅ›Ä‡ dla kaÅ¼dego klucza (brak kolizji).
d) Tablica mieszajÄ…ca gwarantuje czas dostÄ™pu O(1) w najgorszym przypadku niezaleÅ¼nie od liczby kolizji.
e) W adresowaniu otwartym wspÃ³Å‚czynnik wypeÅ‚nienia moÅ¼e byÄ‡ dowolnie duÅ¼y.
f) Metoda Å‚aÅ„cuchowa jest rodzajem adresowania otwartego.


[#5] (#5) KtÃ³re stwierdzenia dotyczÄ…ce notacji asymptotycznych i sortowania sÄ… prawdziwe:
>>a) Sekwencyjny algorytm sortowania przez porÃ³wnania elementÃ³w w tablicy nie moÅ¼e dziaÅ‚aÄ‡ z mniejszÄ… zÅ‚oÅ¼onoÅ›ciÄ… niÅ¼ Î©(n log n).
b) Sortowanie przez wstawianie ma pesymistycznÄ… zÅ‚oÅ¼onoÅ›Ä‡ O(n log n).
c) Notacja O(f(n)) oznacza dolne ograniczenie asymptotyczne.
d) KaÅ¼dy algorytm sortowania ma zÅ‚oÅ¼onoÅ›Ä‡ pamiÄ™ciowÄ… O(1).
>>e) JeÅ›li f(n) = O(g(n)), to g(n) jest asymptotycznym ograniczeniem gÃ³rnym dla f(n).
f) Algorytm o zÅ‚oÅ¼onoÅ›ci O(n^2) jest zawsze szybszy niÅ¼ O(n log n) dla duÅ¼ych n.


[#6] (#6) Zadanie o rozmiarze n realizowane algorytmem o zÅ‚oÅ¼onoÅ›ci f(n) zostaÅ‚o sprowadzone do dwÃ³ch pod-zadaÅ„ o wielkoÅ›ci 1/n oraz wykonania n
operacji o staÅ‚ym koszcie wykonania. ZÅ‚oÅ¼onoÅ›Ä‡ f(n) wynosi
>>a) O(n log n)
b) O(n)
c) O(n^2)
d) O(log n)
e) O(1)
f) O(n!)


[#7] (#7) Do drzewa BST wstawiono losowy zestaw n wzajemnie rÃ³Å¼nych liczb. KtÃ³ra z odpowiedzi jest prawdziwa?
>>a) Pesymistyczna zÅ‚oÅ¼onoÅ›Ä‡ operacji usuwania elementu w drzewie kaÅ¼dorazowo zaleÅ¼y od gÅ‚Ä™bokoÅ›ci danego drzewa.
b) Åšrednia wysokoÅ›Ä‡ takiego drzewa wynosi O(n).
c) Operacja wyszukiwania w takim drzewie zawsze zajmuje O(log n) czasu w najgorszym przypadku.
d) Drzewo BST po wstawieniu losowych elementÃ³w zawsze staje siÄ™ drzewem AVL.
e) In-order przechodzenie przez BST nie daje posortowanej sekwencji.
f) BST zawsze gwarantuje logarytmiczny czas operacji.


[#8] (#8) Uruchomiono operacjÄ™ budowania kopca dla tablicy dziesiÄ™ciu elementÃ³w: 1,2,3,4,5,6,7,8,9,0. Czy prawdziwe sÄ… w odniesieniu do powstaÅ‚ego drzewa nastÄ™pujÄ…ce stwierdzenia:
a) Ze wzglÄ™du na wykorzystanie operacji rotacji przy wstawianiu elementÃ³w gÅ‚Ä™bokoÅ›Ä‡ kopca bÄ™dzie wynosiÄ‡ O(log n).
>>b) Operacja budowania kopca (build-heap) dla n elementÃ³w ma zÅ‚oÅ¼onoÅ›Ä‡ czasowÄ… O(n).
c) Kopiec binarny jest zawsze drzewem peÅ‚nym (wszystkie liÅ›cie na tym samym poziomie).
d) W kopcu typu max element o najmniejszej wartoÅ›ci zawsze znajduje siÄ™ w korzeniu.
e) Kopiec binarny nie moÅ¼e byÄ‡ reprezentowany w tablicy.
f) Budowanie kopca metodÄ… kolejnych wstawiaÅ„ ma zÅ‚oÅ¼onoÅ›Ä‡ O(n).


[#9] (#9) KtÃ³re stwierdzenia z poniÅ¼szych sÄ… prawdziwe dotyczÄ…ce algorytmÃ³w sortowania?
a) Sortowanie przez zliczanie (ang. Counting Sort) ma lepszÄ… zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowÄ… niÅ¼ sortowanie szybkie (ang. QuickSort) dla dowolnych danych wejÅ›ciowych.
>>b) Sortowanie przez zliczanie ma zÅ‚oÅ¼onoÅ›Ä‡ O(n + k), gdzie k to zakres wartoÅ›ci, co moÅ¼e byÄ‡ lepsze od O(n log n) dla maÅ‚ych k.
c) QuickSort jest algorytmem stabilnym.
d) MergeSort nie wymaga dodatkowej pamiÄ™ci (dziaÅ‚a w miejscu).
>>e) Sortowanie przez zliczanie jest algorytmem stabilnym.
f) Heapsort jest algorytmem stabilnym.


[#10] (#10) WskaÅ¼ odpowiedzi prawdziwe dotyczÄ…ce list przeskakiwania:
>>a) Lista przeskakiwania (skip list) moÅ¼e byÄ‡ rozwaÅ¼ana jako probabilistyczna alternatywa drzewa AVL.
>>b) Operacje wyszukiwania, wstawiania i usuwania w liÅ›cie przeskakiwania majÄ… Å›redniÄ… zÅ‚oÅ¼onoÅ›Ä‡ O(log n).
c) Lista przeskakiwania wymaga, aby dane byÅ‚y przechowywane w sposÃ³b nieposortowany.
d) KaÅ¼dy element w liÅ›cie przeskakiwania ma zawsze takÄ… samÄ… liczbÄ™ wskaÅºnikÃ³w do przodu.
e) Lista przeskakiwania gwarantuje pesymistyczny czas wyszukiwania O(log n).
f) Skip list nie wymaga dodatkowej pamiÄ™ci na wskaÅºniki.


[#11] (#11) Zbudowano drzewo binarne zawierajÄ…ce liczby od 1, 2, do 15 w ten sposÃ³b, Å¼e jako korzeÅ„ drzewa wziÄ™to 1, jako jego dzieci liczby 2 i 3 a w
kolejnym rzÄ™dzie 4,5,6,7 tak, Å¼e 4 i 5 to dzieci wÄ™zÅ‚a o kluczu 2 a 6, 7 to dzieci wÄ™zÅ‚a z kluczem 4. Podobnie, w kolejnym rzÄ™dzie utworzono
wÄ™zÅ‚y od 8 do 15.
a) 15, 1, 2, 3 ,4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15
>>b) 15, 7, 3, 1, 2, 4, 8, 9, 5, 10, 11, 6, 12, 13, 14
c) 1, 2, 4, 8, 9, 5, 10, 11, 3, 6, 12, 13, 7, 14, 15
d) 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
e) 15, 7, 14, 3, 6, 12, 13, 1, 2, 4, 8, 9, 5, 10, 11
f) 1, 3, 7, 15, 14, 6, 13, 12, 2, 5, 11, 10, 4, 9, 8


[#12] (#12) Zbudowano drzewo binarne zawierajÄ…ce liczby od 1, 2, do 15 w ten sposÃ³b, Å¼e jako korzeÅ„ drzewa wziÄ™to 1, jako jego dzieci liczby 2 i 3 a w
kolejnym rzÄ™dzie 4,5,6,7 tak, Å¼e 4 i 5 to dzieci wÄ™zÅ‚a o kluczu 2 a 6, 7 to dzieci wÄ™zÅ‚a z kluczem 4. Podobnie, w kolejnym rzÄ™dzie utworzono
wÄ™zÅ‚y od 8 do 15. OkreÅ›l prawdziwoÅ›Ä‡ nastÄ™pujacych stwierdzeÅ„:
a) 15, 7, 3, 1, 14 , 6 ,1, 30, 13, 4, 5, 8, 9, 10, 11
>>b) KolejnoÅ›Ä‡ In-order dla peÅ‚nego drzewa binarnego wypeÅ‚nionego poziomami od 1 do 15 to: 8, 4, 9, 2, 10, 5, 11, 1, 12, 6, 13, 3, 14, 7, 15
c) WÄ™zeÅ‚ 1 jest ostatnim wÄ™zÅ‚em w przejÅ›ciu In-order.
d) WÄ™zeÅ‚ 15 jest korzeniem tego drzewa.
e) PrzejÅ›cie In-order dla tego drzewa daje liczby w kolejnoÅ›ci rosnÄ…cej.
f) WÄ™zeÅ‚ 8 jest korzeniem lewego poddrzewa.


[#13] (#13) Rachunek predykatÃ³w:
a) nie zawiera Å¼adnych aksjomatÃ³w dla kwantyfikatorÃ³w.
>>b) zawiera reguÅ‚y wnioskowania i aksjomaty dotyczÄ…ce kwantyfikatorÃ³w ogÃ³lnego i egzystencjalnego.
c) jest toÅ¼samy z klasycznym rachunkiem zdaÅ„.
d) nie pozwala na uÅ¼ywanie symboli relacyjnych.
>>e) rozszerza rachunek zdaÅ„ o kwantyfikatory i symbole relacyjne/funkcyjne.
f) jest rozstrzygalny w sensie ogÃ³lnym.


[#14] (#14) Prawo transpozycji (p -> q) <=> (~q -> ~p):
>>a) Pozwala przyjÄ…Ä‡, Å¼e prawdziwoÅ›Ä‡ zdania: "JeÅ›li Kopernik nie urodziÅ‚ siÄ™ w Krakowie, to Kepler nie urodziÅ‚ siÄ™ w Toruniu" pociÄ…ga prawdziwoÅ›Ä‡ zdania: "jeÅ›li Kepler urodziÅ‚ siÄ™ w Toruniu, to Kopernik urodziÅ‚ siÄ™ w Krakowie".
b) Orzeka, Å¼e z faÅ‚szywoÅ›ci implikacji wynika prawdziwoÅ›Ä‡ jej nastÄ™pnika.
c) Jest podstawÄ… dowodÃ³w wprost w matematyce.
d) MÃ³wi, Å¼e koniunkcja jest przemienna.
e) GÅ‚osi, Å¼e z p -> q wynika ~p -> ~q.
f) Dotyczy wyÅ‚Ä…cznie kwantyfikatorÃ³w ogÃ³lnych.


[#15] (#15) TeoriÄ… w sensie logicznym w ustalonym jÄ™zyku L nazywamy:
a) zbiÃ³r wszystkich konsekwencji logicznych zbioru zdaÅ„ majÄ…cych swÃ³j dowÃ³d w tej teorii.
>>b) zbiÃ³r zdaÅ„ zamkniÄ™ty ze wzglÄ™du na operacjÄ™ konsekwencji.
c) dowolny zbiÃ³r formuÅ‚ otwartych.
d) zbiÃ³r wszystkich tautologii danego jÄ™zyka.
e) zbiÃ³r aksjomatÃ³w, ktÃ³re nie sÄ… ze sobÄ… spÃ³jne.
f) dowolny zbiÃ³r sÅ‚Ã³w nad alfabetem L.


[#16] (#16) Model dla teorii rachunku predykatÃ³w:
a) Musi zawieraÄ‡ symbole funkcyjne, interpretujÄ…ce w modelu zmienne jÄ™zyka tej teorii.
>>b) SkÅ‚ada siÄ™ z niepustej dziedziny oraz interpretacji symboli predykatywnych, funkcyjnych i staÅ‚ych.
c) Jest zawsze skoÅ„czony.
d) Nie zaleÅ¼y od jÄ™zyka teorii.
e) Jest zbiorem wszystkich zdaÅ„ prawdziwych w danej teorii.
f) MoÅ¼e mieÄ‡ pustÄ… dziedzinÄ™ (uniwersum).


[#17] (#17) Twierdzenie o peÅ‚noÅ›ci dla klasycznego rachunku zdaÅ„ orzeka, Å¼e:
a) KaÅ¼de zdanie klasycznego rachunku zdaÅ„ jest formuÅ‚Ä… (w jego jÄ™zyku), lecz nie kaÅ¼da formuÅ‚a jest zdaniem.
>>b) KaÅ¼da tautologia jest dowodliwa w systemie aksjomatycznym.
c) System logiczny jest niespÃ³jny.
d) KaÅ¼dy model jest skoÅ„czony.
e) KaÅ¼dy zbiÃ³r zdaÅ„ sprzecznych posiada model.
f) Rachunek zdaÅ„ jest niezupeÅ‚ny.


[#18] (#18) W jÄ™zyku rachunku predykatÃ³w wyrÃ³Å¼niÄ‡ moÅ¼emy:
a) wyÅ‚Ä…cznie termy, bez Å¼adnych typÃ³w formuÅ‚.
>>b) termy, formuÅ‚y atomowe oraz formuÅ‚y zÅ‚oÅ¼one (z uÅ¼yciem spÃ³jnikÃ³w i kwantyfikatorÃ³w).
c) tylko staÅ‚e i zmienne, bez predykatÃ³w.
d) wyÅ‚Ä…cznie kwantyfikatory.
e) tylko zdania, bez formuÅ‚ otwartych.
f) wyÅ‚Ä…cznie symbole relacyjne.


[#19] (#19) Zdanie "JeÅ›li SÅ‚owacki wielkim poetÄ… byÅ‚, to jeÅ›li przez KrakÃ³w przepÅ‚ywa Nil, to SÅ‚owacki wielkim poetÄ… byÅ‚" (schemat p -> (q -> p)) jest:
a) nie da siÄ™ oceniÄ‡ bez znajomoÅ›ci jego modelu
>>b) tautologiÄ… klasycznego rachunku zdaÅ„.
c) zdaniem zawsze faÅ‚szywym (kontrtautologiÄ…).
d) zdaniem speÅ‚nialnym, ale nie bÄ™dÄ…cym tautologiÄ….
e) zdaniem przygodnym.
f) zdaniem faÅ‚szywym w modelu standardowym.


[#20] (#20) Tautologia rachunku predykatÃ³w to:
>>a) formuÅ‚a prawdziwa w kaÅ¼dym modelu (przy kaÅ¼dej interpretacji).
b) formuÅ‚a prawdziwa w przynajmniej jednym modelu.
c) formuÅ‚a, ktÃ³ra nie zawiera kwantyfikatorÃ³w.
d) zdanie, ktÃ³re jest prawdziwe w modelu standardowym liczb naturalnych.
e) formuÅ‚a, ktÃ³ra posiada dowÃ³d w arytmetyce Peano.
f) zdanie, ktÃ³re jest faÅ‚szywe w przynajmniej jednym modelu.


[#21] (#21) Logika pierwszego rzÄ™du to:
a) logika bez Å¼adnych kwantyfikatorÃ³w
>>b) logika dopuszczajÄ…ca kwantyfikowanie wyÅ‚Ä…cznie po zmiennych obiektowych (indywiduach).
c) logika dopuszczajÄ…ca kwantyfikowanie po zbiorach i relacjach.
d) system logiczny, w ktÃ³rym nie istniejÄ… zmienne.
e) logika, w ktÃ³rej nie moÅ¼na definiowaÄ‡ relacji.
f) logika, w ktÃ³rej kaÅ¼dy model jest skoÅ„czony.


[#22] (#22) Kwantyfikatory "istnieje takie x, Å¼e" oraz "dla kaÅ¼dego x, takiego, Å¼e":
>>a) majÄ… swoje semantyczne interpretacje w modelach dla jÄ™zyka, w ktÃ³rym wystÄ™pujÄ….
b) sÄ… spÃ³jnikami logicznymi o argumentach zdaniowych.
c) nie mogÄ… wystÄ™powaÄ‡ w jednej formule jednoczeÅ›nie.
d) odnoszÄ… siÄ™ wyÅ‚Ä…cznie do zbiorÃ³w skoÅ„czonych.
e) sÄ… definiowane wyÅ‚Ä…cznie przez reguÅ‚y syntaktyczne.
f) nie podlegajÄ… negacji.


[#23] (#23) Funkcja interpretacji semantycznej, okreÅ›lonej dla jÄ™zyka rachunku predykatÃ³w:
>>a) interpretuje predykaty jako relacje w dziedzinie modelu.
b) przypisuje kaÅ¼demu zdaniu wartoÅ›Ä‡ "prawda" niezaleÅ¼nie od modelu.
c) interpretuje zmienne wolne jako kwantyfikatory ogÃ³lne.
d) sÅ‚uÅ¼y wyÅ‚Ä…cznie do upraszczania formuÅ‚.
>>e) interpretuje symbole funkcyjne jako funkcje w dziedzinie modelu.
f) przypisuje kaÅ¼demu termowi wartoÅ›Ä‡ logicznÄ….


[#24] (#24) Twierdzenie o dedukcji:
>>a) pozwala przenieÅ›Ä‡ przesÅ‚anki do treÅ›ci implikacji we wniosku (jeÅ›li ze zbioru G i zdania A wynika B, to z G wynika A -> B).
b) pozwala przenieÅ›Ä‡ przesÅ‚anki do zbioru wnioskÃ³w.
c) mÃ³wi, Å¼e kaÅ¼da teoria jest rozstrzygalna.
d) dotyczy wyÅ‚Ä…cznie rachunku predykatÃ³w z identycznoÅ›ciÄ….
e) orzeka o peÅ‚noÅ›ci systemu logicznego.
f) mÃ³wi, Å¼e z A wynika B wtedy i tylko wtedy, gdy A jest faÅ‚szywe.


[#25] (#25) KaÅ¼da permutacja zbioru skoÅ„czonego:
a) moÅ¼e byÄ‡ w sposÃ³b jednoznaczny rozÅ‚oÅ¼ona na niekoniecznie rozÅ‚Ä…czne transpozycje.
>>b) moÅ¼e byÄ‡ rozÅ‚oÅ¼ona na iloczyn rozÅ‚Ä…cznych cykli w sposÃ³b jednoznaczny (z dokÅ‚adnoÅ›ciÄ… do kolejnoÅ›ci czynnikÃ³w).
c) jest zawsze transpozycjÄ….
d) nie moÅ¼e byÄ‡ przedstawiona jako zÅ‚oÅ¼enie cykli.
e) ma zawsze parzystÄ… liczbÄ™ inwersji.
f) jest cyklem o dÅ‚ugoÅ›ci n.


[#26] (#26) W grafie wÅ‚aÅ›ciwym nieskierowanym:
a) najniÅ¼szy stopieÅ„ wÄ™zÅ‚a moÅ¼e byÄ‡ mniejszy od spÃ³jnoÅ›ci krawÄ™dziowej.
>>b) spÃ³jnoÅ›Ä‡ krawÄ™dziowa jest zawsze mniejsza lub rÃ³wna minimalnemu stopniowi wierzchoÅ‚ka (lambda(G) <= delta(G)).
c) liczba wierzchoÅ‚kÃ³w o stopniu nieparzystym musi byÄ‡ nieparzysta.
d) suma stopni wierzchoÅ‚kÃ³w jest rÃ³wna liczbie krawÄ™dzi.
e) spÃ³jnoÅ›Ä‡ wierzchoÅ‚kowa jest zawsze wiÄ™ksza od krawÄ™dziowej.
f) graf jest drzewem, jeÅ›li ma n krawÄ™dzi.


[#27] (#27) Grupa symetrii danej figury geometrycznej to grupa tych przeksztaÅ‚ceÅ„ pÅ‚aszczyzny, wzglÄ™dem ktÃ³rych danafigura jest niezmiennicza.
DziaÅ‚aniem grupowym jest skÅ‚adanie przeksztaÅ‚ceÅ„.
a) Grupa symetrii siedmiokÄ…ta foremnego jest siedmioelementowa.
>>b) Jest grupÄ… dihedralnÄ… D7 i posiada 14 elementÃ³w (7 obrotÃ³w i 7 symetrii osiowych).
c) Jest grupÄ… cyklicznÄ… Z7.
d) Nie zawiera Å¼adnych symetrii osiowych.
e) Jest grupÄ… abelowÄ….
f) Zawiera dokÅ‚adnie 49 elementÃ³w.


[#28] (#28) GrupÄ… nie jest:
a) (C[0,1], +) - zbiÃ³r wszystkich funkcji ciÄ…gÅ‚ych o dziedzinie w [0,1] z dodawaniem funkcji po wartoÅ›ciach jako dziaÅ‚anie grupowym.
>>b) (N, +) - zbiÃ³r liczb naturalnych z dodawaniem.
c) (Z, +) - zbiÃ³r liczb caÅ‚kowitych z dodawaniem.
d) (R*, *) - zbiÃ³r liczb rzeczywistych bez zera z mnoÅ¼eniem.
e) (Q, +) - zbiÃ³r liczb wymiernych z dodawaniem.
f) (Z_n, +_n) - zbiÃ³r reszt z dzielenia przez n z dodawaniem modulo n.


[#29] (#29) Niech X bÄ™dzie zbiorem czÄ™Å›ciowo uporzÄ…dkowanym.
a) JeÅ›li X jest skoÅ„czony, to element maksymalny jest rÃ³wnoczeÅ›nie elementem najwiÄ™kszym.
>>b) JeÅ›li X ma element najwiÄ™kszy, to jest on jedynym elementem maksymalnym.
c) KaÅ¼dy zbiÃ³r czÄ™Å›ciowo uporzÄ…dkowany ma element najmniejszy.
d) Relacja czÄ™Å›ciowego porzÄ…dku jest zwrotna, symetryczna i przechodnia.
e) KaÅ¼dy podzbiÃ³r X ma kres gÃ³rny.
f) Element minimalny jest zawsze elementem najmniejszym.


[#30] (#30) KostkÄ… Qn nazywamy graf, ktÃ³rego wierzchoÅ‚ki sÄ… zaetykietowane wszystkimi moÅ¼liwymi zerojedynkowymi
ciÄ…gami nâˆ’elementowymi a krawÄ™dzie Å‚Ä…czÄ… te wierzchoÅ‚ki, ktÃ³rych etykiety rÃ³Å¼niÄ… siÄ™ dokÅ‚adnie na jednym
miejscu.
>>a) Kostka Q3 ma 8 wierzchoÅ‚kÃ³w i 12 krawÄ™dzi.
b) Kostka Qn ma n wierzchoÅ‚kÃ³w.
c) Kostka Qn jest grafem peÅ‚nym.
d) KaÅ¼dy wierzchoÅ‚ek w Qn ma stopieÅ„ 2^n.
e) Kostka Qn jest grafem planarnym dla kaÅ¼dego n.
f) Kostka Qn nie jest grafem dwudzielnym.


[#31] (#31) Liczba chromatyczna grafu to minimalna liczba kolorÃ³w, jakimi moÅ¼na pokolorowaÄ‡ wierzchoÅ‚ki grafu tak,
aby Å¼adne dwa wierzchoÅ‚ki poÅ‚Ä…czone krawÄ™dziÄ… nie byÅ‚y tego samego koloru.
>>a) 2
b) 3
c) 4
d) 8
e) 1
f) 5


[#32] (#32) KaÅ¼dy zbiÃ³r czÄ™Å›ciowo uporzÄ…dkowany:
a) ma element maksymalny.
>>b) moÅ¼e nie posiadaÄ‡ elementÃ³w maksymalnych ani minimalnych (np. zbiÃ³r liczb caÅ‚kowitych z relacjÄ… <=).
c) jest zawsze liniowo uporzÄ…dkowany.
d) musi byÄ‡ skoÅ„czony.
e) ma dokÅ‚adnie jeden element najmniejszy.
f) jest gÄ™sty.


[#33] (#33) WskaÅ¼ zdania prawdziwe dotyczÄ…ce porzÄ…dkÃ³w:
a) ZbiÃ³r liczb caÅ‚kowitych z relacjÄ… arytmetycznÄ… â€mniejsze lub rÃ³wneâ€ jest dobrze uporzÄ…dkowany.
>>b) ZbiÃ³r liczb naturalnych z relacjÄ… â€mniejsze lub rÃ³wneâ€ jest dobrze uporzÄ…dkowany.
c) KaÅ¼dy porzÄ…dek liniowy jest dobrym porzÄ…dkiem.
d) Relacja inkluzji podzbiorÃ³w jest zawsze porzÄ…dkiem liniowym.
e) Relacja podzielnoÅ›ci na liczbach naturalnych jest porzÄ…dkiem liniowym.
f) ZbiÃ³r liczb rzeczywistych z relacjÄ… <= jest dobrze uporzÄ…dkowany.


[#34] (#34) JeÅ›li X jest zbiorem nâˆ’elementowym i Y jest zbiorem m-elementowym, n > 0, m > 0, to
>>a) licznoÅ›Ä‡ rodziny wszystkich podzbiorÃ³w zbioru X (zbioru potÄ™gowego) jest rÃ³wna 2^n.
b) liczba wszystkich permutacji zbioru X wynosi n^2.
c) liczba k-elementowych podzbiorÃ³w zbioru X wynosi n! / k!.
d) liczba relacji zwrotnych na zbiorze X wynosi 2^n.
e) liczba wszystkich relacji na zbiorze X wynosi n^n.
f) liczba wszystkich funkcji ze zbioru X w X wynosi n!.


[#35] (#35) Niech Pn oznacza zbiÃ³r permutacji n-elementowych. W P3:
>>a) istniejÄ… dokÅ‚adnie 2 permutacje cykliczne o dÅ‚ugoÅ›ci 3.
b) istnieje 6 permutacji cyklicznych.
c) kaÅ¼da permutacja jest cyklem.
d) nie istnieje permutacja identycznoÅ›ciowa.
e) liczba wszystkich permutacji wynosi 9.
f) kaÅ¼da permutacja jest parzysta.


[#36] (#36) Niech X bÄ™dzie zbiorem n-elementowym (n > 2) i R bÄ™dzie relacjÄ… rÃ³wnowaÅ¼noÅ›ci na X.
a) Liczba klas rÃ³wnowaÅ¼noÅ›ci musi byÄ‡ podzielnikiem liczby n.
>>b) Klasy rÃ³wnowaÅ¼noÅ›ci tworzÄ… partycjÄ™ (podziaÅ‚) zbioru X.
c) KaÅ¼da klasa rÃ³wnowaÅ¼noÅ›ci musi mieÄ‡ tyle samo elementÃ³w.
d) Relacja rÃ³wnowaÅ¼noÅ›ci nie musi byÄ‡ przechodnia.
e) Liczba relacji rÃ³wnowaÅ¼noÅ›ci na X jest rÃ³wna 2^n.
f) Suma wszystkich klas rÃ³wnowaÅ¼noÅ›ci jest zbiorem pustym.


[#37] (#37) Liczby w formacie zmiennoprzecinkowym (wg standardu IEEE 754).
Dodatnie liczby rzeczywiste z zakresu od ğ‘‰ ğ´ğ¿ğ‘€ğ¼ğ‘ = 2.2 â‹… 10âˆ’308 do ğ‘‰ ğ´ğ¿ğ‘€ğ´ğ‘‹ = 1.8 â‹… 10308 sÄ… zapisywane w formacie podwÃ³jnej precyzji z
wzglÄ™dnym bÅ‚Ä™dem zaokrÄ…glenia nie wiÄ™kszym od ğœ€ = 2âˆ’52 â‰ˆ 2.2 â‹… 10âˆ’16 .

KtÃ³re zdania sÄ… prawdziwe?
a) Wszystkie liczby wymierne, poza caÅ‚kowitymi, sÄ… reprezentowane z niezerowym bÅ‚Ä™dem zaokrÄ…glenia.
>>b) Liczby wymierne, ktÃ³rych rozwiniÄ™cie w bazie 2 jest nieskoÅ„czone (np. 0.1), sÄ… reprezentowane z bÅ‚Ä™dem zaokrÄ…glenia.
c) BÅ‚Ä…d wzglÄ™dny reprezentacji jest staÅ‚y dla wszystkich liczb.
d) Liczba 0.1 jest reprezentowana dokÅ‚adnie.
e) Mantysa ma dÅ‚ugoÅ›Ä‡ 64 bitÃ³w.
f) WykÅ‚adnik jest zapisywany w kodzie uzupeÅ‚nieÅ„ do dwÃ³ch (U2).


[#38] (#38) Niech ğ‘, ğ‘, ğ‘ bÄ™dÄ… liczbami rÃ³Å¼nymi od zera, zapisanymi w komputerze w formacie zmiennoprzecinkowym z dokÅ‚adnoÅ›ciÄ… maszynowÄ… ğœ€.
Liczba ğ‘ jest wynikiem operacji arytmetycznej âˆ˜ wykonanej w komputerze i zapisanym w takim samym formacie zmiennoprzecinkowym.
Niech ğ›¿ğ‘ oznacza bÅ‚Ä…d wzglÄ™dny wyniku operacji ğ‘ = ğ‘ âˆ˜ ğ‘. (dokÅ‚adniej: jego wartoÅ›Ä‡ bezwzglÄ™dnÄ…).
W ktÃ³rych przypadkach bÅ‚Ä…d wyniku ğ›¿ğ‘ moÅ¼e byÄ‡ wielokrotnie (kilka rzÄ™dÃ³w) wiÄ™kszy od bÅ‚Ä™dÃ³w argumentÃ³w ğ‘ i ğ‘ , czyli ğ›¿ğ‘ â‰« 2ğœ€
a) w przypadku dzielenia liczby rÃ³Å¼nej od zera przez liczbÄ™ rÃ³Å¼nÄ… od zera.
>>b) w przypadku odejmowania dwÃ³ch liczb o bardzo zbliÅ¼onych wartoÅ›ciach.
c) w przypadku mnoÅ¼enia dwÃ³ch bardzo duÅ¼ych liczb.
d) w przypadku dodawania liczby bardzo maÅ‚ej do bardzo duÅ¼ej.
e) w przypadku wyznaczania pierwiastka kwadratowego.
f) w przypadku podnoszenia do kwadratu.


[#39] (#39) Obliczanie pierwiastkÃ³w ciÄ…gÅ‚ej funkcji ğ‘“ jednej zmiennej rzeczywistej ğ‘¥ metodami iteracyjnymi.
WartoÅ›ci funkcji dla pierwszych dwÃ³ch wartoÅ›ci wyrazÃ³w ciÄ…gu iteracyjnego ğ‘¥0 i ğ‘¥1 speÅ‚niajÄ… nierÃ³wnoÅ›Ä‡ ğ‘“(ğ‘¥0 )ğ‘“(ğ‘¥1 ) < 0.
CiÄ…g iteracyjny bÄ™dzie zbieÅ¼ny do miejsca zerowego dowolnej funkcji speÅ‚niajÄ…cej powyÅ¼sze warunki, jeÅ¼eli zastosujemy metodÄ™
a) siecznych
>>b) bisekcji (poÅ‚owienia przedziaÅ‚u).
c) Newtona (stycznych).
d) iteracji prostych.
e) odwrotnej interpolacji kwadratowej.
f) Å¼adna z powyÅ¼szych.


[#40] (#40) NaleÅ¼y rozwiÄ…zaÄ‡ ukÅ‚ad rÃ³wnaÅ„ liniowych ğ´ğ‘¥ = ğ‘ z dowolnÄ… rzeczywistÄ…, nieosobliwÄ… macierzÄ… ğ´ ğ‘›Ã—ğ‘›, ğ‘› â‰« 1.
ZÅ‚oÅ¼onoÅ›Ä‡ obliczeniowa algorytmu obliczenia rozwiÄ…zania jest mniejsza (w stosunku do metody eliminacyjnej Gaussa), jeÅ¼eli macierz ğ´ jest
zadana w postaci:
Zaznacz zdania prawdziwe.
>>a) macierz A jest juÅ¼ rozÅ‚oÅ¼ona na iloczyn A = LU.
b) macierz A jest peÅ‚na i niesymetryczna.
c) macierz A ma wymiar 10x10.
d) stosujemy metodÄ™ Cramera dla duÅ¼ych n.
e) macierz A jest macierzÄ… osobliwÄ….
f) macierz A jest macierzÄ… Hilberta.


[#41] (#41) RozkÅ‚ad wedÅ‚ug wartoÅ›ci szczegÃ³lnych (SVD):
a) jest moÅ¼liwy tylko dla macierzy kwadratowej.
>>b) jest moÅ¼liwy dla dowolnej macierzy prostokÄ…tnej m x n.
c) wymaga, aby macierz byÅ‚a dodatnio okreÅ›lona.
d) nie pozwala na wyznaczenie rzÄ™du macierzy.
e) macierze U i V w rozkÅ‚adzie sÄ… macierzami trÃ³jkÄ…tnymi.
f) wartoÅ›ci osobliwe sÄ… zawsze ujemne.


[#42] (#42) KtÃ³re zdania sÄ… prawdziwe dotyczÄ…ce eliminacji Gaussa?
>>a) WybÃ³r elementu gÅ‚Ã³wnego (pivoting) jest stosowany w celu poprawy stabilnoÅ›ci numerycznej algorytmu.
>>b) WybÃ³r elementu gÅ‚Ã³wnego jest realizowany n - 1 razy w algorytmie eliminacyjnym Gaussa.
c) Eliminacja Gaussa bez wyboru elementu gÅ‚Ã³wnego jest zawsze stabilna.
d) ZÅ‚oÅ¼onoÅ›Ä‡ czasowa eliminacji Gaussa wynosi O(n^2).
e) Eliminacja Gaussa sÅ‚uÅ¼y do wyznaczania wartoÅ›ci wÅ‚asnych.
f) Macierz po eliminacji Gaussa jest macierzÄ… diagonalnÄ….


[#43] (#43) KtÃ³re zdanie jest prawdziwe dotyczÄ…ce wyznaczania wartoÅ›ci wÅ‚asnych?
a) Aby wyznaczyÄ‡ n wartoÅ›ci wÅ‚asnych dowolnej macierzy kwadratowej A nÃ—n nie stosuje siÄ™ metod iteracyjnych.
>>b) Dla macierzy o stopniu n > 4 nie istniejÄ… ogÃ³lne algorytmy skoÅ„czone (algebraiczne) wyznaczajÄ…ce wartoÅ›ci wÅ‚asne (wynika to z twierdzenia Abla).
c) WartoÅ›ci wÅ‚asne macierzy trÃ³jkÄ…tnej nie leÅ¼Ä… na jej przekÄ…tnej.
d) KaÅ¼da macierz kwadratowa ma wyÅ‚Ä…cznie rzeczywiste wartoÅ›ci wÅ‚asne.
e) Metoda potÄ™gowa znajduje wszystkie wartoÅ›ci wÅ‚asne jednoczeÅ›nie.
f) WartoÅ›ci wÅ‚asne macierzy A i A^T sÄ… zawsze rÃ³Å¼ne.


[#44] (#44) KtÃ³re zdania sÄ… prawdziwe dotyczÄ…ce rozkÅ‚adu SVD (A = UÎ£V^T)?
>>a) RozkÅ‚ad SVD jest wykorzystywany w kompresji obrazÃ³w poprzez ucinanie najmniejszych wartoÅ›ci osobliwych.
b) Macierz Î£ jest macierzÄ… ortogonalnÄ….
c) Macierze U i V sÄ… macierzami diagonalnymi.
d) WartoÅ›ci osobliwe na przekÄ…tnej Î£ mogÄ… byÄ‡ ujemne.
>>e) Macierze U i V sÄ… macierzami ortogonalnymi.
f) SVD nie pozwala na obliczenie macierzy pseudoodwrotnej.


[#45] (#45) Szukanie minimum funkcji wielu zmiennych.
Przyjmijmy, Å¼e funkcja, ktÃ³rej minimum naleÅ¼y znaleÅºÄ‡, jest ,,funkcjÄ… kwadratowÄ…'', a dokÅ‚adniej - ma postaÄ‡ formy kwadratowej
ğ¹ (ğ‘¥) = ğ‘¥ğ‘‡ ğ´ğ‘¥ + ğ‘ğ‘‡ ğ‘¥ + ğ‘ , ğ‘¥ âˆˆ â„ ğ‘› i macierz A jest dowolnÄ… macierzÄ… dodatnio okreÅ›lonÄ…, czyli funkcja jest wypukÅ‚a,.
ğ‘˜ - liczba iteracji koniecznych do przejÅ›cia od dowolnego punktu startowego do punktu, w ktÃ³rym funkcja ğ¹ ma minimum.
KtÃ³re zdania sÄ… prawdziwe?
a) Dla bezgradientowej metody Neldera-Meada: k < n.
>>b) Metoda sprzÄ™Å¼onych gradientÃ³w znajduje minimum takiej funkcji w co najwyÅ¼ej n iteracjach (w arytmetyce dokÅ‚adnej).
c) Metoda najszybszego spadku zawsze zbiega w jednej iteracji.
d) Metoda Newtona wymaga obliczania tylko pierwszej pochodnej.
e) Minimum funkcji kwadratowej nie istnieje, jeÅ›li A jest dodatnio okreÅ›lona.
f) Metoda Newtona dla funkcji kwadratowej zbiega w n iteracjach.


[#46] (#46) PrzykÅ‚ad zadania liniowej aproksymacji metodÄ… najmniejszych kwadratÃ³w (Linear Least Squares)
Dane:
20 pomiarÃ³w poÅ‚oÅ¼enia ğ‘  ğ‘– pojazdu w ruchu prostoliniowym w chwilach ğ‘¡ğ‘– , ğ‘– = 1, 2, â€¦ , 20.
Funkcja aproksymujÄ…ca zaleÅ¼noÅ›ci poÅ‚oÅ¼enia od czasu:
ğ‘ (ğ‘¡) = ğ‘0 + ğ‘1 ğ‘¡ + ğ‘2 ğ‘¡2 .
KtÃ³re zdania sÄ… prawdziwe?
a) Podany przykÅ‚ad nie jest odpowiedni dla liniowego zadania najmniejszych kwadratÃ³w, bo funkcja aproksymujÄ…ca jest funkcjÄ… kwadratowÄ….
>>b) Jest to liniowe zadanie najmniejszych kwadratÃ³w, poniewaÅ¼ funkcja jest liniowa wzglÄ™dem parametrÃ³w a0, a1, a2.
c) Wymaga rozwiÄ…zania ukÅ‚adu rÃ³wnaÅ„ nieliniowych.
d) MoÅ¼na jÄ… stosowaÄ‡ tylko dla 2 pomiarÃ³w.
e) Parametry a0, a1, a2 muszÄ… byÄ‡ liczbami caÅ‚kowitymi.
f) BÅ‚Ä…d aproksymacji w kaÅ¼dym punkcie musi wynosiÄ‡ zero.


[#47] (#47) Metoda ilorazÃ³w rÃ³Å¼nicowych.
ZaleÅ¼noÅ›Ä‡ bÅ‚Ä™du przybliÅ¼ania wartoÅ›ci pochodnej funkcji analitycznej ğ‘“ w punkcie ğ‘¥, ğ‘¥ âˆˆ ğ‘… metodÄ… ilorazÃ³w rÃ³Å¼nicowych wedÅ‚ug formuÅ‚y
dwupunktowej od kroku â„ moÅ¼na zapisaÄ‡ wzorem

                          âˆ’ ğ‘“ â€² (ğ‘¥)âˆ£âˆ£ .
            ğ‘“(ğ‘¥+â„)âˆ’ğ‘“(ğ‘¥)
ğœ€(â„) = âˆ£âˆ£ â„
>>a) W algorytmie obliczania przybliÅ¼enia wartoÅ›ci pochodnej metodÄ… ilorazÃ³w z urojonym krokiem ih nie wystÄ™puje odejmowanie bliskich wartoÅ›ci, co eliminuje bÅ‚Ä…d kasowania.
b) Metoda ilorazÃ³w rÃ³Å¼nicowych jest zawsze dokÅ‚adniejsza od rÃ³Å¼niczkowania automatycznego.
c) Krok h powinien byÄ‡ jak najwiÄ™kszy, aby zminimalizowaÄ‡ bÅ‚Ä…d metody.
d) Metoda ta wymaga znajomoÅ›ci drugiej pochodnej.
>>e) RÃ³Å¼niczkowanie z urojonym krokiem wymaga uÅ¼ycia liczb zespolonych.
f) Metoda ilorazÃ³w rÃ³Å¼nicowych wstecz jest zawsze rzÄ™du O(h^2).


[#48] (#48) RÃ³Å¼niczkowanie automatyczne:
a) MetodÄ™ rÃ³Å¼niczkowania automatycznego moÅ¼na stosowaÄ‡ tylko dla funkcji jednej zmiennej.
>>b) Pozwala na obliczanie wartoÅ›ci pochodnych z dokÅ‚adnoÅ›ciÄ… maszynowÄ…, wykorzystujÄ…c reguÅ‚Ä™ Å‚aÅ„cuchowÄ….
c) Polega na symbolicznym wyznaczaniu wzoru pochodnej.
d) Jest znacznie wolniejsze od metod ilorazÃ³w rÃ³Å¼nicowych dla funkcji wielu zmiennych.
e) Wymaga numerycznego caÅ‚kowania funkcji.
f) Nie pozwala na obliczanie gradientÃ³w.


[#49] (#49) Zaznacz zdanie prawdziwe dotyczÄ…ce rozkÅ‚adu QR:
a) RozkÅ‚ad danej macierzy A na iloczyn QR jest jednoznaczny.
>>b) RozkÅ‚ad QR jest jednoznaczny, jeÅ›li macierz A jest peÅ‚nego rzÄ™du kolumnowego, a elementy na przekÄ…tnej macierzy R sÄ… dodatnie.
c) Metoda Grama-Schmidta jest najbardziej stabilnÄ… numerycznie metodÄ… wyznaczania rozkÅ‚adu QR.
d) Macierz Q w rozkÅ‚adzie QR jest macierzÄ… trÃ³jkÄ…tnÄ….
e) RozkÅ‚ad QR nie moÅ¼e byÄ‡ stosowany do rozwiÄ…zywania zadaÅ„ najmniejszych kwadratÃ³w.
f) Macierz R jest macierzÄ… ortogonalnÄ….


[#50] (#50) Pomiary masy ciaÅ‚a i wzrostu 100 osÃ³b sÄ… danymi dla aproksymacji zaleÅ¼noÅ›ci masy od wzrostu funkcjÄ… afinicznÄ… ğ‘š = ğ‘0 + ğ‘1 â„ . Warunki
zgodnoÅ›ci danych z funkcjÄ… aproksymujÄ…cÄ… zapiszemy jako
>>a) Prowadzi do rozwiÄ…zania ukÅ‚adu nadwyznaczonego (100 rÃ³wnaÅ„ z 2 niewiadomymi) w sensie najmniejszych kwadratÃ³w.
b) Wymaga odwrÃ³cenia macierzy 100x100.
c) Zawsze daje rozwiÄ…zanie przechodzÄ…ce przez wszystkie punkty pomiarowe.
d) Nie moÅ¼na jej stosowaÄ‡, gdy pomiary sÄ… obarczone bÅ‚Ä™dem.
e) Funkcja bÅ‚Ä™du jest funkcjÄ… liniowÄ….
>>f) RozwiÄ…zanie zawsze istnieje i jest jednoznaczne, jeÅ›li macierz ukÅ‚adu ma peÅ‚ny rzÄ…d.


[#51] (#51) KtÃ³re z poniÅ¼szych zdaÅ„ jest jednym z aksjomatÃ³w prawdopodobieÅ„stwa KoÅ‚mogorowa dla przestrzeni probabilistycznej (Î©, , ğ‘ƒ) :
>>a) P(A) >= 0 dla kaÅ¼dego zdarzenia A.
b) P(A) <= 0.5 dla kaÅ¼dego zdarzenia A.
c) P(Omega) = 0.
d) P(A u B) = P(A) + P(B) dla dowolnych zdarzeÅ„ A, B.
>>e) P(Omega) = 1.
f) P(A) + P(A') = 1 (to jest wniosek, ale czÄ™sto mylony z aksjomatem).


[#52] (#52) W statystyce populacjÄ… nazywamy:
a) zbiÃ³r wszystkich moÅ¼liwych cech pewnego wybranego parametru.
>>b) zbiÃ³r wszystkich elementÃ³w, o ktÃ³rych chcemy wyciÄ…gnÄ…Ä‡ wnioski.
c) podzbiÃ³r elementÃ³w wybrany do badania.
d) Å›redniÄ… wartoÅ›Ä‡ z prÃ³by.
e) zbiÃ³r wszystkich wynikÃ³w pomiarÃ³w w prÃ³bie.
f) wyÅ‚Ä…cznie grupÄ™ ludzi w danym regionie.


[#53] (#53) W statystyce estymatorem nazywamy:
>>a) dowolnÄ… statystykÄ™ (funkcjÄ™ z prÃ³by) sÅ‚uÅ¼Ä…cÄ… do oszacowania nieznanego parametru populacji.
b) bÅ‚Ä…d pomiarowy.
c) wartoÅ›Ä‡ parametru w caÅ‚ej populacji.
d) liczbÄ™ elementÃ³w w prÃ³bie.
e) hipotezÄ™ zerowÄ….
f) poziom istotnoÅ›ci testu.


[#54] (#54) W statystyce bÅ‚Ä™dem pierwszego rodzaju nazywamy:
a) przyjÄ™cie hipotezy alternatywnej przy niskiej wielkoÅ›ci efektu.
>>b) odrzucenie hipotezy zerowej, mimo Å¼e jest ona prawdziwa.
c) nieodrzucenie hipotezy zerowej, mimo Å¼e jest ona faÅ‚szywa.
d) bÅ‚Ä…d wynikajÄ…cy z maÅ‚ej liczebnoÅ›ci prÃ³by.
e) bÅ‚Ä…d gruby pomiaru.
f) bÅ‚Ä…d zaokrÄ…glenia w obliczeniach statystycznych.


[#55] (#55) LiczbÄ™ wszystkich rÃ³Å¼nych k-elementowych ciÄ…gÃ³w (wariacji z powtÃ³rzeniami) utworzonych ze zbioru n-elementowego liczymy wzorem:
>>a) n^k
b) n! / (n-k)!
c) symbol Newtona (n nad k)
d) k^n
e) n! / k!
f) 2^n


[#56] (#56) W rachunku prawdopodobieÅ„stwa wzÃ³r na prawdopodobieÅ„stwo caÅ‚kowite:
a) jak znaleÅºÄ‡ wartoÅ›Ä‡ granicznÄ… prawdopodobieÅ„stwa sumy przeliczalnej rodziny wstÄ™pujÄ…cej zbiorÃ³w.
>>b) pozwala obliczyÄ‡ prawdopodobieÅ„stwo zdarzenia poprzez sumowanie prawdopodobieÅ„stw warunkowych wzglÄ™dem zupeÅ‚nego ukÅ‚adu zdarzeÅ„.
c) dotyczy wyÅ‚Ä…cznie zdarzeÅ„ niezaleÅ¼nych.
d) sÅ‚uÅ¼y do obliczania prawdopodobieÅ„stwa a posteriori (wzÃ³r Bayesa).
e) wymaga, aby zdarzenia warunkujÄ…ce miaÅ‚y prawdopodobieÅ„stwo 1.
f) mÃ³wi, Å¼e P(A|B) = P(B|A).


[#57] (#57) W rachunku prawdopodobieÅ„stwa zdarzenia niezaleÅ¼ne od kaÅ¼dego innego zdarzenia:
a) istniejÄ…, ale mogÄ… byÄ‡ tylko zbiorem pustym, albo caÅ‚Ä… przestrzeniÄ….
>>b) to zdarzenia o prawdopodobieÅ„stwie 0 lub 1.
c) nie istniejÄ… w Å¼adnej przestrzeni probabilistycznej.
d) to wszystkie zdarzenia w przestrzeni dyskretnej.
e) to zdarzenia, ktÃ³rych suma wynosi 1.
f) to zdarzenia rozÅ‚Ä…czne.


[#58] (#58) Sigma-ciaÅ‚em zbiorÃ³w borelowskich na R nazywamy:
>>a) najmniejsze sigma-ciaÅ‚o na R ktÃ³re zawiera wszystkie zbiory otwarte (lub przedziaÅ‚y postaci (-inf, a]).
b) zbiÃ³r wszystkich podzbiorÃ³w R.
c) zbiÃ³r wszystkich liczb wymiernych.
d) zbiÃ³r przedziaÅ‚Ã³w domkniÄ™tych.
e) zbiÃ³r wszystkich funkcji ciÄ…gÅ‚ych.
f) zbiÃ³r wszystkich punktÃ³w na prostej.


[#59] (#59) ZmiennÄ… losowÄ… X : Omega -> R nazywamy funkcjÄ™, dla ktÃ³rej:
>>a) przeciwobraz dowolnego przedziaÅ‚u (-inf, a] dla a w R jest zdarzeniem (naleÅ¼y do sigma-ciaÅ‚a).
b) obraz kaÅ¼dego zdarzenia jest liczbÄ… dodatniÄ….
c) dziedzina jest zbiorem liczb rzeczywistych.
d) wartoÅ›ci sÄ… zawsze caÅ‚kowite.
e) funkcja jest zawsze rosnÄ…ca.
f) funkcja jest bijekcjÄ….


[#60] (#60) KtÃ³re z podanych wÅ‚asnoÅ›ci sÄ… wÅ‚asnoÅ›ciami kaÅ¼dej dystrybuanty FX zmiennej losowej X:
a) FX jest Å›ciÅ›le rosnÄ…ca.
>>b) FX jest niemalejÄ…ca i prawostronnie ciÄ…gÅ‚a.
c) FX(x) dÄ…Å¼y do 1 gdy x dÄ…Å¼y do minus nieskoÅ„czonoÅ›ci.
d) FX jest zawsze funkcjÄ… ciÄ…gÅ‚Ä….
>>e) Granica FX(x) przy x dÄ…Å¼Ä…cym do plus nieskoÅ„czonoÅ›ci wynosi 1.
f) FX(x) moÅ¼e przyjmowaÄ‡ wartoÅ›ci ujemne.


[#61] (#61) Wariancja zmiennej losowej sÅ‚uÅ¼y do:
a) wyznaczania skoÅ›noÅ›ci dystrybucji zmiennej losowej.
>>b) okreÅ›lenia stopnia rozproszenia wartoÅ›ci zmiennej losowej wokÃ³Å‚ jej wartoÅ›ci oczekiwanej.
c) obliczania najbardziej prawdopodobnej wartoÅ›ci.
d) wyznaczania mediany.
e) okreÅ›lenia kierunku zaleÅ¼noÅ›ci miÄ™dzy dwiema zmiennymi.
f) obliczania wartoÅ›ci Å›redniej.


[#62] (#62) JeÅ¼eli dwie zmienne losowe X i Y sÄ… niezaleÅ¼ne, to:
a) rozkÅ‚ad ich sumy jest sumÄ… ich rozkÅ‚adÃ³w.
>>b) wariancja ich sumy jest sumÄ… ich wariancji (Var(X+Y) = Var(X) + Var(Y)).
c) ich korelacja wynosi 1.
d) ich wartoÅ›ci oczekiwane muszÄ… byÄ‡ rÃ³wne 0.
>>e) ich kowariancja wynosi 0.
f) P(X|Y) = P(Y).


[#63] (#63) Dany jest graf G utworzony z n-wierzchoÅ‚kowej kliki (n>5), poprzez usuniÄ™cie 3 krawÄ™dzi. WskaÅ¼ zdania prawdziwe:
a) G jest eulerowski dla n nieparzystych.
>>b) JeÅ›li usuniÄ™te krawÄ™dzie tworzÄ… cykl C3, to stopnie wszystkich wierzchoÅ‚kÃ³w pozostajÄ… parzyste (dla n nieparzystego), wiÄ™c graf jest eulerowski.
c) Graf po usuniÄ™ciu krawÄ™dzi zawsze przestaje byÄ‡ spÃ³jny.
d) Liczba krawÄ™dzi w takim grafie wynosi n(n-1)/2.
e) Graf G jest zawsze planarny.
f) G nie posiada cyklu Hamiltona.


[#64] (#64) Czy graf cyklu C5 jest grafem dwudzielnym?
a) Nie, poniewaÅ¼ nie jest eulerowski.
>>b) Nie, poniewaÅ¼ zawiera cykl o nieparzystej dÅ‚ugoÅ›ci.
c) Tak, poniewaÅ¼ kaÅ¼dy graf pÅ‚aski jest dwudzielny.
d) Tak, poniewaÅ¼ ma 5 wierzchoÅ‚kÃ³w.
e) Tak, bo moÅ¼na go pokolorowaÄ‡ 2 kolorami.
f) Nie, bo jego liczba chromatyczna wynosi 3.


[#65] (#65) Dany jest graf G o szeÅ›ciu wierzchoÅ‚kach i stopniach: 2, 2, 3, 4, 4, 5. Czy G moÅ¼e byÄ‡ grafem planarnym?
a) Nie.
>>b) Tak. PrzykÅ‚ad konstrukcji: wierzchoÅ‚ek stopnia 5 Å‚Ä…czymy ze wszystkimi pozostaÅ‚ymi, a miÄ™dzy pozostaÅ‚ymi 5 wierzchoÅ‚kami dodajemy krawÄ™dzie tak, by stopnie wyniosÅ‚y 4,4,3,2,2 (np. resztowe stopnie 3,3,2,1,1).
c) Nie, poniewaÅ¼ zawiera wierzchoÅ‚ek o stopniu 5.
d) Tak, kaÅ¼dy graf o 6 wierzchoÅ‚kach jest planarny.
e) Nie, bo zawiera podgraf izomorficzny z K3,3.
f) Tak, bo suma stopni jest parzysta.


[#66] (#66) Dany jest wieloÅ›cian wypukÅ‚y o 11 wierzchoÅ‚kach, w ktÃ³rym 7 Å›cian to trÃ³jkÄ…ty, a 4 to czworokÄ…ty. KorzystajÄ…c ze wzoru Eulera (V-E+F=2), okreÅ›l rodzaj ostatniej (12-stej) Å›ciany:
a) czworokÄ…tem.
>>b) trÃ³jkÄ…tem.
c) piÄ™ciokÄ…tem.
d) szeÅ›ciokÄ…tem.
e) siedmiokÄ…tem.
f) nie da siÄ™ okreÅ›liÄ‡.


[#67] (#67) Graf G zostaÅ‚ zbudowany z grafÃ³w Hamiltona, G1=(V1,E1) i G2=(V2,E2), w nastÄ™pujÄ…cy sposÃ³b. Z V1 wybrano podzbiÃ³r W1 (W1 rÃ³Å¼ne od V1)
wierzchoÅ‚kÃ³w, stanowiÄ…cych kolejne wÄ™zÅ‚y cyklu Hamiltona w G1, oraz z V2 podzbiÃ³r W2 (W2 rÃ³Å¼ne od V2) wierzchoÅ‚kÃ³w, stanowiÄ…cych kolejne
wÄ™zÅ‚y cyklu Hamiltona w G2, a nastÄ™pnie poÅ‚Ä…czono wÄ™zÅ‚y W1 i W2 dodatkowymi krawÄ™dziami, tak Å¼e kaÅ¼dy wÄ™zeÅ‚ W1 jest sÄ…siedni z kaÅ¼dym
wÄ™zÅ‚em W2. WskaÅ¼ zdania prawdziwe:
a) G jest grafem Hamiltona dla |W1| + |W2| > 3.
>>b) G jest grafem Hamiltona, jeÅ›li istniejÄ… krawÄ™dzie Å‚Ä…czÄ…ce cykle Hamiltona w G1 i G2 pozwalajÄ…ce na utworzenie jednego wspÃ³lnego cyklu.
c) G nigdy nie jest grafem Hamiltona.
d) G jest grafem peÅ‚nym.
e) G jest zawsze dwudzielny.
f) G nie posiada mostÃ³w.


[#68] (#68) Indeks chromatyczny (minimalna liczba kolorÃ³w krawÄ™dzi) drzewa o maksymalnym stopniu wierzchoÅ‚ka Delta wynosi:
a) |V|
>>b) Delta (maksymalny stopieÅ„ wierzchoÅ‚ka).
c) Delta + 1
d) 2
e) Delta - 1
f) 3


[#69] (#69) Dany jest dowolny graf spÃ³jny G=(V,E), w ktÃ³rym kaÅ¼da krawÄ™dÅº jest mostem. KtÃ³re zdania sÄ… prawdziwe:
>>a) G jest drzewem.
b) G zawiera przynajmniej jeden cykl.
c) G jest grafem peÅ‚nym.
d) G ma wiÄ™cej krawÄ™dzi niÅ¼ wierzchoÅ‚kÃ³w.
>>e) Liczba krawÄ™dzi E = V - 1.
f) Graf G jest dwuspÃ³jny.


[#70] (#70) PodaÄ‡ najmniejszÄ… liczbÄ™ krawÄ™dzi, jakÄ… naleÅ¼y usunÄ…Ä‡ z grafu dwudzielnego peÅ‚nego K3,3, aby uzyskaÄ‡ graf regularny stopnia 2:
>>a) 3
>>b) 3 (usuwamy krawÄ™dzie tworzÄ…ce doskonaÅ‚e skojarzenie).
c) 1
d) 6
e) 0
f) 9


[#71] (#71) Dana jest klika K8. Liczba podgrafÃ³w izomorficznych z K5 (czyli liczba 5-elementowych podzbiorÃ³w wierzchoÅ‚kÃ³w) wynosi:
>>a) 56 (8 po 5).
b) 120
c) 40
d) 8! / 5!
e) 28
f) 64


[#72] (#72) Dana jest klika K8 o wierzchoÅ‚kach v1, v2,..., v8. Liczba drÃ³g prostych w tym grafie, prowadzÄ…cych z v1 do v2 i posiadajÄ…cych co najwyÅ¼ej 3
krawÄ™dzie, wynosi:
>>a) 37 (dÅ‚ugoÅ›Ä‡ 1: 1, dÅ‚ugoÅ›Ä‡ 2: 6, dÅ‚ugoÅ›Ä‡ 3: 30).
b) 43
c) 8
d) 64
e) 120
f) 56


[#73] (#73) Liczba drÃ³g prostych o dÅ‚ugoÅ›ci dokÅ‚adnie 1, 2 lub 3 krawÄ™dzi w klice K8 wynosi:
a) C(8,3) + C(8,2) + C(8,1)
>>b) 1 + 6 + 30 = 37 (miÄ™dzy parÄ… wierzchoÅ‚kÃ³w).
c) 8! / (8-k)!
d) n^k
e) 8*7/2
f) 37 * (8*7/2) (dla wszystkich par).


[#74] (#74) Dany jest graf o 21 krawÄ™dziach, 7 wierzchoÅ‚kach stopnia 1, 3 stopnia 2, 7 stopnia 3 i pozostaÅ‚ych stopnia 4. Ile jest wierzchoÅ‚kÃ³w stopnia 4?
a) Nie da siÄ™ zbudowaÄ‡ takiego grafu.
>>b) 2 (suma stopni 7*1 + 3*2 + 7*3 + 4*x = 34 + 4x = 42 => 4x=8 => x=2).
c) 5
d) 0
e) 3
f) 4


[#75] (#75) JÄ™zyk L_ne = {<M>: L(M) != pusty} koduje problem:
>>a) Czy dla danej maszyny Turinga M, jÄ™zyk przez niÄ… akceptowany jest niepusty?
b) Czy maszyna Turinga M zatrzymuje siÄ™ dla sÅ‚owa pustego?
c) Czy jÄ™zyk L(M) jest skoÅ„czony?
d) Czy maszyna M jest uniwersalna?
e) Czy M akceptuje wszystkie sÅ‚owa?
f) Czy M jest maszynÄ… deterministycznÄ…?


[#76] (#76) JÄ™zyk L_nr = {<M> : L(M) nie jest rekurencyjny}:
a) Jest akceptowany przez uniwersalnÄ… MT.
>>b) Nie jest rekurencyjnie przeliczalny (ani jego dopeÅ‚nienie).
c) Jest jÄ™zykiem regularnym.
d) Jest rozstrzygalny.
e) Jest jÄ™zykiem bezkontekstowym.
f) Jest rekurencyjnie przeliczalny.


[#77] (#77) JÄ™zyk L_eq = {<M> <N>: L(M) = L(N)}:
>>a) Nie jest rozpoznawany przez Å¼adnÄ… maszynÄ™ Turinga (nie jest rekurencyjnie przeliczalny).
b) Jest rozstrzygalny dla dowolnych maszyn Turinga.
c) Jest jÄ™zykiem bezkontekstowym.
d) Jest akceptowany przez automat ze stosem.
e) Jest rekurencyjny.
f) Jest jÄ™zykiem regularnym.


[#78] (#78) Problem decyzyjny â€Czy dane maszyny Turinga M i N akceptujÄ… ten sam jÄ™zyk?â€ jest:
a) Rozstrzygalny.
>>b) Nierozstrzygalny.
c) CzÄ™Å›ciowo rozstrzygalny.
d) Rozstrzygalny tylko dla automatÃ³w skoÅ„czonych.
e) Rozstrzygalny w czasie wielomianowym.
f) P-zupeÅ‚ny.


[#79] (#79) Twierdzenie Rice'a orzeka, Å¼e kaÅ¼da nietrywialna wÅ‚asnoÅ›Ä‡ semantyczna jÄ™zykÃ³w akceptowanych przez maszyny Turinga jest:
>>a) Nierozstrzygalna (jÄ™zyk L = {<M>: L(M) ma wÅ‚asnoÅ›Ä‡ S} nie jest rekurencyjny).
b) Rekurencyjnie przeliczalna.
c) Regularna.
d) Rozstrzygalna w czasie wielomianowym.
e) Prawdziwa dla wszystkich maszyn Turinga.
f) ZaleÅ¼na od liczby stanÃ³w maszyny.


[#80] (#80) Niech S bÄ™dzie pewnÄ… wÅ‚asnoÅ›ciÄ… zbiorÃ³w rekurencyjnie przeliczalnych. JeÅ›li S nie jest monotoniczna to:
a) S jest nieprzeliczalna lub pusta.
>>b) JÄ™zyk L = {<M>: L(M) naleÅ¼y do S} nie jest rekurencyjnie przeliczalny.
c) S jest zawsze rozstrzygalna.
d) S zawiera wszystkie jÄ™zyki regularne.
e) S jest rekurencyjna.
f) S jest skoÅ„czona.


[#81] (#81) FunkcjÄ™ Ackermana:
a) da siÄ™ przedstawiÄ‡ w reprezentacji Maszyny Turinga.
>>b) jest funkcjÄ… rekurencyjnÄ…, ale nie jest prymitywnie rekurencyjna.
c) nie jest obliczalna.
d) ma zÅ‚oÅ¼onoÅ›Ä‡ wielomianowÄ….
>>e) roÅ›nie szybciej niÅ¼ jakakolwiek funkcja prymitywnie rekurencyjna.
f) jest funkcjÄ… liniowÄ….


[#82] (#82) Dany jest jÄ™zyk L_e = {w : w = <M> => L(M) = pusty}. Koduje on problem:
>>a) Czy jÄ™zyk akceptowany przez maszynÄ™ Turinga M jest pusty?
b) Czy dla sÅ‚owa w niebÄ™dÄ…cego kodem MT, jest ono akceptowane przez pewnÄ… MT?
c) Czy maszyna M akceptuje wszystkie sÅ‚owa?
d) Czy M jest maszynÄ… deterministycznÄ…?
e) Czy M zatrzymuje siÄ™ na sÅ‚owie w?
f) Czy L(M) jest skoÅ„czony?


[#83] (#83) JÄ™zyk L_e = {<M> : L(M) = pusty}:
a) Jest prymitywnie rekurencyjny.
>>b) Nie jest rekurencyjnie przeliczalny.
c) Jest rozstrzygalny.
d) Jest jÄ™zykiem kontekstowym.
>>e) Jego dopeÅ‚nienie L_ne jest rekurencyjnie przeliczalne.
f) Jest jÄ™zykiem regularnym.


[#84] (#84) JÄ™zyk L_ne = {<M>: L(M) != pusty}:
>>a) Jest rekurencyjnie przeliczalny (ale nie rekurencyjny).
b) Jest rozstrzygalny.
c) Nie jest akceptowany przez Å¼adnÄ… maszynÄ™ Turinga.
d) Jest jÄ™zykiem skoÅ„czonym.
e) Jest jÄ™zykiem regularnym.
f) Jest rekurencyjny.


[#85] (#85) Problem decyzyjny, czy jÄ™zyk akceptowany przez danÄ… maszynÄ™ Turinga jest pusty, jest:
a) CzÄ™Å›ciowo rozstrzygalny.
>>b) Nierozstrzygalny i nie jest nawet czÄ™Å›ciowo rozstrzygalny.
c) Rozstrzygalny.
d) Wielomianowy.
e) Rozstrzygalny dla automatÃ³w ze stosem.
f) P-zupeÅ‚ny.


[#86] (#86) Problem decyzyjny, czy jÄ™zyk akceptowany przez danÄ… maszynÄ™ Turinga jest niepusty, jest:
a) Nie jest nawet problemem czÄ™Å›ciowo rozstrzygalnym.
>>b) CzÄ™Å›ciowo rozstrzygalny (moÅ¼na symulowaÄ‡ M na wszystkich sÅ‚owach rÃ³wnolegle).
c) Rozstrzygalny.
d) Rekurencyjny.
e) Regularny.
f) Rozstrzygalny w czasie wykÅ‚adniczym.


[#87] (#87) JÄ™zyk L_r = {<M>: L(M) jest rekurencyjny} koduje problem:
>>a) Czy jÄ™zyk akceptowany przez maszynÄ™ Turinga M jest rozstrzygalny?
b) Czy dla danej maszyny Turinga M, L(M) jest rekurencyjnie przeliczalny?
c) Czy M zatrzymuje siÄ™ dla kaÅ¼dego wejÅ›cia?
d) Czy M ma skoÅ„czonÄ… liczbÄ™ stanÃ³w?
e) Czy L(M) jest jÄ™zykiem regularnym?
f) Czy M jest uniwersalna?


[#88] (#88) JÄ™zyk L_nr = {<M>: L(M) nie jest rekurencyjny} koduje problem:
>>a) Czy jÄ™zyk akceptowany przez maszynÄ™ Turinga M jest nierozstrzygalny?
b) Czy dana maszyna Turinga M, posiada wÅ‚asnoÅ›Ä‡ stopu?
c) Czy M jest maszynÄ… uniwersalnÄ…?
d) Czy L(M) jest jÄ™zykiem regularnym?
e) Czy M jest deterministyczna?
f) Czy M ma nieskoÅ„czonÄ… taÅ›mÄ™?


[#89] (#89) JÄ™zyk L_r = {<M>: L(M) jest rekurencyjny}:
>>a) Nie jest rekurencyjny (wynika z twierdzenia Rice'a).
b) Jest rekurencyjnie przeliczalny.
c) Jest rozstrzygalny.
d) Jest regularny.
e) Jest bezkontekstowy.
>>f) Nie jest rekurencyjnie przeliczalny.


[#90] (#90) Jednostka arytmetyczno-logiczna ALU:
a) musi byÄ‡ ukÅ‚adem sekwencyjnym.
>>b) jest podstawowym blokiem procesora wykonujÄ…cym operacje obliczeniowe i logiczne.
c) nie moÅ¼e zawieraÄ‡ sumatorÃ³w.
d) sÅ‚uÅ¼y wyÅ‚Ä…cznie do przechowywania danych.
>>e) wykonuje operacje takie jak dodawanie, odejmowanie, AND, OR.
f) zarzÄ…dza przerwaniami sprzÄ™towymi.


[#91] (#91) UkÅ‚ad sekwencyjny:
a) jest to ukÅ‚ad logiczny nie pamiÄ™tajÄ…cy stanÃ³w poprzednich.
>>b) to ukÅ‚ad, w ktÃ³rym stan wyjÅ›Ä‡ zaleÅ¼y od aktualnych wejÅ›Ä‡ oraz od stanu poprzedniego (posiada pamiÄ™Ä‡).
c) to inaczej ukÅ‚ad kombinacyjny.
d) nie wymaga sygnaÅ‚u zegarowego.
>>e) przykÅ‚adami sÄ… przerzutniki, liczniki, rejestry.
f) nie posiada sprzÄ™Å¼enia zwrotnego.


[#92] (#92) PamiÄ™Ä‡ RAM dwuportowa:
>>a) pozwala na jednoczesny dostÄ™p do dwÃ³ch rÃ³Å¼nych komÃ³rek pamiÄ™ci (np. odczyt i zapis).
b) nie moÅ¼e byÄ‡ zaimplementowana w ukÅ‚adach FPGA.
c) jest zawsze wolniejsza od pamiÄ™ci jednoportowej.
d) sÅ‚uÅ¼y wyÅ‚Ä…cznie do przechowywania instrukcji procesora.
e) wymaga dwÃ³ch oddzielnych ukÅ‚adÃ³w scalonych.
f) nie posiada linii adresowych.


[#93] (#93) Procesor w ukÅ‚adzie FPGA:
>>a) moÅ¼e mieÄ‡ architekturÄ™ dostosowanÄ… do specyficznych potrzeb uÅ¼ytkownika (tzw. soft-core).
b) musi byÄ‡ zgodny z architekturÄ… x86.
c) nie moÅ¼e posiadaÄ‡ wÅ‚asnej listy rozkazÃ³w.
d) jest zawsze szybszy od procesorÃ³w dedykowanych (ASIC).
e) nie moÅ¼e byÄ‡ taktowany zegarem.
f) nie posiada rejestrÃ³w.


[#94] (#94) Lista rozkazÃ³w procesora (ISA):
a) w skÅ‚ad listy rozkazÃ³w zawsze wchodzi mnoÅ¼enie.
>>b) definiuje zestaw instrukcji rozumianych przez procesor oraz ich formaty.
c) jest identyczna dla wszystkich procesorÃ³w.
d) nie zawiera instrukcji skokÃ³w.
>>e) okreÅ›la dostÄ™pne tryby adresowania.
f) zaleÅ¼y od systemu operacyjnego.


[#95] (#95) Karta graficzna i FPGA:
>>a) UkÅ‚ady FPGA mogÄ… byÄ‡ wykorzystane do budowy akceleratorÃ³w graficznych i przetwarzania obrazu.
b) przy uÅ¼yciu FPGA nie moÅ¼na zbudowaÄ‡ karty graficznej ze sprzÄ™towym wspomaganiem OpenGL.
c) FPGA nie nadaje siÄ™ do obliczeÅ„ rÃ³wnolegÅ‚ych.
d) karty graficzne nie uÅ¼ywajÄ… pamiÄ™ci RAM.
e) FPGA sÄ… uÅ¼ywane wyÅ‚Ä…cznie w telekomunikacji.
f) GPU i FPGA to te same ukÅ‚ady.


[#96] (#96) Licznik rozkazÃ³w (Program Counter):
>>a) przechowuje adres nastÄ™pnej instrukcji do pobrania z pamiÄ™ci.
b) sÅ‚uÅ¼y do zliczania liczby wykonanych operacji arytmetycznych.
c) jest czÄ™Å›ciÄ… jednostki ALU.
d) przechowuje kody bÅ‚Ä™dÃ³w procesora.
e) jest rejestrem 8-bitowym w procesorach 64-bitowych.
f) nie moÅ¼e byÄ‡ zmieniony przez instrukcjÄ™ skoku.


[#97] (#97) Rozkaz skoku warunkowego:
>>a) zmienia kolejnoÅ›Ä‡ wykonywania instrukcji w zaleÅ¼noÅ›ci od stanu znacznikÃ³w (flag) procesora.
b) zawsze wykonuje skok do adresu zero.
c) nie zaleÅ¼y od wynikÃ³w poprzednich operacji.
d) jest instrukcjÄ… typu ALU.
e) nie jest dostÄ™pny w architekturze RISC.
f) zawsze czyÅ›ci pamiÄ™Ä‡ cache.


[#98] (#98) Rozkaz dodawania w procesorze:
>>a) pobiera argumenty (np. z rejestrÃ³w), wykonuje sumowanie w ALU i zapisuje wynik.
b) nie moÅ¼e uÅ¼ywaÄ‡ adresowania bezpoÅ›redniego.
c) jest dostÄ™pny tylko w procesorach 64-bitowych.
d) zawsze ustawia flagÄ™ przerwania.
>>e) moÅ¼e ustawiÄ‡ flagi takie jak Zero (Z), Carry (C), Overflow (V).
f) nie zmienia stanu rejestrÃ³w.


[#99] (#99) Przetwarzanie potokowe (pipelining):
>>a) pozwala na jednoczesne wykonywanie rÃ³Å¼nych etapÃ³w wielu instrukcji.
b) skraca czas wykonania pojedynczej instrukcji (latency).
c) eliminuje potrzebÄ™ stosowania pamiÄ™ci cache.
d) jest stosowane tylko w procesorach jednoukÅ‚adowych.
>>e) zwiÄ™ksza przepustowoÅ›Ä‡ (throughput) procesora.
f) uniemoÅ¼liwia wykonywanie skokÃ³w.


[#100] (#100) Sumator jednobitowy peÅ‚ny (Full Adder):
>>a) posiada trzy wejÅ›cia (dwa bity skÅ‚adnikÃ³w i przeniesienie) oraz dwa wyjÅ›cia (suma i przeniesienie).
b) nie uwzglÄ™dnia przeniesienia z poprzedniej pozycji.
c) jest ukÅ‚adem sekwencyjnym.
d) sÅ‚uÅ¼y do mnoÅ¼enia liczb.
e) skÅ‚ada siÄ™ wyÅ‚Ä…cznie z bramek NOT.
>>f) jest podstawÄ… budowy sumatorÃ³w wielobitowych.


[#101] (#101) Rejestr rozkazÃ³w (Instruction Register):
>>a) przechowuje aktualnie dekodowanÄ… i wykonywanÄ… instrukcjÄ™.
b) jest dostÄ™pny bezpoÅ›rednio dla programisty.
c) sÅ‚uÅ¼y do przechowywania wynikÃ³w operacji zmiennoprzecinkowych.
d) jest toÅ¼samy z licznikiem rozkazÃ³w.
e) przechowuje adresy pamiÄ™ci RAM.
f) jest czÄ™Å›ciÄ… jednostki sterujÄ…cej procesora.


[#102] (#102) WskaÅ¼, ktÃ³re z poniÅ¼szych stwierdzeÅ„ opisujÄ… poprawnie wÅ‚asnoÅ›ci relacyjnych baz danych:
a) WartoÅ›ciÄ… atrybutu moÅ¼e byÄ‡ wyraÅ¼enie obliczalne.
>>b) KaÅ¼da relacja musi posiadaÄ‡ klucz gÅ‚Ã³wny, ktÃ³ry jednoznacznie identyfikuje krotki.
c) KolejnoÅ›Ä‡ wierszy w tabeli ma znaczenie semantyczne.
d) Atrybuty w relacji mogÄ… byÄ‡ wielowartoÅ›ciowe (np. tablice).
>>e) Relacja jest zbiorem krotek (brak duplikatÃ³w).
f) Relacyjna baza danych nie obsÅ‚uguje wiÄ™zÃ³w integralnoÅ›ci.


[#103] (#103) WskaÅ¼, ktÃ³re z poniÅ¼szych stwierdzeÅ„ dotyczÄ…cych kluczy obcych w relacyjnych bazach danych sÄ… prawdziwe.
a) Nazwa atrybutu klucza obcego musi byÄ‡ taka sama jak nazwa atrybutu klucza w tabeli nadrzÄ™dnej.
>>b) Klucz obcy sÅ‚uÅ¼y do wymuszania wiÄ™zÃ³w integralnoÅ›ci referencyjnej miÄ™dzy tabelami.
c) Klucz obcy nie moÅ¼e zawieraÄ‡ wartoÅ›ci NULL.
d) W jednej tabeli moÅ¼e istnieÄ‡ tylko jeden klucz obcy.
>>e) Klucz obcy moÅ¼e odwoÅ‚ywaÄ‡ siÄ™ do klucza gÅ‚Ã³wnego lub unikalnego w innej tabeli.
f) UsuniÄ™cie rekordu nadrzÄ™dnego zawsze powoduje usuniÄ™cie rekordu z kluczem obcym.


[#104] (#104) Dana jest zmienna relacyjna o schemacie H={A,B,C,D} i zbiorze zaleÅ¼noÅ›ci funkcyjnych F={{A,B} -> C, {A,C} -> D}. Jedynym kluczem
tej zmiennej relacyjnej jest para atrybutÃ³w {A,B}. W jakiej maksymalnie postaci normalnej jest ta zmienna relacyjna? (ZakÅ‚adamy, Å¼e jest w 1NF.)
a) BCNF
b) 2NF
>>c) 3NF
d) 1NF
e) 4NF
f) 5NF


[#105] (#105) Dana jest zmienna relacyjna o schemacie H={A,B,C,D} i zbiorze zaleÅ¼noÅ›ci funkcyjnych F={A -> B, C -> D}. Jedynym kluczem tej
zmiennej relacyjnej jest para atrybutÃ³w {A,C}. Jak naleÅ¼y zdekomponowaÄ‡ zmiennÄ… relacyjnÄ…, aby uzyskaÄ‡ zbiÃ³r zmiennych relacyjnych w 3NF?
>>a) Dekompozycja na {A,B} oraz {C,D} oraz {A,C}.
b) {A,B}, {C,D}
c) {A,B,C}, {D}
d) {A,B,D}, {C}
e) Nie wymaga dekompozycji.
f) {A,B,C,D}


[#106] (#106) WskaÅ¼ prawdziwe stwierdzenia dotyczÄ…ce kluczy w modelu relacyjnym:
a) ZbiÃ³r wszystkich atrybutÃ³w wchodzÄ…cych w skÅ‚ad nagÅ‚Ã³wka zmiennej relacyjnej jest kluczem.
>>b) Klucz nadmiarowy (superklucz) to zbiÃ³r atrybutÃ³w zawierajÄ…cy klucz kandydujÄ…cy.
c) KaÅ¼da tabela moÅ¼e mieÄ‡ wiele kluczy gÅ‚Ã³wnych.
d) Klucz kandydujÄ…cy moÅ¼e byÄ‡ pusty.
>>e) Klucz kandydujÄ…cy to minimalny superklucz.
f) Klucz gÅ‚Ã³wny to jeden z wybranych kluczy kandydujÄ…cych.


[#107] (#107) WskaÅ¼, ktÃ³re z poniÅ¼szych stwierdzeÅ„ dotyczÄ…cych normalizacji sÄ… prawdziwe w relacyjnym modelu danych.
>>a) DowolnÄ… zmiennÄ… relacyjnÄ… moÅ¼na sprowadziÄ‡ do 3NF stosujÄ…c dekompozycjÄ™ bezstratnÄ… i zachowujÄ…cÄ… zaleÅ¼noÅ›ci funkcyjne.
b) PostaÄ‡ BCNF zawsze zachowuje wszystkie zaleÅ¼noÅ›ci funkcyjne.
c) 2NF eliminuje zaleÅ¼noÅ›ci przechodnie.
d) Normalizacja zawsze zwiÄ™ksza wydajnoÅ›Ä‡ odczytu danych.
>>e) 1NF wymaga, aby wszystkie wartoÅ›ci atrybutÃ³w byÅ‚y atomowe.
f) 3NF eliminuje zaleÅ¼noÅ›ci wielowartoÅ›ciowe.


[#108] (#108) WskaÅ¼ prawdziwe stwierdzenia dotyczÄ…ce powiÄ…zaÅ„ w relacyjnych bazach danych:
>>a) Relacja wiele-do-wielu wymaga wprowadzenia tabeli poÅ›redniczÄ…cej (asocjacyjnej).
b) PowiÄ…zania klucz-klucz obcy mogÄ… byÄ‡ tylko typu jeden do jednego lub jeden do wielu.
c) Klucz obcy musi zawsze wskazywaÄ‡ na klucz gÅ‚Ã³wny, nigdy na klucz unikalny.
d) MiÄ™dzy dwiema tabelami moÅ¼e istnieÄ‡ tylko jedno powiÄ…zanie.
>>e) Relacja jeden-do-jednego moÅ¼e byÄ‡ zaimplementowana w jednej tabeli lub dwÃ³ch poÅ‚Ä…czonych kluczami gÅ‚Ã³wnymi.
f) Relacje w SQL sÄ… zawsze symetryczne.


[#109] (#109) WskaÅ¼ prawdziwe stwierdzenia dotyczÄ…ce podzapytaÅ„ w PostgreSQL:
a) WewnÄ…trz instrukcji INSERT moÅ¼na stosowaÄ‡ wyÅ‚Ä…cznie podzapytania skalarne.
>>b) Podzapytania mogÄ… byÄ‡ stosowane w klauzulach SELECT, FROM, WHERE oraz HAVING.
c) Podzapytanie w klauzuli FROM nie musi mieÄ‡ nadanego aliasu.
d) Podzapytania skorelowane sÄ… zawsze szybsze od zwykÅ‚ych podzapytaÅ„.
>>e) Podzapytanie skalarne zwraca dokÅ‚adnie jednÄ… wartoÅ›Ä‡ (jeden wiersz i jednÄ… kolumnÄ™).
f) Podzapytania nie mogÄ… byÄ‡ zagnieÅ¼dÅ¼one.


[#110] (#110) WskaÅ¼, ktÃ³re z poniÅ¼szych stwierdzeÅ„ dotyczÄ…cych typÃ³w zÅ‚Ä…czeÅ„ w relacyjnych bazach danych sÄ… prawdziwe.
>>a) LEFT JOIN zwraca wszystkie wiersze z lewej tabeli i dopasowane wiersze z prawej tabeli (lub NULL).
b) ZÅ‚Ä…czenie wewnÄ™trzne (INNER JOIN) zawiera wszystkie rekordy z lewej tabeli, nawet jeÅ›li nie ma dopasowania.
c) FULL JOIN zwraca tylko rekordy, ktÃ³re majÄ… dopasowanie w obu tabelach.
d) CROSS JOIN wymaga podania warunku ON.
>>e) RIGHT JOIN jest symetryczny do LEFT JOIN (zwraca wszystko z prawej tabeli).
f) NATURAL JOIN Å‚Ä…czy tabele po wszystkich kolumnach o tych samych nazwach.


[#111] (#111) WskaÅ¼, ktÃ³re z wÅ‚asnoÅ›ci przetwarzania transakcyjnego oznacza skrÃ³t ACID.
>>a) AtomicznoÅ›Ä‡, SpÃ³jnoÅ›Ä‡ (Consistency), Izolacja, TrwaÅ‚oÅ›Ä‡ (Durability).
b) Agregacja, CaÅ‚kowitoÅ›Ä‡, Identyfikacja, DostÄ™pnoÅ›Ä‡.
c) AsynchronicznoÅ›Ä‡, CiÄ…gÅ‚oÅ›Ä‡, Interakcja, Decentralizacja.
d) Automatyzacja, Certyfikacja, Integracja, Dokumentacja.
e) Akceptacja, CylicznoÅ›Ä‡, Indeksacja, Definicja.
f) Autoryzacja, CiÄ…gÅ‚oÅ›Ä‡, Izolacja, DostÄ™pnoÅ›Ä‡.


[#112] (#112) WskaÅ¼ prawdziwe stwierdzenia dotyczÄ…ce funkcji agregujÄ…cych w PostgreSQL:
>>a) Funkcje agregujÄ…ce (np. SUM, AVG) nie mogÄ… byÄ‡ uÅ¼ywane bezpoÅ›rednio w klauzuli WHERE.
b) Klauzula HAVING sÅ‚uÅ¼y do filtrowania wynikÃ³w przed agregacjÄ….
c) Funkcja COUNT() pomija wartoÅ›ci NULL.
d) Funkcje agregujÄ…ce moÅ¼na stosowaÄ‡ tylko w zapytaniach z GROUP BY.
>>e) Funkcja COUNT(*) zlicza wszystkie wiersze, w tym te z wartoÅ›ciami NULL.
f) Funkcja MAX() dziaÅ‚a tylko na typach numerycznych.


[#113] (#113) WskaÅ¼, ktÃ³re z poniÅ¼szych stwierdzeÅ„ dotyczÄ…cych zwiÄ…zku relacyjnych baz danych z matematycznÄ… teoriÄ… relacji sÄ… prawdziwe.
>>a) Relacja w sensie matematycznym to podzbiÃ³r iloczynu kartezjaÅ„skiego zbiorÃ³w (dziedzin).
b) Tabele relacyjnych baz danych w ktÃ³rych istniejÄ… klucze sÄ… relacjami.
c) KaÅ¼da tabela w SQL jest matematycznÄ… relacjÄ… (nawet jeÅ›li dopuszcza duplikaty).
d) Model relacyjny nie opiera siÄ™ na teorii zbiorÃ³w.
>>e) Atrybuty relacji odpowiadajÄ… kolumnom tabeli, a krotki odpowiadajÄ… wierszom.
f) Relacja matematyczna dopuszcza nieskoÅ„czonÄ… liczbÄ™ krotek w bazie danych.


[#114] (#114) Gramatyka formalna jest wieloznaczna, jeÅ¼eli:
>>a) istnieje przynajmniej jedno sÅ‚owo w jÄ™zyku tej gramatyki, ktÃ³re posiada wiÄ™cej niÅ¼ jedno drzewo wyprowadzenia (syntaktyczne).
b) posiada symbole nieterminalne o wielu produkcjach.
c) generuje jÄ™zyk nieskoÅ„czony.
d) nie moÅ¼na jej sprowadziÄ‡ do postaci normalnej Chomsky'ego.
>>e) posiada sÅ‚owo, dla ktÃ³rego istnieje wiÄ™cej niÅ¼ jedno wyprowadzenie lewostronne.
f) generuje sÅ‚owa o rÃ³Å¼nej dÅ‚ugoÅ›ci.


[#115] (#115) W kontekÅ›cie jÄ™zykÃ³w formalnych, (oznaczenie: ^ to symbol potÄ™gowania, ktÃ³rego argumenty mogÄ… byÄ‡ w nawiasach klamrowych.,
nastÄ™pujÄ…ce stwierdzenia sÄ… prawdziwe:
>>a) JÄ™zyk L = {a^n b^n : n > 0} nie jest regularny, ale jest bezkontekstowy.
b) L1 = {f^{2^{n}}: n > 0} jest regularny.
c) KaÅ¼dy jÄ™zyk bezkontekstowy jest regularny.
d) JÄ™zyki regularne nie sÄ… zamkniÄ™te ze wzglÄ™du na dopeÅ‚nienie.
>>e) Klasa jÄ™zykÃ³w regularnych jest wÅ‚aÅ›ciwym podzbiorem klasy jÄ™zykÃ³w bezkontekstowych.
f) KaÅ¼dy jÄ™zyk akceptowany przez automat skoÅ„czony jest bezkontekstowy.


[#116] (#116) Mamy gramatykÄ™ (duÅ¼e litery to symbole nieterminalne, maÅ‚e to symbole terminalne, S to symbol startowy) zawierajÄ…cÄ… produkcje: S -> AB,
A -> Aa | bB, B -> a | Sb oraz formÄ™ zdaniowÄ…: baaABb. KtÃ³re stwierdzenie jest prawdziwe
a) nie jest wyprowadzana.
>>b) jest formÄ… zdaniowÄ…, jeÅ›li moÅ¼na jÄ… uzyskaÄ‡ w dowolnej liczbie krokÃ³w z symbolu startowego S.
c) zawiera wyÅ‚Ä…cznie symbole terminalne.
d) jest sÅ‚owem jÄ™zyka.
e) jest symbolem startowym.
f) nie moÅ¼e zawieraÄ‡ nieterminali.


[#117] (#117) W odniesieniu do wyraÅ¼eÅ„ regularnych i generowanych Å‚aÅ„cuchÃ³w, ktÃ³re stwierdzenia sÄ… prawdziwe
WyraÅ¼enie regularne: (x+y)*y(a+ab)*
>>a) Generuje sÅ‚owa koÅ„czÄ…ce siÄ™ sekwencjÄ… 'y' po ktÃ³rej nastÄ™puje 'a' lub 'ab'.
b) Zawiera dokÅ‚adnie 7 Å‚aÅ„cuchÃ³w o dÅ‚ugoÅ›ci mniejszej niÅ¼ 4.
c) Nie generuje sÅ‚owa 'y'.
d) Generuje sÅ‚owo 'xa'.
>>e) Generuje sÅ‚owo 'yya'.
>>f) Generuje sÅ‚owo 'xyab'.


[#118] (#118) Lemat o pompowaniu dla jÄ™zykÃ³w regularnych:
>>a) SÅ‚uÅ¼y do dowodzenia, Å¼e dany jÄ™zyk nie jest regularny.
b) DÅ‚ugoÅ›Ä‡ pompowania dla Å‚aÅ„cucha o dÅ‚ugoÅ›ci x jest rÃ³wna x+1.
c) KaÅ¼dy jÄ™zyk speÅ‚niajÄ…cy warunki lematu o pompowaniu jest regularny.
d) Dotyczy wyÅ‚Ä…cznie jÄ™zykÃ³w skoÅ„czonych.
e) MÃ³wi, Å¼e kaÅ¼de sÅ‚owo jÄ™zyka regularnego moÅ¼na dowolnie skracaÄ‡.
f) Pozwala na konstrukcjÄ™ automatu minimalnego.


[#119] (#119) RozwaÅ¼my gramatykÄ™
                    S ---> PQ | SQ | PS
                    P ---> x
                    Q--> yKtÃ³re stwierdzenia sÄ… prawdziwe:
>>a) W gramatyce w postaci normalnej Chomsky'ego liczba krokÃ³w wyprowadzenia sÅ‚owa o dÅ‚ugoÅ›ci n wynosi dokÅ‚adnie 2n-1.
b) Liczba uÅ¼ytych produkcji musi byÄ‡ rÃ³wna n.
c) Nie da siÄ™ wyprowadziÄ‡ sÅ‚Ã³w o dÅ‚ugoÅ›ci wiÄ™kszej niÅ¼ 2.
d) Gramatyka ta jest regularna.
e) Wymaga n^2 krokÃ³w.
f) Liczba krokÃ³w jest zawsze parzysta.


[#120] (#120) W odniesieniu do jÄ™zykÃ³w regularnych:
>>a) JÄ™zyki regularne sÄ… zamkniÄ™te ze wzglÄ™du na sumÄ™, iloczyn i dopeÅ‚nienie.
b) JeÅ›li L1 jest regularny a L1-L2 jest regularny, to L2 musi byÄ‡ regularny.
c) KaÅ¼dy jÄ™zyk podzbiÃ³r jÄ™zyka regularnego jest regularny.
d) Automaty niedeterministyczne akceptujÄ… szerszÄ… klasÄ™ jÄ™zykÃ³w niÅ¼ deterministyczne.
>>e) KaÅ¼dy jÄ™zyk regularny jest akceptowany przez pewien deterministyczny automat skoÅ„czony.
f) JÄ™zyki regularne nie sÄ… zamkniÄ™te ze wzglÄ™du na gwiazdkÄ™ Kleene'ego.


[#121] (#121) Mamy gramatykÄ™ z nastÄ™pujÄ…cymi produkcjami:
S -> XY

X -> aX|a

Y -> aYb|\epsilon
>>a) Generuje jÄ™zyk {a^m b^n : m > n >= 0}.
b) Generuje jÄ™zyk {a^n b^n : n >= 0}.
c) Jest gramatykÄ… regularnÄ….
d) Nie generuje sÅ‚owa 'a'.
e) Generuje sÅ‚owo 'ab'.
f) Generuje jÄ™zyk {a^n b^m : n > m}.


[#122] (#122) KtÃ³re z poniÅ¼szych zdaÅ„ odnoÅ›nie gramatyk formalnych sÄ… prawdziwe:
>>a) Z kaÅ¼dej gramatyki bezkontekstowej moÅ¼na usunÄ…Ä‡ epsilon-produkcje (chyba Å¼e jÄ™zyk zawiera sÅ‚owo puste).
b) Gramatyki bezkontekstowe sÄ… zamkniÄ™te ze wzglÄ™du na przekrÃ³j (intersekcjÄ™).
c) KaÅ¼dy jÄ™zyk regularny jest generowany przez gramatykÄ™ typu 0.
d) Gramatyki kontekstowe nie mogÄ… mieÄ‡ produkcji skracajÄ…cych.
>>e) KaÅ¼dy jÄ™zyk regularny jest bezkontekstowy.
f) Gramatyki typu 3 generujÄ… jÄ™zyki kontekstowe.


[#123] (#123) OdnoÅ›nie twierdzenia Myhill-Nerode'a nastÄ™pujÄ…ce zdania sÄ… prawdziwe:
>>a) Podaje warunek konieczny i dostateczny na to, by jÄ™zyk byÅ‚ regularny.
b) SÅ‚uÅ¼y do minimalizacji automatÃ³w deterministycznych.
c) Twierdzenie ma znaczenie w kontekÅ›cie konwersji NAS na DAS.
d) Dotyczy wyÅ‚Ä…cznie jÄ™zykÃ³w bezkontekstowych.
>>e) Relacja Myhill-Nerode'a ma skoÅ„czony indeks wtedy i tylko wtedy, gdy jÄ™zyk jest regularny.
f) Pozwala na rozstrzygniÄ™cie problemu stopu.


[#124] (#124) W kontekÅ›cie jÄ™zykÃ³w formalnych nastÄ™pujÄ…ce stwierdzenia sÄ… prawdziwe
>>a) SÄ… akceptowane przez liniowo ograniczone automaty Turinga (LBA).
b) JÄ™zyk kontekstowy jest akceptowany przez NAS (automat skoÅ„czony).
c) SÄ… podzbiorem jÄ™zykÃ³w regularnych.
d) Ich gramatyki mogÄ… zawieraÄ‡ produkcjÄ™ A -> BC.
>>e) Gramatyki kontekstowe (typ 1) majÄ… produkcje postaci alpha A beta -> alpha gamma beta, gdzie gamma != epsilon.
f) KaÅ¼dy jÄ™zyk kontekstowy jest bezkontekstowy.


[#125] (#125) W odniesieniu do jÄ™zykÃ³w formalnych nastÄ™pujÄ…ce zdania sÄ… prawdziwe:
>>a) Akceptuje klasÄ™ jÄ™zykÃ³w bezkontekstowych.
b) MoÅ¼e akceptowaÄ‡ napis wejÅ›ciowy poprzez stan koÅ„cowy lub pusty stos.
c) Jest rÃ³wnowaÅ¼ny automatowi skoÅ„czonemu z dwoma stosami.
d) Zawsze musi byÄ‡ deterministyczny.
>>e) Niedeterministyczne automaty ze stosem sÄ… silniejsze od deterministycznych (akceptujÄ… szerszÄ… klasÄ™ jÄ™zykÃ³w).
f) Nie moÅ¼e mieÄ‡ wiÄ™cej niÅ¼ jeden stan.


[#126] (#126) JeÅ¼eli kolor punktu zapisany jest na 16 bitach (High Color), to moÅ¼e on przyjÄ…Ä‡:
>>a) 65536 rÃ³Å¼nych barw.
b) 16,7 miliona barw.
c) 256 barw.
d) 1024 barwy.
e) 32768 barw.
f) 2^24 barw.


[#127] (#127) W modelu oÅ›wietlenia Phonga, odbicie zwierciadlane (specular):
>>a) ZaleÅ¼y od kÄ…ta miÄ™dzy wektorem kierunku obserwacji a wektorem kierunku odbicia Å›wiatÅ‚a.
b) Jest niezaleÅ¼ne od kÄ…ta pomiÄ™dzy wektorem normalnym powierzchni a wektorem w kierunku ÅºrÃ³dÅ‚a Å›wiatÅ‚a.
c) Nie zaleÅ¼y od wÅ‚aÅ›ciwoÅ›ci materiaÅ‚u.
d) Jest identyczne dla kaÅ¼dego punktu powierzchni.
e) Odpowiada za kolor cienia obiektu.
f) Jest modelowane za pomocÄ… funkcji sinus.


[#128] (#128) W Ray-tracingu rekurencyjnym promienie wtÃ³rne to:
>>a) Promienie odbite, zaÅ‚amane (transmitowane) oraz promienie cienia.
b) wektory normalne do wszystkich powierzchni.
c) promienie biegnÄ…ce bezpoÅ›rednio z oka do rzutni.
d) promienie generowane przez ÅºrÃ³dÅ‚a Å›wiatÅ‚a rozproszonego.
e) promienie pierwotne.
f) tylko promienie zaÅ‚amane.


[#129] (#129) Metoda bilansu energetycznego (Radiosity):
>>a) Bazuje na zasadzie zachowania energii i modeluje wymianÄ™ Å›wiatÅ‚a miÄ™dzy powierzchniami rozpraszajÄ…cymi.
b) dobrze symuluje odbicia zwierciadlane.
>>c) jest metodÄ… niezaleÅ¼nÄ… od widoku (view-independent).
d) nie wymaga podziaÅ‚u powierzchni na patche.
e) jest szybsza od ray-tracingu dla scen z wieloma lustrami.
f) oblicza oÅ›wietlenie tylko dla punktÃ³w widocznych z kamery.


[#130] (#130) Modele kolorÃ³w subtraktywne to:
>>a) CMYK.
b) RGB.
c) HSV.
d) YUV.
e) HSL.
f) Lab.


[#131] (#131) Przeplot obrazu (Interlacing):
>>a) Polega na wyÅ›wietlaniu najpierw linii parzystych, a nastÄ™pnie nieparzystych (lub odwrotnie).
b) algorytm renderingu bazujÄ…cy na skalowaniu obrazu.
c) technika antyaliasingu przestrzennego.
d) metoda kompresji bezstratnej.
e) sÅ‚uÅ¼y do zwiÄ™kszenia rozdzielczoÅ›ci pionowej.
f) jest stosowany w nowoczesnych monitorach LCD.


[#132] (#132) SkrÃ³t RLE (Run-Length Encoding) oznacza:
>>a) MetodÄ™ bezstratnej kompresji danych polegajÄ…cÄ… na zliczaniu powtÃ³rzeÅ„ tych samych wartoÅ›ci.
b) wspieranÄ… sprzÄ™towo bibliotekÄ™ do grafiki 3D.
c) algorytm rasteryzacji linii.
d) format zapisu tekstur 3D.
e) metodÄ™ kompresji stratnej dÅºwiÄ™ku.
f) protokÃ³Å‚ przesyÅ‚ania obrazu w sieci.


[#133] (#133) Podstawowe transformacje geometryczne w grafice 3D to:
>>a) Translacja (przesuniÄ™cie), Rotacja (obrÃ³t) i Skalowanie.
b) przenikanie, zasÅ‚anianie, teksturowanie.
c) cieniowanie, oÅ›wietlanie, rzutowanie.
d) teselacja, kliping, rasteryzacja.
e) transformacja barwna.
f) filtracja splotowa.


[#134] (#134) W grafice 3D, Ray-Tracing:
>>a) Pozwala na Å‚atwe uzyskanie efektÃ³w takich jak cienie, odbicia zwierciadlane i zaÅ‚amania Å›wiatÅ‚a.
b) technika renderingu bazujÄ…ca na koncepcji modelu oÅ›wietlenia lokalnego.
c) jest zawsze szybszy od rasteryzacji.
d) nie obsÅ‚uguje przezroczystoÅ›ci.
e) polega na rzutowaniu wierzchoÅ‚kÃ³w na ekran.
f) nie wymaga obliczania przeciÄ™Ä‡ promienia z obiektami.


[#135] (#135) Bufor Z (Z-buffer):
>>a) SÅ‚uÅ¼y do rozstrzygania widocznoÅ›ci powierzchni poprzez przechowywanie gÅ‚Ä™bokoÅ›ci pikseli.
b) metoda nakÅ‚adania tekstury na obiekt.
c) sÅ‚uÅ¼y do przechowywania skÅ‚adowej alfa koloru.
d) jest wykorzystywany tylko w ray-tracingu.
e) przechowuje wspÃ³Å‚rzÄ™dne XY piksela.
f) zwiÄ™ksza zuÅ¼ycie pamiÄ™ci karty graficznej.


[#136] (#136) W grafice komputerowej 3D teselacja:
>>a) Polega na podziale skomplikowanych prymitywÃ³w geometrycznych na prostsze.
b) sÅ‚uÅ¼y do wygÅ‚adzania krawÄ™dzi (antyaliasing).
c) jest procesem zamiany obrazu wektorowego na rastrowy.
d) polega na usuwaniu niewidocznych krawÄ™dzi.
e) jest wykonywana wyÅ‚Ä…cznie na procesorze (CPU).
f) sÅ‚uÅ¼y do kompresji siatek wielokÄ…tÃ³w.


[#137] (#137) Cieniowanie Phonga (Phong Shading):
>>a) Polega na interpolacji wektorÃ³w normalnych wewnÄ…trz wielokÄ…ta i obliczaniu modelu oÅ›wietlenia dla kaÅ¼dego piksela.
b) technika cieniowania polegajÄ…ca na obliczeniu jasnoÅ›ci dla jednego z wierzchoÅ‚kÃ³w fasety.
c) jest identyczne z cieniowaniem Gourauda.
d) nie pozwala na uzyskanie odblaskÃ³w zwierciadlanych.
e) jest mniej kosztowne obliczeniowo niÅ¼ cieniowanie Gourauda.
f) daje gorsze efekty wizualne niÅ¼ cieniowanie pÅ‚askie (flat).


[#138] (#138) Algorytm bankiera (Dijkstra) sÅ‚uÅ¼y do:
>>a) unikania zakleszczenia (deadlock avoidance) poprzez sprawdzanie stanu bezpiecznego.
b) wykrywania cykli w grafie zasobÃ³w.
c) szeregowania procesÃ³w w systemie czasu rzeczywistego.
d) zarzÄ…dzania pamiÄ™ciÄ… wirtualnÄ….
e) znajdowania najkrÃ³tszej Å›cieÅ¼ki w sieci komputerowej.
f) optymalizacji zuÅ¼ycia energii przez procesor.


[#139] (#139) Buforowanie plikÃ³w (File Buffering):
>>a) ZwiÄ™ksza wydajnoÅ›Ä‡ poprzez redukcjÄ™ liczby fizycznych operacji wejÅ›cia/wyjÅ›cia na dysku.
b) sÅ‚uÅ¼y wyÅ‚Ä…cznie do zabezpieczenia danych przed usuniÄ™ciem.
c) uniemoÅ¼liwia jednoczesny dostÄ™p wielu procesÃ³w do pliku.
d) jest realizowane tylko w systemach 64-bitowych.
e) polega na szyfrowaniu zawartoÅ›ci pliku.
f) jest zawsze zarzÄ…dzane przez uÅ¼ytkownika, a nie system operacyjny.


[#140] (#140) Centralny Procesor, po otrzymaniu informacji o przerwaniu z urzÄ…dzenia wejÅ›cia/wyjÅ›cia:
>>a) Procesor koÅ„czy bieÅ¼Ä…cÄ… instrukcjÄ™, zapisuje stan i przekazuje sterowanie do ISR.
b) procesor natychmiast przerywa wykonywanie bieÅ¼Ä…cej instrukcji w jej poÅ‚owie.
c) przerwania sÄ… ignorowane w trybie uÅ¼ytkownika.
d) tylko system operacyjny moÅ¼e generowaÄ‡ przerwania.
>>e) przerwania mogÄ… byÄ‡ maskowalne lub niemaskowalne (NMI).
f) po obsÅ‚udze przerwania procesor zawsze restartuje system.


[#141] (#141) Inicjalna wartoÅ›Ä‡ semafora binarnego implementujÄ…cego sekcjÄ™ krytycznÄ… (mutex) wynosi:
>>a) 1
b) 0
c) -1
d) n (liczba procesÃ³w)
e) nieskoÅ„czonoÅ›Ä‡
f) 2


[#142] (#142) Algorytm szeregowania z wywÅ‚aszczaniem (preemptive scheduling):
>>a) Pozwala na przerwanie bieÅ¼Ä…cego procesu i przekazanie procesora innemu procesowi.
b) szeregowanie bez wywÅ‚aszczenia.
c) nie pozwala na zmianÄ™ procesu przed jego zakoÅ„czeniem.
d) jest stosowany tylko w systemach wsadowych.
>>e) przykÅ‚adem jest algorytm Round Robin (karuzelowy).
f) minimalizuje liczbÄ™ przeÅ‚Ä…czeÅ„ kontekstu.


[#143] (#143) Aby system operacyjny mÃ³gÅ‚ wykonywaÄ‡ wielozadaniowoÅ›Ä‡ (multitasking):
>>a) Wymaga wsparcia sprzÄ™towego (np. przerwania zegarowe, ochrona pamiÄ™ci).
b) musi posiadaÄ‡ przynajmniej 2 procesory fizyczne.
c) nie moÅ¼e uÅ¼ywaÄ‡ pamiÄ™ci wirtualnej.
d) wymaga, aby wszystkie programy byÅ‚y napisane w tym samym jÄ™zyku.
>>e) musi implementowaÄ‡ mechanizm przeÅ‚Ä…czania kontekstu (context switching).
f) nie moÅ¼e obsÅ‚ugiwaÄ‡ sieci.


[#144] (#144) JeÅ¼eli wirtualny adres w programie jest 16 bitowy i rozmiar strony jest 0,5 K to moÅ¼emy maksymalnie zaadresowaÄ‡ nastÄ™pujÄ…cÄ… liczbÄ™ stron:
>>a) 128.
b) 64.
c) 256.
d) 1024.
e) 512.
f) 32.


[#145] (#145) PamiÄ™Ä‡ asocjacyjna (TLB - Translation Lookaside Buffer):
>>a) Przechowuje ostatnio uÅ¼ywane mapowania adresÃ³w wirtualnych na fizyczne.
b) jest konieczna dla efektywnej realizacji stronicowania.
c) sÅ‚uÅ¼y do przechowywania danych na dysku.
d) jest wolniejsza od pamiÄ™ci RAM.
>>e) jest rodzajem pamiÄ™ci cache dla tablicy stron.
f) przechowuje kody instrukcji procesora.


[#146] (#146) Maksymalna liczba procesÃ³w wewnÄ…trz sekcji krytycznej (dla zapewnienia wzajemnego wykluczania):
>>a) 1
b) 2
c) Dowolna liczba.
d) 0
e) n-1
f) n


[#147] (#147) Problem producent-konsument moÅ¼e byÄ‡ rozwiÄ…zany przy pomocy:
>>a) Semafory, monitory, kolejki komunikatÃ³w.
b) tylko MonitorÃ³w.
c) wyÅ‚Ä…cznie zmiennych globalnych.
d) tylko w systemach jednoprocesorowych.
e) algorytmu Dijkstry znajdowania najkrÃ³tszej Å›cieÅ¼ki.
f) instrukcji skoku bezwarunkowego.


[#148] (#148) Stan uprzywilejowany (Kernel Mode):
>>a) Pozwala na wykonywanie wszystkich instrukcji procesora, w tym instrukcji sterujÄ…cych sprzÄ™tem.
b) umoÅ¼liwia wykonywanie instrukcji systemu operacyjnego.
c) jest dostÄ™pny dla kaÅ¼dej aplikacji uÅ¼ytkownika.
d) sÅ‚uÅ¼y do przyspieszania obliczeÅ„ matematycznych.
>>e) przejÅ›cie do tego stanu nastÄ™puje m.in. podczas wywoÅ‚ania systemowego (system call).
f) wyklucza dostÄ™p do pamiÄ™ci RAM.


[#149] (#149) Komunikacja synchroniczna miÄ™dzy procesami:
>>a) Powoduje zawieszenie procesu wysyÅ‚ajÄ…cego do momentu odebrania komunikatu przez odbiorcÄ™.
b) umoÅ¼liwia procesom synchronizacjÄ™ ich aktywnoÅ›ci.
c) nie wymaga potwierdzenia odbioru.
d) jest zawsze szybsza od komunikacji asynchronicznej.
>>e) jest realizowana np. przez mechanizm rendezvous.
f) nie moÅ¼e byÄ‡ stosowana w systemach rozproszonych.


[#150] (#150) Parser LR:
>>a) Jest parserem typu bottom-up (od doÅ‚u do gÃ³ry).
b) odczytuje symbole wejÅ›ciowe od lewej strony do prawej.
c) nie obsÅ‚uguje gramatyk z lewostronnÄ… rekurencjÄ….
d) jest wolniejszy od parsera LL.
>>e) buduje wyprowadzenie prawostronne w odwrotnej kolejnoÅ›ci.
f) jest stosowany tylko dla jÄ™zykÃ³w regularnych.


[#151] (#151) RozstrzygalnoÅ›Ä‡ przynaleÅ¼noÅ›ci gramatyki bezkontekstowej do klasy LL(k):
>>a) Jest rozstrzygalna dla dowolnego ustalonego k.
b) jest rozstrzygalne tylko jeÅ›li gramatyka zawiera lewostronnÄ… rekurencjÄ™.
c) jest nierozstrzygalna dla k > 1.
d) zaleÅ¼y od liczby symboli terminalnych.
e) jest nierozstrzygalna dla gramatyk wieloznacznych.
f) wymaga sprowadzenia do postaci normalnej Chomsky'ego.


[#152] (#152) PorÃ³wnanie gramatyk LL i LR:
>>a) Klasa gramatyk LL(k) jest wÅ‚aÅ›ciwym podzbiorem klasy gramatyk LR(k).
b) gramatyki LL oraz LR opisujÄ… czÄ™Å›ciowo rozÅ‚Ä…czne klasy gramatyk.
c) KaÅ¼da gramatyka LR jest gramatykÄ… LL.
d) Gramatyki LL sÄ… potÄ™Å¼niejsze od LR.
>>e) Gramatyki LR radzÄ… sobie z lewostronnÄ… rekurencjÄ…, ktÃ³rej LL nie obsÅ‚uguje bezpoÅ›rednio.
f) Gramatyki LL(1) sÄ… rÃ³wnowaÅ¼ne gramatykom LR(1).


[#153] (#153) ZÅ‚oÅ¼onoÅ›Ä‡ analizatorÃ³w LL(k) oraz LR(k) dla sÅ‚owa o dÅ‚ugoÅ›ci n wynosi:
>>a) Czasowa O(n) i pamiÄ™ciowa O(n).
b) czasowÄ… Theta(n) i pamiÄ™ciowÄ… Theta(n).
c) Czasowa O(n^2).
d) Czasowa O(2^n).
e) PamiÄ™ciowa O(1).
f) Czasowa O(log n).


[#154] (#154) Dla gramatyki bezkontekstowej z produkcjami:
Eâ†’E+E
Eâ†’E*E
E â†’ id
nastÄ™pujÄ…ce wyprowadzenia sÄ… prawostronne:
>>a) E => E+E => E+EE => E+Eid => E+idid => id+idid.
b) E => E+E => id+E => id+EE => id+idE => id+idid.
c) E => id.
d) E => EE => idid.
e) Jest niemoÅ¼liwe dla tej gramatyki.
f) Zawsze koÅ„czy siÄ™ symbolem E.


[#155] (#155) KtÃ³re stwierdzenie jest prawdziwe dotyczÄ…ce gramatyk LR?
>>a) Nie kaÅ¼da gramatyka bezkontekstowa jest klasy LR(k) (np. gramatyki wieloznaczne nie sÄ… LR).
b) KaÅ¼da gramatyka bezkontekstowa jest klasy LR(k) dla pewnego k > 0.
c) Gramatyki LR(0) mogÄ… opisywaÄ‡ wszystkie jÄ™zyki bezkontekstowe.
d) Analiza LR wymaga gramatyki w postaci normalnej Greibach.
>>e) Gramatyki LR(1) sÄ… wystarczajÄ…ce do opisu wiÄ™kszoÅ›ci jÄ™zykÃ³w programowania.
f) Gramatyki LR nie mogÄ… byÄ‡ generowane automatycznie.


[#156] (#156) Dla gramatyki bezkontekstowej z produkcjami:
E' â†’ E
Eâ†’E+T | T
Tâ†’T*F|F
F â†’ (E) | id
domkniÄ™cie (closure) zbioru sytuacji I= {E' â†’â€¢E} zawiera sytuacje:
>>a) E' -> .E, E -> .E+T, E -> .T, T -> .TF, T -> .F, F -> .(E), F -> .id.
b) E' -> E.
c) E -> E.+T.
d) F -> id.
e) Tylko E' -> .E.
f) Wszystkie produkcje z kropkÄ… na koÅ„cu.


[#157] (#157) Dana jest gramatyka (wzbogacona) z produkcjami:
E' â†’ E
Eâ†’E+T | T
Tâ†’T*F|F
F â†’ (E) | id
KtÃ³re z podanych symboli naleÅ¼Ä… do zbioru FOLLOW(F):
>>a) +, *, ), $ (koniec napisu).
b) id.
c) E, T.
d) (, id.
e) Tylko $.
f) Wszystkie nieterminale.


[#158] (#158) Gramatyka operatorowa:
>>a) To gramatyka bezkontekstowa, w ktÃ³rej Å¼adna produkcja nie ma po prawej stronie dwÃ³ch sÄ…siednich nieterminali ani epsilona.
b) Gramatyka operatorowa jest gramatykÄ… bezkontekstowÄ….
c) SÅ‚uÅ¼y wyÅ‚Ä…cznie do opisu jÄ™zykÃ³w regularnych.
d) Nie moÅ¼e zawieraÄ‡ symboli terminalnych.
>>e) Pozwala na Å‚atwÄ… implementacjÄ™ parserÃ³w wyraÅ¼eÅ„ matematycznych.
f) Jest zawsze wieloznaczna.


[#159] (#159) Analiza leksykalna (skaner) obejmuje:
>>a) Grupowanie znakÃ³w wejÅ›ciowych w leksemy i generowanie odpowiadajÄ…cych im tokenÃ³w.
b) usuniÄ™cie tokenÃ³w a znalezienie leksemÃ³w.
c) budowanie drzewa skÅ‚adniowego.
d) sprawdzanie zgodnoÅ›ci typÃ³w.
>>e) usuwanie komentarzy i biaÅ‚ych znakÃ³w z kodu ÅºrÃ³dÅ‚owego.
f) generowanie kodu poÅ›redniego.


[#160] (#160) Analizatory LL oraz LR:
>>a) Oba sÄ… analizatorami kierunkowymi (przetwarzajÄ… wejÅ›cie od lewej do prawej).
b) LL nie jest analizatorem kierunkowym.
c) LR przetwarza wejÅ›cie od prawej do lewej.
d) Å»aden z nich nie uÅ¼ywa stosu.
>>e) WykorzystujÄ… wiedzÄ™ o symbolach juÅ¼ przetworzonych oraz podglÄ…dajÄ… symbole w przÃ³d (lookahead).
f) SÄ… stosowane tylko w kompilatorach jÄ™zyka C.


[#161] (#161) Parametr k w analizatorach LL(k) oznacza:
>>a) LiczbÄ™ symboli podglÄ…danych (lookahead) w przÃ³d na wejÅ›ciu.
b) parametr k oznacza liczbÄ™ bÅ‚Ä™dÃ³w, po ktÃ³rych analizator przerywa dziaÅ‚anie.
c) liczbÄ™ krokÃ³w wyprowadzenia.
d) maksymalnÄ… gÅ‚Ä™bokoÅ›Ä‡ stosu.
e) liczbÄ™ nieterminali w gramatyce.
f) liczbÄ™ stanÃ³w automatu.


[#162] (#162) KtÃ³ra z poniÅ¼szych opcji najlepiej opisuje klasyfikacjÄ™ Chomsky'ego dotyczÄ…cÄ… gramatyk formalnych?
>>a) Cztery poziomy gramatyk: typ 0, typ 1, typ 2, typ 3.
b) Klasyfikacja Chomsky'ego obejmuje piÄ™Ä‡ poziomÃ³w gramatyk.
c) Tylko jÄ™zyki programowania.
d) WyÅ‚Ä…cznie gramatyki skoÅ„czone.
>>e) Typ 2 to gramatyki bezkontekstowe, a typ 3 to gramatyki regularne.
f) Typ 0 to gramatyki liniowe.


[#163] (#163) KtÃ³re z poniÅ¼szych stwierdzeÅ„ najlepiej opisuje rolÄ™ metajÄ™zyka w kontekÅ›cie antynomii semantycznych?
>>a) MetajÄ™zyk sÅ‚uÅ¼y do opisu i analizy innego jÄ™zyka (przedmiotowego).
b) MetajÄ™zyk jest jÄ™zykiem, ktÃ³ry jest bardziej zÅ‚oÅ¼ony niÅ¼ jÄ™zyk przedmiotowy.
c) MetajÄ™zyk nie moÅ¼e zawieraÄ‡ nazw.
d) MetajÄ™zyk jest zawsze jÄ™zykiem naturalnym.
>>e) RozrÃ³Å¼nienie jÄ™zyka przedmiotowego od metajÄ™zyka pozwala na definiowanie prawdy bez popadania w paradoksy.
f) MetajÄ™zyk sÅ‚uÅ¼y wyÅ‚Ä…cznie do tÅ‚umaczenia tekstÃ³w.


[#164] (#164) KtÃ³re z poniÅ¼szych stwierdzeÅ„ najlepiej opisuje rÃ³Å¼nicÄ™ miÄ™dzy wybranymi paradygmatami jÄ™zykÃ³w programowania?
>>a) Paradygmat imperatywny opisuje "jak", deklaratywny opisuje "co".
b) Paradygmat imperatywny jest stosowany wyÅ‚Ä…cznie w jÄ™zykach niskiego poziomu.
c) JÄ™zyki funkcyjne sÄ… zawsze imperatywne.
d) Programowanie obiektowe wyklucza paradygmat deklaratywny.
>>e) Programowanie obiektowe skupia siÄ™ na Å‚Ä…czeniu danych i zachowaÅ„ w obiekty.
f) Paradygmat logiczny jest podzbiorem paradygmatu imperatywnego.


[#165] (#165) W kontekÅ›cie paradygmatÃ³w jÄ™zykÃ³w programowania, ktÃ³re z poniÅ¼szych stwierdzeÅ„ najlepiej charakteryzujÄ… ich wÅ‚asnoÅ›ci
>>a) Paradygmat funkcyjny opiera siÄ™ na ewaluacji funkcji matematycznych, logiczny na wnioskowaniu.
b) Paradygmat funkcyjny skupia siÄ™ na niezmiennych danych i funkcjach jako podstawowych jednostkach obliczeÅ„.
c) W paradygmacie logicznym nie istniejÄ… zmienne.
d) Oba paradygmaty sÄ… odmianami programowania proceduralnego.
>>e) Oba paradygmaty naleÅ¼Ä… do szerszej grupy paradygmatÃ³w deklaratywnych.
f) JÄ™zyk Prolog jest przykÅ‚adem jÄ™zyka funkcyjnego.


[#166] (#166) KtÃ³re z poniÅ¼szych stwierdzeÅ„ najlepiej opisujÄ… rÃ³Å¼nicÄ™ miÄ™dzy pewnymi pewnymi typami algorytmÃ³w:
>>a) Algorytm deterministyczny dla tych samych danych zawsze przechodzi przez tÄ™ samÄ… Å›cieÅ¼kÄ™ obliczeÅ„.
b) Algorytm deterministyczny zawsze daje rÃ³Å¼ne wyniki dla tych samych danych wejÅ›ciowych.
c) Algorytm niedeterministyczny nie moÅ¼e byÄ‡ zaimplementowany na komputerze.
d) ZÅ‚oÅ¼onoÅ›Ä‡ P dotyczy algorytmÃ³w niedeterministycznych.
>>e) Algorytm niedeterministyczny moÅ¼e byÄ‡ postrzegany jako posiadajÄ…cy zdolnoÅ›Ä‡ "zgadywania" poprawnej Å›cieÅ¼ki.
f) KaÅ¼dy algorytm niedeterministyczny ma zÅ‚oÅ¼onoÅ›Ä‡ wykÅ‚adniczÄ….


[#167] (#167) KtÃ³re stwierdzenia dotyczÄ…ce entropii Shannona sÄ… prawdziwe:
>>a) OkreÅ›la Å›redniÄ… iloÅ›Ä‡ informacji przypadajÄ…cÄ… na jeden symbol ÅºrÃ³dÅ‚a.
b) WartoÅ›Ä‡ entropii zawsze jest dodatnia (lub zero).
c) Jest maksymalna, gdy wszystkie symbole majÄ… rÃ³Å¼ne prawdopodobieÅ„stwa.
d) Nie zaleÅ¼y od prawdopodobieÅ„stwa wystÄ…pienia symboli.
>>e) Entropia jest maksymalna dla rozkÅ‚adu jednostajnego (wszystkie symbole rÃ³wnie prawdopodobne).
f) JednostkÄ… entropii jest zawsze bajt.


[#168] (#168) KtÃ³re z podanych stwierdzeÅ„ w odniesieniu do kodu Hamminga sÄ… prawdziwe:
>>a) Pozwala na wykrywanie i korekcjÄ™ bÅ‚Ä™dÃ³w pojedynczego bitu (SEC) oraz wykrywanie bÅ‚Ä™dÃ³w dwÃ³ch bitÃ³w (DED).
b) Kod Hamminga pozwala korygowaÄ‡ bÅ‚Ä™dy polegajÄ…ce na przekÅ‚amaniu dwÃ³ch bitÃ³w.
c) Jest kodem o zmiennej dÅ‚ugoÅ›ci sÅ‚owa.
d) Nie uÅ¼ywa bitÃ³w parzystoÅ›ci.
>>e) OdlegÅ‚oÅ›Ä‡ Hamminga dla kodu korygujÄ…cego pojedyncze bÅ‚Ä™dy musi wynosiÄ‡ co najmniej 3.
f) Kod Hamminga jest kodem stratnym.


[#169] (#169) Kodowanie Shannona-Fano i Huffmana:
>>a) TworzÄ… kody prefiksowe.
b) Kodowanie Shannona-Fano tworzy kod postfiksowy.
c) SÄ… metodami kompresji stratnej.
d) Huffmana daje zawsze gorsze wyniki niÅ¼ Shannona-Fano.
>>e) Kodowanie Huffmana jest optymalnym kodowaniem prefiksowym dla danych prawdopodobieÅ„stw symboli.
f) Oba kody wymagajÄ… przesyÅ‚ania sÅ‚ownika razem z danymi.


[#170] (#170) KtÃ³re stwierdzenia dotyczÄ…ce kompresji JPEG sÄ… prawdziwe:
>>a) Wykorzystuje stratnÄ… kompresjÄ™ opartÄ… na dyskretnej transformacie kosinusowej (DCT).
b) Typowo w procesie kompresji wykorzystuje transformatÄ™ Fouriera.
c) Jest optymalna do kompresji tekstu i grafiki o ostrych krawÄ™dziach.
d) Nie pozwala na regulacjÄ™ stopnia kompresji.
>>e) Wykorzystuje kwantyzacjÄ™ w celu usuniÄ™cia informacji mniej istotnych dla ludzkiego oka.
f) Jest formatem wyÅ‚Ä…cznie bezstratnym.


[#171] (#171) PracujÄ…c w powÅ‚oce bash pod kontrolÄ… systemu operacyjnego Linux lub UNIX uruchomienie polecenia: rm / && echo ok
>>a) Zazwyczaj zakoÅ„czy siÄ™ bÅ‚Ä™dem, a "ok" nie zostanie wypisane.
b) spowoduje wypisanie na standardowym wyjÅ›ciu komunikatu o niemoÅ¼noÅ›ci usuniÄ™cia katalogu /
c) usunie wszystkie pliki w systemie.
d) wypisze "ok" niezaleÅ¼nie od wyniku rm.
>>e) Operator && wykonuje drugie polecenie tylko wtedy, gdy pierwsze zakoÅ„czyÅ‚o siÄ™ sukcesem (kod wyjÅ›cia 0).
f) Polecenie rm / bez opcji -r usunie katalog gÅ‚Ã³wny.


[#172] (#172) PracujÄ…c w powÅ‚oce bash systemu operacyjnego Linux lub UNIX uÅ¼ycie wzorca nazwy pliku data.{txt,sql,iq} bÄ™dzie pasowaÄ‡ do pliku o
nazwie:
>>a) data.txt, data.sql lub data.iq.
b) data.
c) dowolnego pliku zaczynajÄ…cego siÄ™ od data.
d) tylko pliku o nazwie data.{txt,sql,iq}.
e) plikÃ³w o nazwach data.txtsql i data.txtiq.
f) wzorzec ten nie jest obsÅ‚ugiwany przez bash.


[#173] (#173) Uprawnienia w systemie Linux/UNIX:
>>a) System opiera siÄ™ na uprawnieniach dla wÅ‚aÅ›ciciela, grupy i innych (rwx).
b) kaÅ¼dy uÅ¼ytkownik ma dostÄ™p do wszystkich plikÃ³w zarzÄ…dzanych przez system operacyjny.
c) tylko administrator (root) moÅ¼e czytaÄ‡ pliki.
d) uprawnienia nie dotyczÄ… katalogÃ³w.
>>e) Uprawnienie 'x' dla katalogu pozwala na wejÅ›cie do niego (cd).
f) Uprawnienia sÄ… zapisywane w treÅ›ci pliku.


[#174] (#174) PosÅ‚ugujÄ…c siÄ™ nazwami plikÃ³w, pracujÄ…c w powÅ‚oce bash systemu operacyjnego Linux lub UNIX, ? (pytajnik) oznacza:
>>a) dokÅ‚adnie jeden dowolny znak.
b) dowolny ciÄ…g znakÃ³w (w tym pusty).
c) zero lub jeden znak.
d) znak zapytania.
e) dowolnÄ… cyfrÄ™.
f) dowolnÄ… literÄ™.


[#175] (#175) System Linux/UNIX:
>>a) Jest systemem wielozadaniowym i wielouÅ¼ytkownikowym.
b) obsÅ‚uguje wielu uÅ¼ytkownikÃ³w.
c) nie posiada systemu plikÃ³w.
d) jest systemem czasu rzeczywistego z natury.
>>e) JÄ…dro (kernel) zarzÄ…dza zasobami sprzÄ™towymi i udostÄ™pnia je aplikacjom.
f) Jest systemem wyÅ‚Ä…cznie tekstowym.


[#176] (#176) Zmienna $? w powÅ‚oce bash dla systemu operacyjnego Linux lub UNIX przechowuje wartoÅ›Ä‡:
>>a) kod wyjÅ›cia (exit status) ostatnio wykonanego polecenia.
b) nie ma takiej zmiennej.
c) identyfikator procesu powÅ‚oki.
d) ostatni argument poprzedniego polecenia.
e) liczbÄ™ argumentÃ³w przekazanych do skryptu.
f) nazwÄ™ bieÅ¼Ä…cego uÅ¼ytkownika.


[#177] (#177) Uruchomienie, w powÅ‚oce bash systemu operacyjnego Linux lub UNIX, polecenia: ls | less powoduje:
>>a) przekazanie standardowego wyjÅ›cia ls na standardowe wejÅ›cie less.
b) przekazanie standardowego wyjÅ›cia less na standardowe wejÅ›cie ls.
c) rÃ³wnolegÅ‚e wykonanie obu poleceÅ„ bez powiÄ…zania.
d) zapisanie wyniku ls do pliku o nazwie less.
>>e) UmoÅ¼liwia wygodne przeglÄ…danie dÅ‚ugiej listy plikÃ³w generowanej przez ls.
f) WyÅ›wietla tylko bÅ‚Ä™dy polecenia ls.


[#178] (#178) KorzystajÄ…c z systemu operacyjnego Linux lub UNIX, ustawienie praw dostÄ™pu 700 na pliku oznacza:
>>a) PeÅ‚ne prawa (rwx) dla wÅ‚aÅ›ciciela i brak jakichkolwiek praw dla grupy i innych.
b) brak praw dla innych.
c) prawo tylko do odczytu dla wszystkich.
d) prawo do wykonywania dla grupy.
e) prawo do zapisu dla wszystkich.
f) plik jest ukryty.


[#179] (#179) PracujÄ…c w powÅ‚oce bash systemu operacyjnego Linux lub UNIX uÅ¼ycie skrÃ³tu klawiszowego Control-c powoduje:
>>a) WysyÅ‚a sygnaÅ‚ SIGINT do bieÅ¼Ä…cego procesu na pierwszym planie.
b) nic.
c) kopiuje zaznaczony tekst.
d) wylogowuje uÅ¼ytkownika.
>>e) Powoduje zazwyczaj natychmiastowe przerwanie dziaÅ‚ania programu.
f) Zamyka wszystkie okna terminala.


[#180] (#180) PracujÄ…c w powÅ‚oce bash systemu operacyjnego Linux lub UNIX, uÅ¼ycie skrÃ³tu klawiszowego Control-z powoduje:
>>a) WysyÅ‚a sygnaÅ‚ SIGTSTP, wstrzymujÄ…c dziaÅ‚anie procesu i przenoszÄ…c go w tÅ‚o.
b) wstrzymanie dziaÅ‚ania aktualnie obsÅ‚ugiwanego procesu.
c) zamyka terminal.
d) cofa ostatniÄ… operacjÄ™ w edytorze.
>>e) Proces wstrzymany moÅ¼na przywrÃ³ciÄ‡ poleceniem 'fg' lub 'bg'.
f) Usuwa bieÅ¼Ä…cÄ… liniÄ™ poleceÅ„.


[#181] (#181) PosÅ‚ugujÄ…c siÄ™ nazwami plikÃ³w, pracujÄ…c w powÅ‚oce bash systemu operacyjnego Linux lub UNIX, * (gwiazdka) oznacza:
>>a) dowolny ciÄ…g znakÃ³w (rÃ³wnieÅ¼ pusty).
b) pojedynczy znak.
c) tylko litery.
d) tylko cyfry.
e) dowolny znak poza kropkÄ… na poczÄ…tku nazwy.
f) tylko rozszerzenia plikÃ³w.


[#182] (#182) Pliki, ktÃ³rych nazwa zaczyna siÄ™ od kropki (np. .bashrc):
>>a) SÄ… traktowane jako pliki ukryte.
b) nie mogÄ… byÄ‡ uÅ¼ywane.
c) sÄ… plikami systemowymi tylko do odczytu.
d) muszÄ… mieÄ‡ rozszerzenie .dot.
>>e) MoÅ¼na je wyÅ›wietliÄ‡ za pomocÄ… polecenia 'ls -a'.
f) SÄ… automatycznie usuwane przy wylogowaniu.


[#183] (#183) PracujÄ…c w powÅ‚oce bash systemu operacyjnego Linux lub UNIX uÅ¼ycie wzorca nazwy pliku [123]data bÄ™dzie pasowaÄ‡ do:
>>a) 1data, 2data lub 3data.
b) data.
c) 123data.
d) dowolnego pliku koÅ„czÄ…cego siÄ™ na data.
e) plikÃ³w o nazwach [1]data, [2]data, [3]data.
f) tylko pliku o nazwie [123]data.


[#184] (#184) Relacja rozszerzenia (<<extend>>) w diagramach przypadkÃ³w uÅ¼ycia UML:
>>a) Wskazuje opcjonalne zachowanie, ktÃ³re moÅ¼e zostaÄ‡ doÅ‚Ä…czone do przypadku uÅ¼ycia.
b) UÅ¼ywana jest do pokazania, Å¼e przypadek uÅ¼ycia jest podzbiorem innego przypadku uÅ¼ycia.
c) Jest obowiÄ…zkowa dla kaÅ¼dego przypadku uÅ¼ycia.
d) SÅ‚uÅ¼y do modelowania dziedziczenia miÄ™dzy aktorami.
>>e) StrzaÅ‚ka relacji <<extend>> jest skierowana od przypadku uÅ¼ycia rozszerzajÄ…cego do bazowego.
f) Zawsze wykonuje siÄ™ razem z przypadkiem bazowym.


[#185] (#185) Relacja â€zawieraâ€ (<<include>>) w diagramach przypadkÃ³w uÅ¼ycia UML:
>>a) Wskazuje, Å¼e jeden przypadek uÅ¼ycia obowiÄ…zkowo wykorzystuje funkcjonalnoÅ›Ä‡ innego.
b) OkreÅ›la, Å¼e jeden przypadek uÅ¼ycia jest w caÅ‚oÅ›ci zaleÅ¼ny od funkcjonalnoÅ›ci innego przypadku uÅ¼ycia.
c) Jest uÅ¼ywana do modelowania opcjonalnych funkcji.
d) ÅÄ…czy aktora z przypadkiem uÅ¼ycia.
>>e) Pozwala na wydzielenie wspÃ³lnej funkcjonalnoÅ›ci do oddzielnego przypadku uÅ¼ycia.
f) StrzaÅ‚ka jest skierowana od przypadku doÅ‚Ä…czanego do bazowego.


[#186] (#186) Jakie sÄ… kluczowe cechy podejÅ›cia strukturalnego Yourdona do analizy systemÃ³w?
>>a) Opiera siÄ™ na dekompozycji funkcjonalnej systemu i wykorzystuje diagramy przepÅ‚ywu danych (DFD).
b) Modelowanie zachowaÅ„ systemu z uÅ¼yciem zÅ‚oÅ¼onych diagramÃ³w stanÃ³w dla kaÅ¼dej funkcji.
c) Jest toÅ¼same z podejÅ›ciem obiektowym.
d) Nie uwzglÄ™dnia modelowania danych.
>>e) Wykorzystuje sÅ‚ownik danych oraz specyfikacje procesÃ³w.
f) Jest nowoczesnÄ… alternatywÄ… dla Agile.


[#187] (#187) Model spiralny cyklu Å¼ycia oprogramowania:
>>a) Jest modelem iteracyjnym, w ktÃ³rym kluczowym elementem jest analiza ryzyka.
b) GÅ‚Ã³wny nacisk kÅ‚adziony jest na szybkie wytwarzanie oprogramowania bez fazy testowania.
c) Wyklucza moÅ¼liwoÅ›Ä‡ powrotu do poprzednich faz.
d) Jest przeznaczony tylko dla bardzo maÅ‚ych projektÃ³w.
>>e) KaÅ¼dy obrÃ³t spirali obejmuje planowanie, analizÄ™ ryzyka, inÅ¼ynieriÄ™ i ocenÄ™.
f) Jest modelem liniowym (kaskadowym).


[#188] (#188) Cele metodyki Scrum:
>>a) Dostarczanie wartoÅ›ci biznesowej w krÃ³tkich iteracjach (Sprintach).
b) ZwiÄ™kszenie przewidywalnoÅ›ci i jakoÅ›ci dostaw poprzez regularne iteracje i staÅ‚e przeglÄ…dy.
c) Wyeliminowanie potrzeby dokumentacji technicznej.
d) Sztywne planowanie caÅ‚ego projektu na samym poczÄ…tku.
>>e) Wspieranie samoorganizacji zespoÅ‚u i ciÄ…gÅ‚ego doskonalenia procesu.
f) ZastÄ…pienie programistÃ³w przez Scrum MasterÃ³w.


[#189] (#189) Poziomy dojrzaÅ‚oÅ›ci w modelu CMM (Capability Maturity Model):
>>a) PoczÄ…tkowy, Powtarzalny, Zdefiniowany, ZarzÄ…dzany, OptymalizujÄ…cy.
b) Analiza, Projektowanie, WdroÅ¼enie, Ocena.
c) Niski, Åšredni, Wysoki, Ekspercki.
d) Planowanie, Realizacja, Testowanie, Utrzymanie.
e) Poziom 0, Poziom 1, Poziom 2, Poziom 3, Poziom 4.
f) Brak, Podstawowy, Zaawansowany, Profesjonalny.


[#190] (#190) ZdolnoÅ›Ä‡ do pielÄ™gnacji (Maintainability) oprogramowania:
>>a) ÅatwoÅ›Ä‡, z jakÄ… moÅ¼na modyfikowaÄ‡ oprogramowanie w celu naprawy bÅ‚Ä™dÃ³w lub dostosowania.
b) zawartoÅ›Ä‡ peÅ‚nej dokumentacji technicznej kodu.
c) odpornoÅ›Ä‡ systemu na ataki hakerskie.
d) szybkoÅ›Ä‡ dziaÅ‚ania aplikacji na starym sprzÄ™cie.
>>e) Obejmuje takie aspekty jak czytelnoÅ›Ä‡ kodu, modularnoÅ›Ä‡ i testowalnoÅ›Ä‡.
f) Gwarantuje, Å¼e oprogramowanie nigdy nie bÄ™dzie wymagaÅ‚o zmian.


[#191] (#191) NiezawodnoÅ›Ä‡ (Reliability) oprogramowania:
>>a) ZdolnoÅ›Ä‡ systemu do poprawnego dziaÅ‚ania w okreÅ›lonych warunkach przez okreÅ›lony czas.
b) w miarÄ™ moÅ¼liwoÅ›ci najkrÃ³tszy okres bezczynnoÅ›ci po awarii.
c) zgodnoÅ›Ä‡ z wymaganiami estetycznymi uÅ¼ytkownika.
d) brak koniecznoÅ›ci aktualizacji systemu.
>>e) Jest mierzona m.in. przez MTBF (Mean Time Between Failures).
f) Oznacza, Å¼e system jest w 100% wolny od bÅ‚Ä™dÃ³w.


[#192] (#192) Proces inÅ¼ynierii wymagaÅ„:
>>a) Obejmuje pozyskiwanie, analizÄ™, specyfikacjÄ™, weryfikacjÄ™ i zarzÄ…dzanie wymaganiami.
b) wynajdowania, dokumentowania, wdraÅ¼ania.
c) dotyczy tylko wymagaÅ„ niefunkcjonalnych.
d) koÅ„czy siÄ™ przed rozpoczÄ™ciem projektowania.
>>e) Ma na celu zrozumienie i udokumentowanie potrzeb interesariuszy.
f) Jest wykonywany wyÅ‚Ä…cznie przez programistÃ³w.


[#193] (#193) Wymagania niefunkcjonalne (systemowe):
>>a) OkreÅ›lajÄ… jakoÅ›ciowe aspekty systemu, takie jak wydajnoÅ›Ä‡, bezpieczeÅ„stwo, dostÄ™pnoÅ›Ä‡.
b) opisujÄ… wÅ‚aÅ›ciwoÅ›ci i ograniczenia systemu np. niezawodnoÅ›Ä‡, czas odpowiedzi.
c) opisujÄ… konkretne funkcje, ktÃ³re system musi realizowaÄ‡.
d) sÄ… mniej waÅ¼ne od wymagaÅ„ funkcjonalnych.
>>e) CzÄ™sto nazywane sÄ… "atrybutami jakoÅ›ciowymi" systemu.
f) Nie mogÄ… byÄ‡ testowane.


[#194] (#194) Testy jednostkowe (Unit Tests):
>>a) SprawdzajÄ… poprawnoÅ›Ä‡ dziaÅ‚ania najmniejszych testowalnych czÄ™Å›ci kodu.
b) zawsze wykonywane sÄ… w peÅ‚nej izolacji od innych komponentÃ³w systemu.
c) sÄ… wykonywane przez uÅ¼ytkownika koÅ„cowego.
d) sÅ‚uÅ¼Ä… do testowania wydajnoÅ›ci caÅ‚ego systemu.
>>e) Automatyzacja testÃ³w jednostkowych uÅ‚atwia refaktoryzacjÄ™ kodu.
f) Powinny byÄ‡ pisane dopiero po zakoÅ„czeniu caÅ‚ego projektu.


[#195] (#195) Aby ograniczyÄ‡ zakres zmian w systemie (zasada niskiego sprzÄ™Å¼enia):
>>a) NaleÅ¼y stosowaÄ‡ hermetyzacjÄ™, interfejsy oraz modularnoÅ›Ä‡.
b) podejÅ›cie komponentowe.
c) naleÅ¼y pisaÄ‡ caÅ‚y kod w jednym pliku.
d) naleÅ¼y unikaÄ‡ stosowania wzorcÃ³w projektowych.
>>e) Komponenty powinny zaleÅ¼eÄ‡ od abstrakcji, a nie od konkretnych implementacji.
f) NaleÅ¼y stosowaÄ‡ jak najwiÄ™cej zmiennych globalnych.


[#196] (#196) PodejÅ›cie modelowe (Model-Driven Development):
>>a) Modele sÄ… gÅ‚Ã³wnym artefaktem procesu, z ktÃ³rych moÅ¼e byÄ‡ generowany kod ÅºrÃ³dÅ‚owy.
b) jednym z zadaÅ„ analizy jest budowa modeli, opisujÄ…cych dziaÅ‚anie systemu.
c) modele UML sÄ… jedynym sposobem modelowania.
d) nie jest prawdÄ… Å¼e modele mogÄ… sÅ‚uÅ¼yÄ‡ do dokumentacji.
>>e) Pozwala na podniesienie poziomu abstrakcji w procesie tworzenia oprogramowania.
f) Wyklucza udziaÅ‚ programistÃ³w w procesie.


[#197] (#197) PrzykÅ‚ad aktywnoÅ›ci DevOps:
>>a) CiÄ…gÅ‚a integracja i ciÄ…gÅ‚e wdraÅ¼anie (CI/CD) oraz automatyzacja infrastruktury.
b) automatyczne monitorowanie parametrÃ³w uruchomionej aplikacji.
c) oddzielenie zespoÅ‚u programistÃ³w od zespoÅ‚u administratorÃ³w.
d) rÄ™czne testowanie aplikacji przed kaÅ¼dym wydaniem.
>>e) WspÃ³Å‚praca miÄ™dzy zespoÅ‚ami rozwoju (Dev) i operacji (Ops) w caÅ‚ym cyklu Å¼ycia.
f) Pisanie dokumentacji w formacie PDF.


[#198] (#198) Diagramy sekwencji UML:
>>a) PrzedstawiajÄ… interakcje miÄ™dzy obiektami w ukÅ‚adzie chronologicznym.
b) linia Å¼ycia reprezentuje Å¼ycie obiektu w czasie trwania interakcji.
c) sÅ‚uÅ¼Ä… do modelowania statycznej struktury klas.
d) nie pokazujÄ… komunikatÃ³w asynchronicznych.
>>e) SkupiajÄ… siÄ™ na kolejnoÅ›ci przesyÅ‚anych komunikatÃ³w.
f) SÄ… odmianÄ… diagramÃ³w wdroÅ¼enia.


[#199] (#199) Diagramy stanÃ³w UML:
>>a) ModelujÄ… zachowanie obiektu poprzez opis stanÃ³w i zdarzeÅ„.
b) stan historii automatycznie aktualizuje stan obiektu.
c) sÄ… uÅ¼ywane wyÅ‚Ä…cznie do modelowania baz danych.
d) nie pozwalajÄ… na definiowanie stanÃ³w zagnieÅ¼dÅ¼onych.
>>e) SÄ… szczegÃ³lnie przydatne do modelowania systemÃ³w sterowania i protokoÅ‚Ã³w.
f) PokazujÄ… strukturÄ™ folderÃ³w w projekcie.


[#200] (#200) Diagramy aktywnoÅ›ci UML:
>>a) SÅ‚uÅ¼Ä… do modelowania przepÅ‚ywÃ³w sterowania i danych w procesach biznesowych lub algorytmach.
b) uÅ¼ycie "tokenu" w rÃ³Å¼nych Å›cieÅ¼kach przepÅ‚ywu reprezentuje przypadek uÅ¼ycia.
c) sÄ… identyczne z diagramami klas.
d) nie obsÅ‚ugujÄ… wspÃ³Å‚bieÅ¼noÅ›ci (fork/join).
>>e) PozwalajÄ… na wizualizacjÄ™ rÃ³wnolegÅ‚ych Å›cieÅ¼ek wykonania.
f) SÅ‚uÅ¼Ä… do projektowania baz danych NoSQL.


[#201] (#201) Diagramy wdroÅ¼enia (Deployment Diagrams) UML:
>>a) PrzedstawiajÄ… fizycznÄ… architekturÄ™ systemu, w tym wÄ™zÅ‚y sprzÄ™towe i artefakty.
b) PokazujÄ… interfejsy uÅ¼ytkownika i ich interakcje.
c) sÅ‚uÅ¼Ä… do projektowania algorytmÃ³w sortowania.
d) modelujÄ… relacje miÄ™dzy tabelami w bazie danych.
>>e) WÄ™zÅ‚y mogÄ… reprezentowaÄ‡ serwery, stacje robocze lub urzÄ…dzenia wbudowane.
f) SÅ‚uÅ¼Ä… do modelowania logiki biznesowej.


[#202] (#202) Komunikaty na diagramach sekwencji:
>>a) ReprezentujÄ… wywoÅ‚ania metod lub przesyÅ‚anie sygnaÅ‚Ã³w miÄ™dzy obiektami.
b) KomunikatÃ³w na diagramach reprezentujÄ… komunikaty poziome i pionowe.
c) zawsze muszÄ… byÄ‡ synchroniczne.
d) sÄ… rysowane jako linie pionowe.
>>e) Komunikat zwrotny (reply) jest zazwyczaj rysowany liniÄ… przerywanÄ….
f) Nie mogÄ… posiadaÄ‡ argumentÃ³w.


[#203] (#203) ZagnieÅ¼dÅ¼one stany w diagramach stanÃ³w UML:
>>a) PozwalajÄ… na hierarchicznÄ… strukturÄ™ stanÃ³w, gdzie stan zÅ‚oÅ¼ony zawiera w sobie podstany.
b) ZagnieÅ¼dÅ¼one stany umoÅ¼liwiajÄ… definiowanie jednorazowych dziaÅ‚aÅ„.
c) sÅ‚uÅ¼Ä… do modelowania pÄ™tli w programie.
d) sÄ… zabronione w standardzie UML 2.0.
>>e) PozwalajÄ… na wspÃ³Å‚dzielenie przejÅ›Ä‡ przez wszystkie podstany.
f) SÅ‚uÅ¼Ä… do modelowania dziedziczenia klas.


[#204] (#204) W odniesieniu i kontekÅ›cie jÄ™zyka UML (Unified Modeling Language) moÅ¼na powiedzieÄ‡, Å¼e
>>a) To proces generowania kodu ÅºrÃ³dÅ‚owego na podstawie modeli (diagramÃ³w).
b) Forward engineering to technika uÅ¼ywana do optymalizacji kodu ÅºrÃ³dÅ‚owego.
c) polega na tworzeniu dokumentacji z kodu.
d) dotyczy tylko testowania oprogramowania.
e) Jest procesem rÄ™cznego przepisywania diagramÃ³w na jÄ™zyk naturalny.
f) SÅ‚uÅ¼y do usuwania bÅ‚Ä™dÃ³w z bazy danych.


[#205] (#205) W odniesieniu i kontekÅ›cie jÄ™zyka UMLUML (Unified Modeling Language) moÅ¼na powiedzieÄ‡, Å¼e
>>a) To proces tworzenia modeli (diagramÃ³w) na podstawie analizy istniejÄ…cego kodu ÅºrÃ³dÅ‚owego.
b) Backward engineering polega na analizie istniejÄ…cego systemu i tworzeniu diagramÃ³w UML.
c) sÅ‚uÅ¼y do automatycznego naprawiania bÅ‚Ä™dÃ³w w kodzie.
d) jest niemoÅ¼liwy dla jÄ™zykÃ³w obiektowych.
e) Pozwala na zrozumienie architektury starego systemu (legacy code).
f) SÅ‚uÅ¼y do szyfrowania kodu ÅºrÃ³dÅ‚owego.


[#206] (#206) Po wykonaniu fragmentu kodu napisanego w jÄ™zyku C:
int a,b=1;
a=b++ + b;
>>a) Wynik jest niezdefiniowany (undefined behavior).
b) operator + nie ma w standardzie C okreÅ›lonej kolejnoÅ›ci obliczenia operandÃ³w.
c) a zawsze wyniesie 3.
d) a zawsze wyniesie 2.
e) Wynik zaleÅ¼y od wersji kompilatora i poziomu optymalizacji.
f) Kod ten nie skompiluje siÄ™ w standardzie C11.


[#207] (#207) Typ double w jÄ™zyku C:
>>a) SÅ‚uÅ¼y do przechowywania liczb zmiennoprzecinkowych podwÃ³jnej precyzji.
b) w zmiennej tego typu moÅ¼emy zapisaÄ‡ miÄ™dzy innymi dowolnÄ… liczbÄ™, ktÃ³rÄ… moÅ¼na zapisaÄ‡ w typie char.
c) ma mniejszy zakres niÅ¼ typ float.
d) nie moÅ¼e przechowywaÄ‡ wartoÅ›ci ujemnych.
>>e) Typowo zajmuje 8 bajtÃ³w w pamiÄ™ci.
f) Jest typem caÅ‚kowitym o duÅ¼ej precyzji.


[#208] (#208) Przyjmijmy, Å¼e zmienne wskaÅºnikowe t oraz s sÄ… typu char, dodatkowo s wskazuje na niepusty Å‚aÅ„cuch tekstowy, a t na adres pamiÄ™ci
rozpoczynajÄ…cy obszar przydzielony naszemu procesowi. Po wykonaniu fragmentu kodu napisanego w jÄ™zyku C:
while(*t++=*s++);
>>a) Kopiuje Å‚aÅ„cuch znakÃ³w z s do t, wÅ‚Ä…cznie ze znakiem koÅ„cowym '\0'.
b) wskaÅºniki s oraz t zwiÄ™kszÄ… swojÄ… wartoÅ›Ä‡ o tyle bajtÃ³w ile znakÃ³w znajduje siÄ™ w Å‚aÅ„cuchu.
c) pÄ™tla bÄ™dzie trwaÄ‡ w nieskoÅ„czonoÅ›Ä‡.
d) kopiuje tylko pierwszy znak.
>>e) Jest to idiomatyczny sposÃ³b kopiowania stringÃ³w w C.
f) Wymaga, aby t byÅ‚o wiÄ™ksze od s.


[#209] (#209) Po wykonaniu fragmentu kodu oznaczajÄ…cego deklaracjÄ™ w jÄ™zyku C:
int tab[10], *ws=tab;
>>a) ws wskazuje na pierwszy element tablicy (tab[0]).
b) nazwa tablicy tab jest wskaÅºnikiem na pierwszy element tablicy.
c) ws przechowuje kopiÄ™ caÅ‚ej tablicy.
d) tab i ws to dwa rÃ³Å¼ne typy, ktÃ³rych nie moÅ¼na przypisaÄ‡.
>>e) WyraÅ¼enie *(ws + 1) jest rÃ³wnowaÅ¼ne tab[1].
f) Rozmiar tablicy tab moÅ¼na zmieniÄ‡ za pomocÄ… realloc.


[#210] (#210) Fragmentu kodu w jÄ™zyku C:
double (*fun1)(double, double);
>>a) fun1 jest wskaÅºnikiem do funkcji przyjmujÄ…cej dwa parametry typu double i zwracajÄ…cej double.
b) ogÃ³lnie nazwa funkcji jest jednoczeÅ›nie wskaÅºnikiem do funkcji.
c) jest to wywoÅ‚anie funkcji o nazwie fun1.
d) deklaruje tablicÄ™ wskaÅºnikÃ³w.
e) fun1 jest funkcjÄ… zwracajÄ…cÄ… wskaÅºnik do double.
f) Deklaracja ta jest bÅ‚Ä™dna bez sÅ‚owa kluczowego typedef.


[#211] (#211) Fragmentu kodu w jÄ™zyku C:
int fib(int n){
 if(n<3) return n;
    return fib(n-1) + fib(n-2);
}
>>a) Jest nieefektywna (zÅ‚oÅ¼onoÅ›Ä‡ wykÅ‚adnicza) i przy kaÅ¼dym wywoÅ‚aniu tworzy nowÄ… ramkÄ™ stosu.
b) przy kaÅ¼dym rekurencyjnym wywoÅ‚aniu funkcji tworzona jest kopia argumentu n.
c) zawsze zwraca wynik w czasie O(n).
d) nie moÅ¼e byÄ‡ zaimplementowana w C.
>>e) MoÅ¼e prowadziÄ‡ do przepeÅ‚nienia stosu (stack overflow) dla duÅ¼ych n.
f) Jest przykÅ‚adem programowania dynamicznego.


[#212] (#212) Algorytm minimax:
>>a) SÅ‚uÅ¼y do wyboru optymalnego ruchu w grach dwuosobowych o sumie zerowej.
b) nawet w tak prostej grze jak kÃ³Å‚ko i krzyÅ¼yk nie da siÄ™ przejrzeÄ‡ caÅ‚ego drzewa ruchÃ³w.
c) jest algorytmem losowym.
d) nie wymaga funkcji oceny stanu gry.
>>e) MoÅ¼e byÄ‡ zoptymalizowany za pomocÄ… odciÄ™Ä‡ alfa-beta (alpha-beta pruning).
f) Jest stosowany wyÅ‚Ä…cznie w grach karcianych.


[#213] (#213) Wyszukiwanie w posortowanej tablicy n elementÃ³w:
>>a) MoÅ¼na zastosowaÄ‡ wyszukiwanie binarne o zÅ‚oÅ¼onoÅ›ci O(log n).
b) w celu wyszukania elementu o zadanej wartoÅ›ci musimy wykonaÄ‡ dokÅ‚adnie n krokÃ³w.
c) zawsze wymaga O(n^2) operacji.
d) nie jest moÅ¼liwe bez dodatkowego indeksu.
e) Wyszukiwanie liniowe jest zawsze szybsze dla n < 1000.
f) Wymaga, aby tablica byÅ‚a posortowana malejÄ…co.


[#214] (#214) Wyszukiwanie w posortowanej liÅ›cie jednokierunkowej n elementÃ³w:
>>a) Wymaga przejÅ›cia sekwencyjnego, co daje zÅ‚oÅ¼onoÅ›Ä‡ pesymistycznÄ… O(n).
b) wyszukanie elementu o zadanej wartoÅ›ci ma logarytmicznÄ… zÅ‚oÅ¼onoÅ›Ä‡ czasowÄ….
c) jest szybsze niÅ¼ w tablicy.
d) pozwala na dostÄ™p swobodny do elementÃ³w.
e) MoÅ¼na zastosowaÄ‡ wyszukiwanie binarne w czasie O(log n).
f) Wymaga staÅ‚ej iloÅ›ci pamiÄ™ci dodatkowej.


[#215] (#215) Gdy mamy strukturÄ™ dynamicznÄ… danych typu lista jednokierunkowa, to:
>>a) Pozwala na wstawienie elementu w dowolnym miejscu, jeÅ›li mamy wskaÅºnik do elementu poprzedzajÄ…cego.
b) nie moÅ¼na wstawiÄ‡ nowego elementu w dowolnym miejscu w liÅ›cie.
c) nie posiada wskaÅºnika na nastÄ™pny element.
d) jest strukturÄ… o staÅ‚ym rozmiarze.
>>e) KaÅ¼dy wÄ™zeÅ‚ przechowuje dane oraz wskaÅºnik na kolejny element.
f) Pozwala na szybkie (O(1)) pobranie poprzedniego elementu.


[#216] (#216) Struktura typu drzewo:
>>a) Aby odwiedziÄ‡ wszystkie n wÄ™zÅ‚Ã³w, naleÅ¼y zastosowaÄ‡ algorytm przejÅ›cia o zÅ‚oÅ¼onoÅ›ci O(n).
b) w celu wypisania wszystkich elementÃ³w drzewa musimy przejÅ›Ä‡ przez wszystkie elementy drzewa.
c) kaÅ¼dy wÄ™zeÅ‚ moÅ¼e mieÄ‡ tylko jednego potomka.
d) nie moÅ¼e byÄ‡ pusta.
>>e) Drzewo binarne to drzewo, w ktÃ³rym kaÅ¼dy wÄ™zeÅ‚ ma co najwyÅ¼ej dwÃ³ch potomkÃ³w.
f) Drzewo jest grafem spÃ³jnym zawierajÄ…cym cykle.


[#217] (#217) Gdy mamy strukturÄ™ dynamicznÄ… typu drzewo wyszukiwaÅ„ binarnych (BST), gdzie jest to drzewo speÅ‚niajÄ…ce wÅ‚asnoÅ›Ä‡, Å¼e dla kaÅ¼dego wÄ™zÅ‚a
zawierajÄ…cego wartoÅ›Ä‡ x majÄ…cego lewego potomka zawierajÄ…cego wartoÅ›Ä‡ l oraz prawego zawierajÄ…cego wartoÅ›Ä‡ p, zachodzi: l<=x oraz x<=p, to:
>>a) Åšrednia zÅ‚oÅ¼onoÅ›Ä‡ wyszukiwania wynosi O(log n), ale pesymistyczna to O(n).
b) w dowolnym drzewie tego typu znalezienie wÄ™zÅ‚a ma logarytmicznÄ… zÅ‚oÅ¼onoÅ›Ä‡ czasowÄ….
c) zawsze jest zrÃ³wnowaÅ¼one.
d) nie pozwala na przechowywanie duplikatÃ³w.
>>e) Dla kaÅ¼dego wÄ™zÅ‚a, wartoÅ›ci w lewym poddrzewie sÄ… mniejsze, a w prawym wiÄ™ksze od wartoÅ›ci wÄ™zÅ‚a.
f) BST jest zawsze drzewem peÅ‚nym.


[#218] (#218) Przeanalizuj fragmenty kodu w jÄ™zyku C++, w ktÃ³rym pojawiajÄ… siÄ™ zmienne, wskaÅºniki i referencje.
KtÃ³re z nich majÄ… poprawnÄ… skÅ‚adniÄ™?
>>a) int x; int &r = x; (referencja musi byÄ‡ zainicjalizowana i nie moÅ¼e byÄ‡ null).
b) int x; int&r=null; r=x;
c) int &r; r = 10;
d) int &r = null;
e) Referencja moÅ¼e zostaÄ‡ przeÅ‚Ä…czona na inny obiekt w trakcie dziaÅ‚ania programu.
f) Referencja zajmuje tyle samo pamiÄ™ci co wskaÅºnik.


[#219] (#219) KtÃ³re stwierdzenia odnoszÄ…ce siÄ™ ograniczeÅ„ narzucanych przez skÅ‚adniÄ™ jÄ™zyka C++ w odniesieniu do konstruktorÃ³w i destruktorÃ³w sÄ…
prawdziwe?
>>a) Klasa moÅ¼e mieÄ‡ wiele konstruktorÃ³w, ale tylko jeden destruktor.
b) W klasie moÅ¼na zdefiniowaÄ‡ dowolnÄ… liczbÄ™ konstruktorÃ³w i co najwyÅ¼ej jeden destruktor.
c) Destruktor moÅ¼e zwracaÄ‡ wartoÅ›Ä‡ int.
d) Konstruktor musi byÄ‡ zawsze publiczny.
>>e) Destruktor jest wywoÅ‚ywany automatycznie, gdy obiekt wychodzi poza zakres.
f) Konstruktor kopiujÄ…cy nie moÅ¼e byÄ‡ prywatny.


[#220] (#220) KtÃ³re stwierdzenia odnoszÄ…ce siÄ™ do metod klas w jÄ™zyku C++ sÄ… prawdziwe?
>>a) Metody statyczne nie posiadajÄ… wskaÅºnika this.
b) WskaÅºnik this nie jest dostÄ™pny w metodach statycznych.
c) Metody wirtualne nie mogÄ… byÄ‡ prywatne.
d) KaÅ¼da metoda musi byÄ‡ wirtualna.
>>e) Metody staÅ‚e (const) nie mogÄ… modyfikowaÄ‡ pÃ³l klasy (poza polami mutable).
f) Metody statyczne mogÄ… wywoÅ‚ywaÄ‡ metody niestatyczne bez obiektu.


[#221] (#221) Zadeklarowano dwie klasy jÄ™zyka C++
class A{
    int value;
public:
       A(int _v):value(_v){}
       int getValue(){return value;}
       const char*getName(){return "AAA";}
};

oraz

class B:public A {
public:
// konstruktor

       const char*getName(){return "B";}
};

Utworzono obiekt klasy B za pomocÄ… nastÄ™pujÄ…cej instrukcji:
A*pa=new B();

KtÃ³ra implementacja konstruktora klasy B jest poprawna?
>>a) Konstruktor klasy pochodnej musi wywoÅ‚aÄ‡ konstruktor klasy bazowej w liÅ›cie inicjalizacyjnej.
b) B::B(){super(0);}
c) B::B(){A(0);}
d) B::B(){this->A(0);}
>>e) JeÅ›li klasa bazowa nie ma konstruktora domyÅ›lnego, jawne wywoÅ‚anie jest wymagane.
f) Klasa B automatycznie dziedziczy wszystkie pola prywatne klasy A jako publiczne.


[#222] (#222) Zadeklarowano cztery klasy jÄ™zyka C++
class A{
public:
    A(){std::cout<<"A";}
};

class B{
public:
     B(){std::cout<<"B";}
};

class C{
    A a;
public:
     C(){std::cout<<"C";}
};

class D : public C{
public:
    B b;
     D(){std::cout<<"D";}
};

Jaka jest kolejnoÅ›Ä‡ wywoÅ‚ania konstruktorÃ³w przy tworzeniu obiektu klasy D?
>>a) Najpierw baza (C), potem pola (B), potem ciaÅ‚o konstruktora (D). WewnÄ…trz C: pole (A), potem ciaÅ‚o (C). Zatem: A, C, B, D.
b) Konstruktor B zostanie wywoÅ‚any przed konstruktorem klasy C.
c) B, A, C, D.
d) D, B, C, A.
e) KolejnoÅ›Ä‡ zaleÅ¼y od kolejnoÅ›ci deklaracji w pliku nagÅ‚Ã³wkowym.
f) Wszystkie konstruktory are wywoÅ‚ywane rÃ³wnolegle.


[#223] (#223) Zadeklarowano trzy klasy jÄ™zyka C++.
class A {
public:
     virtual ~A(){f();}
     virtual void f(){std::cout<<"A";}
};

class B:public A {
public:
     ~B(){f();}
};

class C:public B {
public:
     ~C(){f();}
     void f(){std::cout<<"C";}
};

Zaimplementowano nastÄ™pujÄ…cÄ… funkcjÄ™ main()
int main(){
     A* ptr = new C();
     delete ptr;
     return 0;
}

Przy usuwaniu obiektu woÅ‚any jest jego destruktor. KtÃ³re stwierdzenia dotyczÄ…ce uruchamianych destruktorÃ³w sÄ… prawdziwe?
>>a) JeÅ›li klasa bazowa ma wirtualny destruktor, destruktory wywoÅ‚ajÄ… siÄ™ od najbardziej pochodnej do bazy.
b) Wpierw zostanie uruchomiony destruktor A, potem B, potem C.
c) WywoÅ‚a siÄ™ tylko destruktor klasy A.
d) Destruktory wywoÅ‚ujÄ… siÄ™ w kolejnoÅ›ci alfabetycznej.
>>e) Brak wirtualnego destruktora w klasie bazowej przy usuwaniu przez wskaÅºnik na bazÄ™ prowadzi do UB.
f) Destruktor wirtualny jest wymagany tylko w klasach abstrakcyjnych.


[#224] (#224) KtÃ³re stwierdzenia odnoszÄ…ce siÄ™ do przeciÄ…Å¼ania operatorÃ³w w jÄ™zyku C++ sÄ… prawdziwe:
>>a) NiektÃ³re operatory (np. <<, >>) sÄ… zazwyczaj przeciÄ…Å¼ane jako funkcje zaprzyjaÅºnione (friend).
b) Wszystkie operatory muszÄ… byÄ‡ zaimplementowane jako metody klasy.
c) Nie moÅ¼na przeciÄ…Å¼aÄ‡ operatora +.
d) Operatory logiczne nie podlegajÄ… przeciÄ…Å¼aniu.
>>e) Operatory takie jak =, [], (), -> muszÄ… byÄ‡ zaimplementowane jako metody klasy.
f) MoÅ¼na tworzyÄ‡ nowe operatory, np. **.


[#225] (#225) Wybierz poprawne stwierdzenia odnoszÄ…ce siÄ™ do obiektÃ³w funkcyjnych w jÄ™zyku C++
>>a) To obiekty klas, ktÃ³re majÄ… przeciÄ…Å¼ony operator nawiasÃ³w operator().
b) Obiekty funkcyjne to obiekty klasy, ktÃ³ra implementuje operator wywoÅ‚ania funkcji.
c) SÄ… to wskaÅºniki do funkcji statycznych.
d) MoÅ¼na je tworzyÄ‡ tylko za pomocÄ… sÅ‚owa kluczowego function.
>>e) Funktory mogÄ… przechowywaÄ‡ stan miÄ™dzy wywoÅ‚aniami.
f) SÄ… wolniejsze od zwykÅ‚ych wskaÅºnikÃ³w do funkcji.


[#226] (#226) KtÃ³re stwierdzenia odnoszÄ…ce siÄ™ do mechanizmu wyjÄ…tkÃ³w w jÄ™zyku C++ sÄ… prawdziwe?
>>a) Podczas "odwijania stosu" niszczone sÄ… obiekty lokalne poprzez wywoÅ‚anie ich destruktorÃ³w.
b) Podczas obsÅ‚ugi wyjÄ…tkÃ³w zwalniana jest pamiÄ™Ä‡ stosu oraz woÅ‚ane sÄ… destruktory obiektÃ³w.
c) WyjÄ…tki nie mogÄ… byÄ‡ rzucane w konstruktorach.
d) KaÅ¼dy wyjÄ…tek musi dziedziczyÄ‡ po klasie std::exception.
>>e) Rzucenie wyjÄ…tku w destruktorze podczas odwijania stosu powoduje wywoÅ‚anie std::terminate.
f) Blok catch(...) Å‚apie tylko wyjÄ…tki typu int.


[#227] (#227) Wybierz poprawne stwierdzenia odnoszÄ…ce siÄ™ do kontenerÃ³w jÄ™zyka C++
>>a) std::list to lista dwukierunkowa, zapewnia staÅ‚y czas O(1) wstawiania na obu koÅ„cach.
b) Szablon std::list umoÅ¼liwia dodawanie elementÃ³w na poczÄ…tku i koÅ„cu listy.
c) std::vector zapewnia staÅ‚y czas wstawiania w dowolnym miejscu.
d) std::map przechowuje elementy w sposÃ³b nieposortowany.
>>e) std::vector zapewnia staÅ‚y czas dostÄ™pu O(1) do dowolnego elementu.
f) std::deque nie pozwala na wstawianie na poczÄ…tku.


[#228] (#228) ZaÅ‚Ã³Å¼my, Å¼e A jest klasÄ… jÄ™zyka C++. Jakie warunki muszÄ… byÄ‡ speÅ‚nione, aby mÃ³c przechowywaÄ‡ obiekty tej klasy w kontenerze std::set lub
uÅ¼ywaÄ‡ ich jako klucze w std::map?
>>a) WymagajÄ…, aby klucze posiadaÅ‚y zdefiniowanÄ… relacjÄ™ Å›cisÅ‚ego sÅ‚abego porzÄ…dku.
b) muszÄ… byÄ‡ zdefiniowane operatory boolowskie < , == oraz >.
c) klucze muszÄ… byÄ‡ typu caÅ‚kowitego.
d) obiekty muszÄ… dziedziczyÄ‡ po klasie Comparable.
>>e) SÄ… zazwyczaj implementowane jako drzewa czerwono-czarne.
f) ZapewniajÄ… Å›redni czas wyszukiwania O(1).


[#229] (#229) KtÃ³re stwierdzenia odnoszÄ…ce siÄ™ do iteratorÃ³w w C++ sÄ… prawdziwe
>>a) std::vector i std::deque posiadajÄ… iteratory swobodnego dostÄ™pu, a std::list tylko dwukierunkowe.
b) Iterator kontenera std::list umoÅ¼liwia dostÄ™p swobodny.
c) Iteratory nie mogÄ… byÄ‡ porÃ³wnywane.
d) KaÅ¼dy iterator moÅ¼na przesunÄ…Ä‡ o n pozycji w czasie O(1).
>>e) Iteratory kontenerÃ³w asocjacyjnych (np. std::set) nie sÄ… iteratorami swobodnego dostÄ™pu.
f) Iterator end() wskazuje na ostatni element kontenera.


[#230] (#230) KtÃ³re stwierdzenia odnoszÄ…ce siÄ™ do wyraÅ¼eÅ„ lambda w jÄ™zyku C++ sÄ… prawdziwe
>>a) KaÅ¼de wyraÅ¼enie lambda ma unikalny, nienazwany typ generowany przez kompilator.
b) Wynikiem kompilacji identycznych wyraÅ¼eÅ„ lambda jest jeden wspÃ³Å‚dzielony obiekt funkcyjny.
c) Lambdy nie mogÄ… przechwytywaÄ‡ zmiennych przez referencjÄ™.
d) Lambdy sÄ… dostÄ™pne od standardu C++98.
>>e) SkÅ‚adnia [=] oznacza przechwycenie wszystkich zmiennych lokalnych przez kopiÄ™.
f) Lambdy nie mogÄ… byÄ‡ uÅ¼ywane jako argumenty funkcji STL.


[#231] (#231) Znaczniki semantyczne w HTML5:
>>a) <article>, <section>, <nav>, <header>, <footer>.
b) div
c) span
d) table
e) <main>, <aside>, <figure>.
f) <font>, <center>, <bold>.


[#232] (#232) Jakich znacznikÃ³w HTML5 uÅ¼yjesz do wyÅ›wietlenia zawartoÅ›ci pliku video?
>>a) <video>
b) file
c) media
d) object
e) <embed>
f) <source> (uÅ¼ywany wewnÄ…trz <video>).


[#233] (#233) KtÃ³ry element moÅ¼e byÄ‡ uÅ¼yty w HTML5 do specyfikacji linku nawigacyjnego?
>>a) <nav> (kontener dla linkÃ³w) oraz <a> (sam link).
b) navigation
c) link
d) anchor
e) <menu>
f) <href>


[#234] (#234) Atrybut for w znaczniku <label>:
>>a) SÅ‚uÅ¼y do powiÄ…zania etykiety z konkretnym elementem formularza (poprzez jego id).
b) aby etykieta byÅ‚a aktywna.
c) okreÅ›la czas wyÅ›wietlania etykiety.
d) sÅ‚uÅ¼y do stylowania w CSS.
e) pozwala na klikniÄ™cie w etykietÄ™ w celu aktywacji pola.
f) jest wymagany dla kaÅ¼dego znacznika <p>.


[#235] (#235) Aplikacje Single Page Application (SPA):
>>a) CaÅ‚a logika i renderowanie widokÃ³w odbywa siÄ™ gÅ‚Ã³wnie po stronie klienta.
b) zarzÄ…dzanie stanem aplikacji realizowane jest po stronie frontendu.
c) wymagajÄ… przeÅ‚adowania caÅ‚ej strony przy kaÅ¼dej nawigacji.
d) nie mogÄ… korzystaÄ‡ z API.
>>e) PrzykÅ‚adowe frameworki to React, Angular, Vue.
f) SÄ… zawsze indeksowane przez wyszukiwarki lepiej niÅ¼ strony statyczne.


[#236] (#236) Jakich operacji HTTP moÅ¼esz uÅ¼yÄ‡ do aktualizacji czÄ™Å›ci danych istniejÄ…cego juÅ¼ uÅ¼ytkownika?
>>a) PATCH (czÄ™Å›ciowa aktualizacja), PUT (peÅ‚na zamiana).
b) PATCH
c) POST
d) UPDATE
e) DELETE
f) OPTIONS


[#237] (#237) KtÃ³ry z poniÅ¼szych adresÃ³w API ( wedÅ‚ug konwencji REST API) powinien byÄ‡ uÅ¼yty do zwrÃ³cenia informacji o wszystkich samochodach
uÅ¼ytkownika posiadajÄ…cego id rÃ³wne 4?
>>a) /users/4/cars
b) /users?id=4/cars/all
c) /get_all_cars_for_user_4
d) /cars/user/4
e) /users/4/actions/get-cars
f) /api/v1/users/4/cars


[#238] (#238) Poprawny format JSON:
>>a) { "user": "Jan Kowalski", "age": 100 }
b) { "user" : Jan Kowalski, "age": 100 }
c) { user: "Jan Kowalski", age: 100 }
d) [ "user": "Jan Kowalski" ]
e) { 'user': 'Jan Kowalski' }
f) { "user": "Jan", "data": [1, 2, 3] }


[#239] (#239) ResponsywnoÅ›Ä‡ (Responsive Web Design):
>>a) Technika projektowania stron tak, aby ich wyglÄ…d dostosowywaÅ‚ siÄ™ do rozmiaru ekranu.
b) zapewnia dostosowanie wyglÄ…du aplikacji w kontekÅ›cie potrzeb uÅ¼ytkownika.
c) oznacza szybkie reagowanie serwera na zapytania.
d) dotyczy tylko aplikacji mobilnych.
>>e) Wykorzystuje elastyczne siatki (grid), elastyczne obrazy oraz Media Queries.
f) Wymaga tworzenia oddzielnej strony pod adresem m.domena.pl.


[#240] (#240) Nowoczesne frameworki JavaScript (JavaScript frameworks) takie jak Angular, React czy Vue
>>a) WykorzystujÄ… komponentowe podejÅ›cie do budowy interfejsu.
b) wykorzystujÄ… wiÄ…zania dwukierunkowe do synchronizacji.
c) sÅ‚uÅ¼Ä… wyÅ‚Ä…cznie do stylowania stron.
d) nie pozwalajÄ… na uÅ¼ywanie zewnÄ™trznych bibliotek.
>>e) PozwalajÄ… na deklaratywne definiowanie interfejsu uÅ¼ytkownika.
f) Wymaga znajomoÅ›ci jÄ™zyka Java.


[#241] (#241) Node.js:
>>a) Jest Å›rodowiskiem uruchomieniowym JavaScript opartym na silniku V8.
b) implementuje tylko operacje asynchroniczne.
c) jest frameworkiem CSS.
d) sÅ‚uÅ¼y do tworzenia wyÅ‚Ä…cznie aplikacji desktopowych.
>>e) Wykorzystuje model Event Loop do obsÅ‚ugi wielu poÅ‚Ä…czeÅ„ jednoczeÅ›nie.
f) Jest jÄ™zykiem programowania kompilowanym do kodu maszynowego.


[#242] (#242) Zapisano nastÄ™pujÄ…cy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
Class C {
public static void main(String[] args) {
int[]a1[]=new int[3][3]; //3
int a2[4]={3,4,5,6}; //4

int a2[5]; //5
}}
Jaki jest wynik kompilacji i wykonania programu (w komentarzach podane sÄ… numery linii)?
>>a) int[] a = new int[5]; (poprawna deklaracja).
b) BÅ‚Ä…d kompilacji w liniach 3,4,5.
c) Wszystkie linie sÄ… poprawne.
d) Tablice w Javie majÄ… dynamiczny rozmiar.
>>e) Rozmiar tablicy jest ustalany w momencie tworzenia (new) i nie moÅ¼e byÄ‡ zmieniony.
f) tablica.length() zwraca liczbÄ™ elementÃ³w.


[#243] (#243) Zapisano nastÄ™pujÄ…cy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
public class A extends Thread {

public int i;
public void run() { i = 1; }
public static void main(String[] args) throws Exception {
A a = new A();
>>a) Aby uruchomiÄ‡ wÄ…tek, naleÅ¼y wywoÅ‚aÄ‡ metodÄ™ start(), ktÃ³ra wywoÅ‚a run().
b) start(); System.out.print(a.i); Thread.sleep(1000); System.out.print(a.i);
c) Nie wypisze nic.
d) Wypisze "11".
>>e) MoÅ¼na implementowaÄ‡ interfejs Runnable lub dziedziczyÄ‡ po klasie Thread.
f) Metoda run() uruchamia nowy wÄ…tek w systemie operacyjnym.


[#244] (#244) Zapisano nastÄ™pujÄ…cy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
class C{
public static void main(String[] args) {
 try {
     try {
       try {}
       catch(RuntimeException e){}
     }
     catch(Exception e) {}
 }
 catch(NullPointerException e) {}
 finally {
   System.out.println("finally");
}
}}
Jaki jest rezultat kompilacji i wykonania programu?
>>a) Blok finally wykonuje siÄ™ zawsze, niezaleÅ¼nie od tego, czy wystÄ…piÅ‚ wyjÄ…tek.
b) Runtime Exception
c) Wypisze "finally".
d) BÅ‚Ä…d kompilacji.
>>e) Blok finally jest czÄ™sto uÅ¼ywany do zwalniania zasobÃ³w.
f) Blok catch musi zawsze wystÄ™powaÄ‡ po bloku finally.


[#245] (#245) Zapisano nastÄ™pujÄ…cy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
public class C {
        public static void main ( String a[]) {
            Thread t = Thread.currentThread ( ) ;
                t.setPriority(-1);
                System.out.println("Done!");
        }
}

Jaki bÄ™dzie rezultat kompilacji i wykonania programu?
>>a) Priorytet musi mieÅ›ciÄ‡ siÄ™ w zakresie od Thread.MIN_PRIORITY (1) do Thread.MAX_PRIORITY (10).
b) Runtime Exception
c) Done!
d) BÅ‚Ä…d kompilacji.
e) WartoÅ›Ä‡ priorytetu 0 jest dozwolona.
f) WyÅ¼szy priorytet gwarantuje, Å¼e wÄ…tek zakoÅ„czy siÄ™ szybciej.


[#246] (#246) Zapisano nastÄ™pujÄ…cy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
interface I{
void f1(); // 1

public void f2(); // 2
protected void f3(); // 3
private void f4(); // 4

}
KtÃ³re linie generujÄ… bÅ‚Ä™dy kompilacji? (w komentarzach podany numery linii)
>>a) W klasycznych interfejsach metody sÄ… domyÅ›lnie public abstract.
b) BÅ‚Ä…d kompilacji w liniach 1,2,3,4.
c) Tylko linia 3 i 4 generujÄ… bÅ‚Ä™dy.
d) Interfejsy nie mogÄ… mieÄ‡ metod.
>>e) Od Javy 8 interfejsy mogÄ… posiadaÄ‡ metody domyÅ›lne (default) i statyczne.
f) Metody w interfejsach mogÄ… byÄ‡ final.


[#247] (#247) Zapisano nastÄ™pujÄ…cy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
class C {
static int s;
public static void main(String a[]){

    C obj=new C();
    obj.m1();
    System.out.println(s);
}

void m1() {
    int x=1;
    m2(x);

    System.out.println(x+"");
}
void m2(int x){
    x=x*2;

    s=x;
}
}

Jaki jest rezultat kompilacji i wykonania programu?
>>a) Java zawsze przekazuje argumenty przez wartoÅ›Ä‡.
b) Wypisze: "2,0"
c) Wypisze: "1 2".
d) Wypisze: "2 2".
>>e) Dla obiektÃ³w przekazywana jest wartoÅ›Ä‡ referencji (kopia wskaÅºnika).
f) SÅ‚owo kluczowe 'ref' pozwala na przekazywanie przez referencjÄ™.


[#248] (#248) Zapisano nastÄ™pujÄ…cy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
class C {

public static void main(String[] args) {
int i1=1;
switch(i1){

case 1:
System.out.println("one ");
case 2:
System.out.println("two ");

case 3:
System.out.println("three ");
}}}

Jaki jest rezultat kompilacji i wykonania programu?
>>a) Po dopasowaniu case, wykonajÄ… siÄ™ wszystkie kolejne instrukcje (fall-through).
b) Wypisze: "one "
c) Wypisze: "one two three "
d) Wypisze: "one " i zakoÅ„czy.
e) Switch obsÅ‚uguje tylko typy caÅ‚kowite (int, long).
f) Od Javy 7 switch obsÅ‚uguje typ String.


[#249] (#249) Zapisano nastÄ™pujÄ…cy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
class C1 {

static interface I {
static class C2 {}
}

public static void main(String a[]) {
C1.I.C2 ob1=new C1.I.C2();
System.out.println("obj created");
}

}
Jaki jest rezultat kompilacji i wykonania programu?
>>a) Interfejsy mogÄ… zawieraÄ‡ klasy statyczne.
b) BÅ‚Ä…d kompilacji
c) Wypisze: "obj created"
d) Interfejsy nie mogÄ… mieÄ‡ metod main.
e) Klasy wewnÄ™trzne nie mogÄ… byÄ‡ statyczne.
f) Klasa wewnÄ™trzna ma dostÄ™p do prywatnych pÃ³l klasy zewnÄ™trznej.


[#250] (#250) Zapisano nastÄ™pujÄ…cy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
class C1 {
static class C2 {

static int i1;
}
public static void main(String a[]) {
System.out.println(C1.C2.i1);

}
}
Jaki jest rezultat kompilacji i wykonania programu?
>>a) Pola statyczne sÄ… inicjalizowane wartoÅ›ciami domyÅ›lnymi (0 dla int).
b) Wypisze: "0"
c) BÅ‚Ä…d kompilacji.
d) Runtime Exception.
e) Klasa statyczna wymaga obiektu klasy zewnÄ™trznej do utworzenia instancji.
f) Klasa statyczna wewnÄ™trzna moÅ¼e dziedziczyÄ‡ po klasie zewnÄ™trznej.


[#251] (#251) Ile obiektÃ³w (instancji klasy StringBuffer) zostanie utworzonych w wyniku wykonania poniÅ¼szego kodu w jÄ™zyku Java:
StringBuffer s1 = new StringBuffer("abc");
StringBuffer s2 = s1;
StringBuffer s3 = new StringBuffer("abc");
>>a) 2 (s1 tworzy nowy obiekt, s3 tworzy drugi nowy obiekt).
b) 1
c) 3
d) 0
e) 4
f) StringBuffer nie jest klasÄ… w Javie.


[#252] (#252) KtÃ³ra z poniÅ¼szych metod jest statycznÄ… metodÄ… w klasie Thread dostÄ™pnej w standardowym API dla jÄ™zyka Java?
>>a) sleep, yield, currentThread, interrupted.
b) join
c) start
d) run
e) wait
f) notify


[#253] (#253) Zapisano poniÅ¼szy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
class c1 {
    public void m1() {
     System.out.println("m1 w klasie C1");
    }
}

class c2 {
 public c1 m1() {
     return new c1(){
       public void m1() {
         System.out.println("m1 w klasie anonimowej");
     }
}

}
public static void main(String a[]) {
 c1 ob1 =new c2().m1();
 ob1.m1();
}}

Jaki bÄ™dzie wynik kompilacji i wykonania tego kodu jako programu?
>>a) Klasa anonimowa nadpisuje metodÄ™, wiÄ™c zostanie wywoÅ‚ana wersja z klasy anonimowej.
b) Program wypisze Å‚aÅ„cuch: "m1 w klasie anonimowej"
c) Program wypisze: "m1 w klasie C1"
d) BÅ‚Ä…d kompilacji.
e) Klasy anonimowe nie mogÄ… implementowaÄ‡ interfejsÃ³w.
f) Klasa anonimowa moÅ¼e mieÄ‡ wÅ‚asny konstruktor.


[#254] (#254) Zapisano poniÅ¼szy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:class C{
int i;

public static void main (String[] args) {
int i; //1
private int a = 1; //2

protected int b = 1; //3
public int c = 1; //4
System.out.println(a+b+c); //5
}}

Jaki jest wynik prÃ³by kompilacji i wykonania powyÅ¼szego programu (w komentarzach zaznaczony numery lini)?
>>a) Zmienne lokalne nie mogÄ… mieÄ‡ modyfikatorÃ³w public, private, protected.
b) Wykonanie kodu spowoduje wyprowadzenie wyniku: "3"
c) BÅ‚Ä…d kompilacji w liniach 2, 3, 4.
d) Wypisze "1".
e) Zmienne lokalne mogÄ… byÄ‡ oznaczone jako final.
f) Zmienne lokalne sÄ… widoczne w caÅ‚ej klasie.


[#255] (#255) Zapisano poniÅ¼szy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
public class Command {

public static void main (String[] a1) {
System.out.print(a1[1] + a1[2] + a1[3]);
}}
Jaki jest wynik prÃ³by kompilacji i wykonania powyÅ¼szego programu przy pomocy poniÅ¼szego polecenia?
polecenie: java Command A B C
>>a) Indeksowanie zaczyna siÄ™ od 0.
b) Runtime Exception
c) ABC
d) BÅ‚Ä…d kompilacji.
e) args[0] zawsze przechowuje nazwÄ™ uruchomionego programu.
f) Tablica args moÅ¼e byÄ‡ pusta (length == 0).


[#256] (#256) Zapisano poniÅ¼szy kod ÅºrÃ³dÅ‚owy w jÄ™zyku Java:
class C{
static String m(int i) {return "int";}
static String m(float i) {return "float";}
public static void main (String[] args) {
long a1 = 1; double b1 = 2;
System.out.print(m(a1)+","+ m(b1));
}}
Jaki bÄ™dzie rezultat kompilacji i wykonania programu?
>>a) long moÅ¼e byÄ‡ niejawnie konwertowany na float, ale double nie pasuje do float bez rzutowania.
b) Kompilacja tego kodu zakoÅ„czy siÄ™ bÅ‚Ä™dem.
c) Wypisze: "int,float".
d) Wypisze: "float,float".
e) Java nie obsÅ‚uguje przeciÄ…Å¼ania metod.
f) Typ byte jest automatycznie promowany do char.


[#257] (#257) Wzorzec architektury Model-View-Controller (MVC) w technologii ASP .NET Core MVC obejmuje:
>>a) Modele (dane), Widoki (interfejs), Kontrolery (logika).
b) WarstwÄ™ modeli - warstwa definiujÄ…ca strukturÄ™ danych.
c) Kontrolery sÅ‚uÅ¼Ä… do stylowania stron.
d) Widoki odpowiadajÄ… za dostÄ™p do bazy danych.
>>e) Kontroler wybiera odpowiedni widok i przekazuje mu dane z modelu.
f) MVC jest wzorcem wyÅ‚Ä…cznie dla aplikacji desktopowych.


[#258] (#258) Aby przechowywaÄ‡ stan aplikacji webowej (dane ulotne, ktÃ³rych nie chcemy utrwalaÄ‡ w bazie danych) w ASP.NET CORE MVC moÅ¼na
uÅ¼yÄ‡:
>>a) Session, Cookies, TempData, QueryString.
b) Stanu sesji (HttpContext.Session)
c) Tylko w bazie danych SQL Server.
d) W plikach tekstowych na serwerze.
>>e) View State nie jest uÅ¼ywany w ASP.NET Core.
f) ProtokÃ³Å‚ HTTP jest stanowy z natury.


[#259] (#259) Przekazywanie przez referencjÄ™ w C#:
>>a) SÅ‚owa kluczowe ref oraz out pozwalajÄ… na przekazywanie typÃ³w wartoÅ›ciowych przez referencjÄ™.
b) PrzekazaÄ‡ do metody zmiennÄ… przez referencjÄ™ przy pomocy sÅ‚owa kluczowego ref.
c) C# nie obsÅ‚uguje referencji.
d) Wszystkie obiekty sÄ… zawsze przekazywane przez kopiÄ™.
>>e) 'out' wymaga, aby zmienna zostaÅ‚a zainicjalizowana wewnÄ…trz metody.
f) 'ref' nie wymaga inicjalizacji zmiennej przed przekazaniem.


[#260] (#260) Czy w jÄ™zyku C# moÅ¼na tworzyÄ‡ klasy zagnieÅ¼dÅ¼one (deklarowaÄ‡ klasÄ™ wewnÄ…trz deklaracji innej klasy)?
>>a) Klasy zagnieÅ¼dÅ¼one mogÄ… mieÄ‡ dowolny modyfikator dostÄ™pu.
b) MoÅ¼na deklarowaÄ‡, ale tylko klasy prywatne.
c) C# nie pozwala na klasy zagnieÅ¼dÅ¼one.
d) Klasy zagnieÅ¼dÅ¼one muszÄ… byÄ‡ statyczne.
e) Klasa zagnieÅ¼dÅ¼ona ma dostÄ™p do prywatnych pÃ³l klasy nadrzÄ™dnej.
f) Klasa nadrzÄ™dna ma dostÄ™p do prywatnych pÃ³l klasy zagnieÅ¼dÅ¼onej.


[#261] (#261) KtÃ³re z poniÅ¼szych konwersji typÃ³w (rzutowaÅ„ typÃ³w) w jÄ™zyku C# sÄ… dozwolone?
>>a) KaÅ¼da klasa dziedziczy po System.Object, wiÄ™c upcasting jest zawsze bezpieczny.
b) Rzutowanie referencji do obiektu dowolnej klasy na referencjÄ™ do klasy "Object"
c) MoÅ¼na rzutowaÄ‡ string na int bezpoÅ›rednio.
d) Rzutowanie w dÃ³Å‚ (downcasting) nigdy nie wymaga operatora rzutowania.
>>e) Operator 'as' zwraca null, jeÅ›li rzutowanie siÄ™ nie powiedzie.
f) Operator 'is' sÅ‚uÅ¼y do konwersji typÃ³w.


[#262] (#262) LINQ (Language Integrated Query):
>>a) SkÅ‚adnia zintegrowana z jÄ™zykiem pozwalajÄ…ca na operacje na kolekcjach.
b) Language INtegrated Query - zestaw konstrukcji programistycznych.
c) Biblioteka do obsÅ‚ugi grafiki 3D.
d) ProtokÃ³Å‚ komunikacji sieciowej.
>>e) Pozwala na zapytania do rÃ³Å¼nych ÅºrÃ³deÅ‚ danych.
f) Wymaga uÅ¼ycia sÅ‚owa kluczowego 'foreach' do kaÅ¼dego zapytania.


[#263] (#263) Deklaracja Polecenia najwyÅ¼szego poziomu (Top-level statements) w jÄ™zyku C# podlega pewnym zasadom. WÅ›rÃ³d nich sÄ…:
>>a) PozwalajÄ… na pisanie kodu bezpoÅ›rednio w pliku bez jawnej definicji klasy i Main.
b) dyrektywa "using" musi znajdã„ã‚‹ na poczÄ…tku pliku.
c) MoÅ¼na mieÄ‡ wiele plikÃ³w z Top-level statements w jednym projekcie.
d) Nie moÅ¼na w nich definiowaÄ‡ metod.
>>e) W projekcie moÅ¼e istnieÄ‡ tylko jeden plik z Top-level statements.
f) SÄ… dostÄ™pne od wersji C# 1.0.


[#264] (#264) Synchronizacja wÄ…tkÃ³w w C#:
>>a) lock, Monitor, Mutex, Semaphore, AutoResetEvent.
b) semaforÃ³w ("Semaphore")
c) tylko za pomocÄ… instrukcji if.
d) nie jest moÅ¼liwa w .NET Core.
>>e) Instrukcja lock jest cukrem skÅ‚adniowym dla Monitor.Enter i Monitor.Exit.
f) Mutex dziaÅ‚a tylko w obrÄ™bie jednego procesu.


[#265] (#265) Do definiowania wyraÅ¼eÅ„ lambda (lambda expression) w C# uÅ¼ywa siÄ™ operatora:
>>a) => (tzw. goes to).
b) ->
c) ::
d) lambda
e) :=
f) .


[#266] (#266) Zarejestrowanie zdarzenia (metody, ktÃ³ra bÄ™dzie wywoÅ‚ana w celu obsÅ‚ugi zdarzenia) w jÄ™zyku C# odbywa siÄ™ za pomocÄ… operatora:
>>a) UÅ¼ywa siÄ™ operatora += do dodania delegata.
b) +=
c) =
d) subscribe
e) add
f) register


[#267] (#267) Pula adresÃ³w IPv4 przewidziana dla grup IP Multicast (Klasa D adresÃ³w IPv4), to:
>>a) Zakres od 224.0.0.0 do 239.255.255.255.
b) 239.0.0.0 â€“ 255.255.255.255
c) 192.168.0.0 â€“ 192.168.255.255
d) 10.0.0.0 â€“ 10.255.255.255
e) 127.0.0.0 â€“ 127.255.255.255
f) 172.16.0.0 â€“ 172.31.255.255


[#268] (#268) PrzykÅ‚ady polskich nazw warstw w stosowanym w sieciach komputerowych modelu ISO OSI RM (ISO Open Systems Interconnection
Reference Model), to:
>>a) Fizyczna, ÅÄ…cza danych, Sieciowa, Transportowa, Sesji, Prezentacji, Aplikacji.
b) Warstwa sesji
c) Warstwa sprzÄ™towa
d) Warstwa internetowa
>>e) Warstwa 3 to warstwa sieciowa (np. protokÃ³Å‚ IP).
f) Model ISO/OSI ma 4 warstwy.


[#269] (#269) ProtokÃ³Å‚ automatycznie eliminujÄ…cy moÅ¼liwoÅ›Ä‡ zapÄ™tlenia transmisji ramki typu broadcast w sieci Ethernet (powstania tzw. broadcast storm),
to:
>>a) Blokuje redundantne Å›cieÅ¼ki w sieci Ethernet, tworzÄ…c strukturÄ™ drzewa bez pÄ™tli.
b) STP (Spanning Tree Protocol)
c) DHCP
d) BGP
e) SÅ‚uÅ¼y do automatycznej konfiguracji adresÃ³w IP.
f) DziaÅ‚a w warstwie 3 modelu OSI.


[#270] (#270) SieÄ‡ 210.210.210.192/26:
>>a) Zakres adresÃ³w uÅ¼ytkowych: 210.210.210.193 - 210.210.210.254.
b) 210.210.210.210
c) 210.210.210.190
d) 210.210.210.255
>>e) Adres rozgÅ‚oszeniowy to 210.210.210.255.
f) Maska podsieci to 255.255.255.0.


[#271] (#271) Jakiej techniki przesyÅ‚ania ruchu sieciowego poprzez ruter IP uÅ¼yjesz, gdy w sieciach IP organizacji, w ktÃ³rej pracujesz, zabrakÅ‚o adresÃ³w
IPv4 dla urzÄ…dzeÅ„, a dodatkowo urzÄ…dzenia te nie powinny byÄ‡ bezpoÅ›rednio dostÄ™pne i adresowalne z Internetu?
>>a) NAT (Network Address Translation).
b) RPF (Reverse Path Forwarding)
c) DNS
d) ICMP
e) ARP
f) OSPF


[#272] (#272) Tak zwana sÃ³l (ang. salt), czyli dane losowe dodawane do hasÅ‚a podczas obliczania funkcji skrÃ³tu przechowywanej w systemach
informatycznych, ma na celu:
>>a) Unikalny ciÄ…g znakÃ³w dodawany do hasÅ‚a przed haszowaniem.
b) utrudnienie sortowania haseÅ‚ przez uÅ¼ytkownikÃ³w.
c) skrÃ³cenie czasu obliczania funkcji skrÃ³tu.
d) umoÅ¼liwienie odzyskania hasÅ‚a w postaci jawnej.
>>e) Chroni przed atakami z uÅ¼yciem Rainbow Tables.
f) Jest przechowywana w bezpiecznym module sprzÄ™towym (HSM).


[#273] (#273) Standard definiujÄ…cy schemat dla certyfikatÃ³w sÅ‚uÅ¼Ä…cych do budowania struktury hierarchicznej infrastruktury klucza publicznego, stosowany
na przykÅ‚ad w zabezpieczonych technologiach webowych, to:
>>a) X.509
b) H.323
c) PKI-Standard
d) SSL-Cert
e) AES-256
f) RSA-4096


[#274] (#274) ProtokÃ³Å‚ UDP:
>>a) Jest bezpoÅ‚Ä…czeniowy, nie gwarantuje dostarczenia pakietÃ³w.
b) definiuje 16-to bitowÄ… adresacjÄ™ gniazd.
c) zapewnia retransmisjÄ™ zgubionych danych.
d) wymaga nawiÄ…zania poÅ‚Ä…czenia.
>>e) Ma mniejszy narzut nagÅ‚Ã³wka niÅ¼ TCP.
f) Jest stosowany w protokole HTTP/1.1.


[#275] (#275) Zapisana liczbowo wartoÅ›Ä‡ maski podsieci IPv4 dla adresu sieci: 5.5.5.0/30, to
>>a) 255.255.255.252
b) 255.255.255.0
c) 255.255.255.248
d) 255.255.255.192
e) 255.255.255.254
f) 255.255.255.128


[#276] (#276) Czy protokÃ³Å‚ TCP, stosowany w komunikacji w sieciach komputerowych, wymusza swoimi uwarunkowaniami technicznymi limit dÅ‚ugoÅ›ci
transmisji danych, przypadajÄ…cych na jedno poÅ‚Ä…czenie?
>>a) TCP traktuje dane jako strumieÅ„ bajtÃ³w bez narzuconego limitu caÅ‚kowitej dÅ‚ugoÅ›ci.
b) tak, jest to zawsze 4GB.
c) zaleÅ¼y od wersji systemu operacyjnego.
d) wynosi 64 KB na segment.
e) Wynosi 2^64 bajtÃ³w.
f) Jest ograniczony rozmiarem okna (window size).


[#277] (#277) DÅ‚ugoÅ›Ä‡ unikatowego adresu MAC (Media Access Control), stosowanego w interfejsach NIC (Network Interface Card) warstwy 2 ISO OSI
(na przykÅ‚ad w Ethernet), to:
>>a) 48 bitÃ³w (6 bajtÃ³w).
b) 32 bity
c) 64 bity
d) 128 bitÃ³w
e) 24 bity
f) 16 bitÃ³w


[#278] (#278) ÅšwiatÅ‚owÃ³d, w ktÃ³rym wiÄ…zka Å›wiatÅ‚a o danej (takiej samej) dÅ‚ugoÅ›ci fali moÅ¼e przemieszczaÄ‡ siÄ™ tylko jednÄ… drogÄ… i nie moÅ¼na przesÅ‚aÄ‡
kilku wiÄ…zek o takiej samej dÅ‚ugoÅ›ci fali przez ten Å›wiatÅ‚owÃ³d jednoczeÅ›nie, oznaczamy okreÅ›leniem:
>>a) Posiada bardzo cienki rdzeÅ„, co pozwala na przesyÅ‚anie tylko jednego modu Å›wiatÅ‚a.
b) jednomodowy
c) wielomodowy
d) gradientowy
>>e) Pozwala na transmisjÄ™ na znacznie wiÄ™ksze odlegÅ‚oÅ›ci niÅ¼ wielomodowy.
f) Jest taÅ„szy w instalacji niÅ¼ skrÄ™tka miedziana.


[#279] (#279) PrzykÅ‚ady wykorzystywanych obecnie szeregowych magistral cyfrowych, to:
>>a) SPI, I2C, UART, USB, CAN.
b) SPI, I2C
c) PCI Express
d) ATA
e) SCSI
f) ISA


[#280] (#280) PrzykÅ‚ady specyfikacji protokoÅ‚Ã³w komunikacyjnych dla sieci bezprzewodowych lub systemÃ³w komunikacji bezprzewodowej to:
>>a) Wi-Fi (802.11), Bluetooth, ZigBee, LoRaWAN, 5G.
b) LoRaWAN
c) Ethernet
d) RS-232
e) Token Ring
f) Frame Relay


[#281] (#281) Adres IPv6 w sieci 5::0/64:
>>a) 5::1, 5::abcd, itp.
b) 1::1
c) 5:0:0:0:0:0:0:1
d) ::5
e) 5::g123
f) 5::1:2:3:4:5


[#282] (#282) Algorytm wÄ™gierski:
>>a) SÅ‚uÅ¼y do rozwiÄ…zywania zagadnienia przydziaÅ‚u w czasie wielomianowym O(n^3).
b) Ma niewielomianowÄ… zÅ‚oÅ¼onoÅ›Ä‡ obliczeniowÄ….
c) Dotyczy tylko grafÃ³w niespÃ³jnych.
d) SÅ‚uÅ¼y do znajdowania najkrÃ³tszej Å›cieÅ¼ki.
e) Jest algorytmem zachÅ‚annym.
f) Wymaga macierzy o wagach ujemnych.


[#283] (#283) LiczbÄ™ rozwiÄ…zaÅ„ optymalnych w programowaniu liniowym:
>>a) MoÅ¼e wynosiÄ‡ zero, jedno lub nieskoÅ„czenie wiele.
b) Zero.
c) Zawsze dokÅ‚adnie jedno.
d) Zawsze skoÅ„czona liczba.
e) Zawsze co najmniej dwa.
f) ZaleÅ¼y od liczby procesorÃ³w.


[#284] (#284) Metoda podziaÅ‚u i ograniczeÅ„ (ang. branch and bound) opiera siÄ™ na porÃ³wnywaniu dwÃ³ch wartoÅ›ci:
      dolnego ograniczenia funkcji celu (ang. lower bound)
      gÃ³rnego ograniczenia funkcji celu (ang. upper bound)

Czym sÄ… te wartoÅ›ci?
>>a) LB to najlepszy moÅ¼liwy wynik w poddrzewie, UB to wartoÅ›Ä‡ najlepszego dotychczas znalezionego rozwiÄ…zania.
b) GÃ³rne ograniczenie liczy siÄ™ dla konkretnego wÄ™zÅ‚a w drzewie przeszukiwania.
c) LB i UB sÄ… zawsze rÃ³wne.
d) SÅ‚uÅ¼y tylko do problemÃ³w bez ograniczeÅ„.
>>e) Pozwala na przeszukiwanie tylko obiecujÄ…cych gaÅ‚Ä™zi drzewa rozwiÄ…zaÅ„.
f) Jest stosowana wyÅ‚Ä…cznie w sortowaniu.


[#285] (#285) Metoda Å›cieÅ¼ki krytycznej (CPM):
>>a) Pozwala wyznaczyÄ‡ najdÅ‚uÅ¼szy ciÄ…g zadaÅ„ zaleÅ¼nych.
b) Do okreÅ›lenia, ktÃ³re zadania majÄ… szczegÃ³lny wpÅ‚yw na czas realizacji.
c) SÅ‚uÅ¼y do optymalizacji kosztÃ³w transportu.
d) Wyznacza zadania o najwiÄ™kszym zapasie czasu.
>>e) Zadania na Å›cieÅ¼ce krytycznej majÄ… zerowy zapas czasu (slack).
f) Jest metodÄ… probabilistycznÄ… (jak PERT).


[#286] (#286) Metoda wielkich M (ang. big-M method) pozwala na znalezienie pierwszego rozwiÄ…zania dla algorytmu symplex. Zaznacz prawdziwe zdania
o tej metodzie:
>>a) Polega na wprowadzeniu sztucznych zmiennych z bardzo duÅ¼ym kosztem M.
b) Wymaga dodania dodatkowych ograniczeÅ„ na istniejÄ…ce zmienne.
c) SÅ‚uÅ¼y do rozwiÄ…zywania problemÃ³w nieliniowych.
d) Eliminuje potrzebÄ™ stosowania zmiennych swobodnych.
e) M jest zawsze rÃ³wne 1,000,000.
f) Jest stosowana tylko w problemach transportowych.


[#287] (#287) Metody rozwiÄ…zywania zagadnienia przydziaÅ‚u:
>>a) Algorytm wÄ™gierski, algorytmy przepÅ‚ywowe, programowanie caÅ‚kowitoliczbowe.
b) Dowolny algorytm rozwiÄ…zujÄ…cy problemy programowania caÅ‚kowitoliczbowego.
c) Tylko metoda bisekcji.
d) Algorytm Dijkstry.
e) Metoda najmniejszych kwadratÃ³w.
f) Algorytm Newtona.


[#288] (#288) PostaÄ‡ kanoniczna (rÃ³wnoÅ›ciowa) zadania programowania liniowego:
>>a) Wszystkie ograniczenia sÄ… rÃ³wnoÅ›ciami, a wszystkie zmienne sÄ… nieujemne.
b) Funkcja celu musi byÄ‡ maksymalizowana.
c) Liczba zmiennych musi byÄ‡ rÃ³wna liczbie ograniczeÅ„.
d) Macierz ograniczeÅ„ musi byÄ‡ kwadratowa.
e) Nie dopuszcza zmiennych swobodnych.
f) Jest jedynÄ… postaciÄ… akceptowanÄ… przez metodÄ™ graficznÄ….


[#289] (#289) DualnoÅ›Ä‡ w programowaniu liniowym:
>>a) KaÅ¼demu problemowi pierwotnemu odpowiada problem dualny.
b) WartoÅ›Ä‡ w optimum programu dualnego jest taka sama jak w pierwotnym.
c) Problem dualny ma zawsze wiÄ™cej zmiennych niÅ¼ pierwotny.
d) JeÅ›li problem pierwotny jest nieograniczony, to dualny ma rozwiÄ…zanie optymalne.
>>e) Liczba zmiennych w problemie dualnym jest rÃ³wna liczbie ograniczeÅ„ w problemie pierwotnym.
f) DualnoÅ›Ä‡ nie zachodzi dla problemÃ³w minimalizacji.


[#290] (#290) Relaksacja liniowa w metodzie podziaÅ‚u i ograniczeÅ„:
>>a) Polega na odrzuceniu wymogu caÅ‚kowitoliczbowoÅ›ci zmiennych.
b) Drzewo przeszukiwania w tym algorytmie jest drzewem binarnym.
c) Zawsze daje rozwiÄ…zanie caÅ‚kowitoliczbowe.
d) Jest stosowana tylko w problemach transportowych.
>>e) RozwiÄ…zanie relaksacji daje ograniczenie dla problemu oryginalnego.
f) Relaksacja liniowa jest problemem NP-trudnym.


[#291] (#291) Relaksacja problemu w badaniach operacyjnych:
>>a) To uproszczenie problemu, ktÃ³rego rozwiÄ…zanie daje oszacowanie wyniku problemu oryginalnego.
b) Relaksacja ma na celu stworzenie nowego problemu, ktÃ³ry jest prostszÄ… wersjÄ….
c) Relaksacja zawsze prowadzi do tego samego rozwiÄ…zania co problem oryginalny.
d) Polega na losowym wyborze zmiennych.
e) Zawsze zwiÄ™ksza liczbÄ™ ograniczeÅ„.
f) Jest stosowana tylko w programowaniu nieliniowym.


[#292] (#292) Algorytm dwufazowy sympleks:
>>a) Faza I znajduje rozwiÄ…zanie bazowe dopuszczalne, Faza II znajduje rozwiÄ…zanie optymalne.
b) Pracuje dwufazowo, czyli rozwiÄ…zuje dwa modele.
c) Jest stosowany tylko dla funkcji kwadratowych.
d) Nie wymaga macierzy jednostkowej w bazie.
e) Faza I zawsze koÅ„czy siÄ™ sukcesem.
f) Faza II jest opcjonalna.


[#293] (#293) Zaznacz prawdziwe (udowodnione) zdania o zÅ‚oÅ¼onoÅ›ci obliczeniowej decyzyjnej wersji problemu plecakowego:
>>a) Jest problemem NP-zupeÅ‚nym.
>>b) NaleÅ¼y do klasy NP.
c) Jest rozstrzygalny w czasie logarytmicznym.
d) NaleÅ¼y do klasy P.
e) Jest problemem nierozstrzygalnym.
f) MoÅ¼e byÄ‡ rozwiÄ…zany w czasie wielomianowym za pomocÄ… programowania dynamicznego.


[#294] (#294) Kodowanie 1 z n (One-Hot Encoding):
>>a) Reprezentacja zmiennych kategorycznych jako wektorÃ³w binarnych.
b) rodzaj zbioru danych, w ktÃ³rym tylko jedna kolumna ma istotne znaczenie.
c) metoda kompresji obrazÃ³w.
d) algorytm sortowania danych tekstowych.
e) SÅ‚uÅ¼y do zamiany liczb zmiennoprzecinkowych na caÅ‚kowite.
>>f) Jest stosowane w sieciach neuronowych do reprezentacji klas.


[#295] (#295) KtÃ³re z poniÅ¼szych poleceÅ„ sÄ… poprawne, zakÅ‚adajÄ…c Å¼e df jest obiektem DataFrame biblioteki Pandas?
>>a) Pozwala na stosowanie rÃ³Å¼nych funkcji agregujÄ…cych do wybranych kolumn DataFrame.
>>b) df.agg({'one': 'mean', 'four': 'sum'})
c) SÅ‚uÅ¼y do usuwania duplikatÃ³w.
d) Nie przyjmuje sÅ‚ownikÃ³w jako argumentÃ³w.
e) Jest toÅ¼sama z metodÄ… apply().
f) DziaÅ‚a tylko na obiektach typu Series.


[#296] (#296) KtÃ³re z poniÅ¼szych stwierdzeÅ„ sÄ… prawdziwe w odniesieniu do biblioteki Pandas?
>>a) Realizuje operacje zÅ‚Ä…czenia dwÃ³ch obiektÃ³w DataFrame na podstawie wspÃ³lnych kolumn.
b) Polecenie merge pozwala zÅ‚Ä…czyÄ‡ dwa obiekty DataFrame poprzez porÃ³wnanie wartoÅ›ci.
c) Zawsze modyfikuje oryginalne obiekty w miejscu.
d) SÅ‚uÅ¼y do pionowego Å‚Ä…czenia tabel.
>>e) ObsÅ‚uguje typy zÅ‚Ä…czeÅ„: inner, left, right, outer.
f) Wymaga, aby obie tabele miaÅ‚y identyczne indeksy.


[#297] (#297) ZakÅ‚adajÄ…c Å¼e s jest obiektem Series biblioteki Pandas, polecenie s.map(x) spowoduje:
>>a) SÅ‚uÅ¼y do mapowania wartoÅ›ci w Series na inne wartoÅ›ci.
b) jeÅ¼eli x jest ciÄ…giem znakÃ³w, odfiltrowanie tylko tych wartoÅ›ci.
c) Zmienia nazwy kolumn w DataFrame.
d) Oblicza Å›redniÄ… kroczÄ…cÄ….
e) Mapuje wartoÅ›ci tylko typu tekstowego.
f) Jest wolniejsza od pÄ™tli for w Pythonie.


[#298] (#298) Sferyczne ukÅ‚ady odniesienia (ang. spatial reference systems, coordinate reference systems), takie jak np. WGS-84:
>>a) ModelujÄ… ZiemiÄ™ jako elipsoidÄ™ lub sferÄ™, uÅ¼ywajÄ…c szerokoÅ›ci i dÅ‚ugoÅ›ci geograficznej.
b) korzystajÄ… ze wspÃ³Å‚rzÄ™dnych podanych w stopniach.
c) PozwalajÄ… na Å‚atwe obliczanie powierzchni w metrach kwadratowych bez rzutowania.
d) SÄ… ukÅ‚adami pÅ‚askimi.
e) SÄ… uÅ¼ywane w systemie GPS.
f) Nie uwzglÄ™dniajÄ… spÅ‚aszczenia Ziemi na biegunach.


[#299] (#299) PÅ‚askie (izometryczne, rzutowane) ukÅ‚ady odniesienia (ang. spatial reference systems, coordinate reference systems), takie jak np. PUWG
2000:
>>a) PowstajÄ… poprzez rzutowanie powierzchni elipsoidy na pÅ‚aszczyznÄ™.
b) pozwalajÄ… na obliczenie odlegÅ‚oÅ›ci przy pomocy samego twierdzenia Pitagorasa.
c) Nie wprowadzajÄ… Å¼adnych znieksztaÅ‚ceÅ„ odlegÅ‚oÅ›ci.
d) SÄ… uÅ¼ywane wyÅ‚Ä…cznie w nawigacji morskiej.
>>e) UÅ¼ywajÄ… wspÃ³Å‚rzÄ™dnych kartezjaÅ„skich (X, Y) wyraÅ¼onych w metrach.
f) SÄ… identyczne na caÅ‚ym Å›wiecie.


[#300] (#300) Optymalizacja czasu przetwarzania danych:
>>a) NaleÅ¼y zoptymalizowaÄ‡ algorytmy, uÅ¼yÄ‡ indeksowania, zrÃ³wnolegliÄ‡ obliczenia.
b) zwiÄ™kszyÄ‡ pamiÄ™Ä‡ wirtualnÄ….
c) zawsze kupiÄ‡ szybszy procesor.
d) zmniejszyÄ‡ liczbÄ™ kolorÃ³w w interfejsie.
e) WykorzystaÄ‡ wektoryzacjÄ™ operacji (np. w NumPy).
f) PrzenieÅ›Ä‡ wszystkie dane do plikÃ³w tekstowych.


[#301] (#301) JeÅ¼eli dane, przy ich analizie, nie mieszczÄ… siÄ™ w dostÄ™pnej pamiÄ™ci RAM naleÅ¼y do ich przetwarzania:
>>a) NaleÅ¼y stosowaÄ‡ przetwarzanie strumieniowe (chunking), bazy danych lub systemy Out-of-Core.
b) uÅ¼yÄ‡ bazy danych.
c) zrezygnowaÄ‡ z analizy czÄ™Å›ci danych.
d) wyÅ‚Ä…czyÄ‡ system operacyjny.
e) ZwiÄ™kszyÄ‡ rozmiar pliku wymiany (swap) do 1 TB.
f) UÅ¼yÄ‡ biblioteki Dask lub Apache Spark.


[#302] (#302) ZakÅ‚adajÄ…c, Å¼e df jest obiektem typu DataFrame biblioteki Pandas, polecenie df.apply(moja_funkcja)spowoduje:
>>a) WywoÅ‚uje funkcjÄ™ moja_funkcja dla kaÅ¼dej kolumny lub kaÅ¼dego wiersza.
b) uruchomienie raz funkcji moja_funkcja.
c) SÅ‚uÅ¼y do filtrowania danych.
d) DziaÅ‚a tylko na liczbach caÅ‚kowitych.
e) Zawsze zwraca obiekt typu Series.
f) Jest najbardziej wydajnym sposobem przetwarzania danych w Pandas.


[#303] (#303) ZakÅ‚adajÄ…c, Å¼e df jest obiektem typu DataFrame biblioteki Pandas, polecenie df.apply(moja_funkcja, axis=1)spowoduje:
>>a) WywoÅ‚uje funkcjÄ™ moja_funkcja dla kaÅ¼dego wiersza (row-wise).
b) wywoÅ‚ywanie funkcji moja_funkcja za kaÅ¼dym razem gdy obiekt df zostanie zmodyfikowany.
c) WywoÅ‚uje funkcjÄ™ tylko dla pierwszej kolumny.
d) SÅ‚uÅ¼y do transpozycji macierzy.
e) Jest szybsze niÅ¼ axis=0.
f) Pozwala na dostÄ™p do wielu kolumn jednoczeÅ›nie wewnÄ…trz funkcji.


[#304] (#304) KtÃ³re z poniÅ¼szych sposobÃ³w przechowywania danych pozwalajÄ… na jawne okreÅ›lenie, czy dana wartoÅ›Ä‡ jest liczbÄ… caÅ‚kowitÄ…, liczbÄ…
zmiennoprzecinkowÄ… czy tekstem?
>>a) Formaty takie jak Parquet, Avro czy bazy danych SQL przechowujÄ… informacje o typach.
b) plik JSON
c) plik CSV
d) plik tekstowy .txt
e) Pliki binarne zawsze wymagajÄ… jawnego schematu.
>>f) HDF5 obsÅ‚uguje jawne typowanie.


[#305] (#305) Obiekt GeoDataFrame w GeoPandas:
>>a) Rozszerza DataFrame o kolumnÄ™ 'geometry', ktÃ³ra przechowuje obiekty przestrzenne.
b) zawiera dane geometryczne, a nie dane tekstowe ani numeryczne.
>>c) MoÅ¼e zawieraÄ‡ zarÃ³wno dane atrybutowe, jak i przestrzenne.
d) Nie obsÅ‚uguje operacji zÅ‚Ä…czeÅ„.
>>e) Wymaga zainstalowanej biblioteki Shapely.
f) KaÅ¼dy wiersz musi mieÄ‡ geometriÄ™ tego samego typu.


[#306] (#306) Jakie sÄ… standardowe metody uÅ¼ywane do oceny modeli w nadzorowanym uczeniu maszynowym?
>>a) Accuracy, Precision, Recall, F1-score, Macierz pomyÅ‚ek, AUC-ROC.
>>b) Macierz pomyÅ‚ek.
c) Åšrednia arytmetyczna wag neuronÃ³w.
d) Liczba warstw w sieci.
e) Czas trenowania modelu.
f) Rozmiar pliku z modelem.


[#307] (#307) Metoda Leave-One-Out (LOOCV):
>>a) To wariant walidacji krzyÅ¼owej, gdzie testujemy model na jednym przykÅ‚adzie, a trenujemy na n-1.
b) To metoda doboru parametrÃ³w tylko w sieciach neuronowych.
c) SÅ‚uÅ¼y do usuwania duplikatÃ³w ze zbioru.
d) Jest bardzo szybka dla duÅ¼ych zbiorÃ³w danych.
>>e) Minimalizuje obciÄ…Å¼enie (bias) estymatora bÅ‚Ä™du.
>>f) Wymaga n-krotnego trenowania modelu.


[#308] (#308) Funkcja aktywacji w sieciach neuronowych:
>>a) Wprowadza nieliniowoÅ›Ä‡ do modelu.
>>b) Funkcja, zgodnie z ktÃ³rÄ… obliczane sÄ… wyjÅ›cia neuronÃ³w.
c) SÅ‚uÅ¼y do inicjalizacji wag.
d) Jest uÅ¼ywana tylko w warstwie wejÅ›ciowej.
>>e) ReLU (Rectified Linear Unit) jest popularnÄ… funkcjÄ… aktywacji.
f) Funkcja liniowa jest najczÄ™Å›ciej stosowana w warstwach ukrytych.


[#309] (#309) Niezbilansowany zbiÃ³r danych (Imbalanced Data):
>>a) Sytuacja, w ktÃ³rej jedna klasa jest znacznie liczniejsza od innych.
>>b) Do walidacji powinniÅ›my zastosowaÄ‡ metrykÄ™ F1.
c) NaleÅ¼y zawsze usunÄ…Ä‡ nadmiarowe dane z klasy liczniejszej.
d) Nie ma wpÅ‚ywu na proces uczenia.
>>e) MoÅ¼na stosowaÄ‡ techniki takie jak SMOTE (oversampling) lub undersampling.
f) Accuracy jest najlepszÄ… metrykÄ… w tym przypadku.


[#310] (#310) Etykietowanie danych (Labeling):
>>a) Proces przypisywania poprawnych odpowiedzi do danych wejÅ›ciowych.
b) Zawsze wykonywany jest automatycznie.
>>c) MoÅ¼e byÄ‡ wykonywany rÄ™cznie przez ekspertÃ³w.
d) Dotyczy tylko danych numerycznych.
e) Jest kluczowym etapem w uczeniu nienadzorowanym.
>>f) BÅ‚Ä™dne etykiety (noise) obniÅ¼ajÄ… jakoÅ›Ä‡ modelu.


[#311] (#311) Epoka (Epoch) w uczeniu maszynowym:
>>a) Jedno peÅ‚ne przejÅ›cie algorytmu przez caÅ‚y zbiÃ³r treningowy.
b) jednego cyklu, w ktÃ³rym pokazujemy sieci neuronowej wszystkie dane ze zbioru testowego.
c) Czas potrzebny na wytrenowanie jednego neuronu.
d) Liczba warstw w sieci gÅ‚Ä™bokiej.
e) Jest toÅ¼sama z jednÄ… iteracjÄ… (batch).
>>f) Zbyt duÅ¼a liczba epok moÅ¼e prowadziÄ‡ do overfittingu.


[#312] (#312) KtÃ³re z poniÅ¼szych metod nie sÄ… zazwyczaj stosowane do oceny modeli w nadzorowanym uczeniu maszynowym?
a) Obszar pod krzywÄ… ROC (AUC-ROC).
>>b) WspÃ³Å‚czynnik korelacji Pearsona.
c) Accuracy.
d) F1-score.
e) Log Loss (Cross-Entropy).
f) Åšredni bÅ‚Ä…d bezwzglÄ™dny (MAE) dla regresji.


[#313] (#313) Co moÅ¼na powiedzieÄ‡ o modelu uczenia maszynowego w kontekÅ›cie zjawiska nadmiernego dopasowania (przeuczenie, overfitting)?
>>a) Model ma bardzo niskÄ… stratÄ™ na zbiorze treningowym, ale wysokÄ… na testowym.
>>b) Model uczenia maszynowego jest zbyt dobrze dopasowany do danych treningowych.
c) Model jest zbyt prosty, aby opisaÄ‡ dane.
d) Wynika z braku danych treningowych.
>>e) Model "uczy siÄ™ na pamiÄ™Ä‡" szumu w danych treningowych.
f) Jest poÅ¼Ä…dane w systemach produkcyjnych.


[#314] (#314) Czym moÅ¼e byÄ‡ spowodowane nadmiernie dopasowanie (przeuczenie, overfitting)?
>>a) Zbyt duÅ¼a liczba parametrÃ³w modelu w stosunku do maÅ‚ej liczby przykÅ‚adÃ³w.
>>b) Zbyt skomplikowany model w stosunku do iloÅ›ci i charakteru dostÄ™pnych danych.
>>c) Zbyt duÅ¼a liczba epok trenowania.
d) Zastosowanie regularyzacji.
>>e) Brak zbioru walidacyjnego.
f) Zbyt silne Dropout w sieciach neuronowych.


[#315] (#315) Czym moÅ¼e byÄ‡ spowodowane niedouczenie (underfitting) modelu uczenia maszynowego?
>>a) Model jest zbyt prosty, aby uchwyciÄ‡ zaleÅ¼noÅ›ci w danych.
>>b) Zbyt krÃ³tkim czasem trenowania lub zbyt maÅ‚Ä… liczbÄ… epok.
c) Zbyt duÅ¼Ä… liczbÄ… cech (wymiarÃ³w).
d) UÅ¼yciem zbyt skomplikowanej sieci neuronowej.
>>e) Model ma wysoki bÅ‚Ä…d zarÃ³wno na zbiorze treningowym, jak i testowym.
f) MoÅ¼na go naprawiÄ‡ poprzez dodanie regularyzacji L2.


[#316] (#316) Jakie dziaÅ‚ania moÅ¼na podjÄ…Ä‡, aby uniknÄ…Ä‡ nadmiernego dopasowania (przeuczenia, overfitting)?
>>a) Regularyzacja (L1/L2), Dropout, Early Stopping, zwiÄ™kszenie iloÅ›ci danych.
b) ZastosowaÄ‡ wiÄ™kszÄ… liczbÄ™ cech.
c) ZwiÄ™kszyÄ‡ liczbÄ™ warstw sieci.
d) UsunÄ…Ä‡ zbiÃ³r walidacyjny.
>>e) ZastosowaÄ‡ Cross-Validation.
f) ZmniejszyÄ‡ siÅ‚Ä™ regularyzacji.


[#317] (#317) Jakie dziaÅ‚ania moÅ¼na podjÄ…Ä‡, aby uniknÄ…Ä‡ niedouczenia (underfitting)?
>>a) ZwiÄ™kszenie zÅ‚oÅ¼onoÅ›ci modelu, dodanie nowych cech, wydÅ‚uÅ¼enie czasu trenowania.
b) UÅ¼yÄ‡ prostszych modeli.
c) ZwiÄ™kszyÄ‡ siÅ‚Ä™ regularyzacji.
d) ZmniejszyÄ‡ liczbÄ™ neuronÃ³w w warstwach ukrytych.
e) UsunÄ…Ä‡ szum z danych treningowych.
>>f) ZastosowaÄ‡ inÅ¼ynieriÄ™ cech (feature engineering).


[#318] (#318) Jakie sÄ… przykÅ‚ady zadaÅ„ uczenia maszynowego stosowanych w uczeniu nadzorowanym?
>>a) Klasyfikacja i Regresja.
>>b) klasyfikacji
c) Klasteryzacja (grupowanie).
d) Redukcja wymiarowoÅ›ci.
e) Wykrywanie anomalii (bez etykiet).
>>f) Przewidywanie wartoÅ›ci ciÄ…gÅ‚ych (regresja).


[#319] (#319) Jakie sÄ… przykÅ‚ady zadaÅ„ uczenia maszynowego stosowanych w uczeniu nienadzorowanym?
>>a) Klasteryzacja, Redukcja wymiarowoÅ›ci, Wykrywanie anomalii, ReguÅ‚y asocjacyjne.
>>b) redukcji wymiarowoÅ›ci
c) Regresja logistyczna.
d) Przewidywanie szeregÃ³w czasowych.
>>e) Grupowanie podobnych klientÃ³w bez znajomoÅ›ci ich etykiet.
f) Rozpoznawanie twarzy na zdjÄ™ciach (z etykietami).


[#320] (#320) JednÄ… z podstawowych architektur systemÃ³w agentowych jest architektura BDI. W kontekÅ›cie systemÃ³w agentowych skrÃ³t BDI jest
wyjaÅ›niany jako:
>>a) Beliefs (Przekonania), Desires (Pragnienia), Intentions (Intencje).
b) Belief-Desire-Intention
c) Binary-Data-Interface
d) Behavior-Driven-Integration
e) Jest modelem architektury agentÃ³w inteligentnych.
f) SÅ‚uÅ¼y do budowy baz danych.


[#321] (#321) OdwracalnoÅ›Ä‡ automatÃ³w komÃ³rkowych:
>>a) Automat jest odwracalny, jeÅ›li kaÅ¼da konfiguracja ma dokÅ‚adnie jednego poprzednika.
b) Dla automatÃ³w odwracalnych odwzorowanie realizowane przez funkcjÄ™ przejÅ›cia nie moÅ¼e byÄ‡ bijekcjÄ….
c) Wszystkie automaty komÃ³rkowe sÄ… odwracalne.
d) OdwracalnoÅ›Ä‡ zaleÅ¼y od liczby stanÃ³w komÃ³rki.
e) Gra w Å¼ycie (Game of Life) jest automatem odwracalnym.
f) Automaty odwracalne zachowujÄ… informacjÄ™.


[#322] (#322) TwÃ³rcy automatÃ³w komÃ³rkowych:
>>a) John von Neumann oraz StanisÅ‚aw Ulam.
b) Jakob Laub oraz Philipp Lenard
c) Alan Turing i Alonzo Church.
d) Claude Shannon i Norbert Wiener.
e) Stephen Wolfram.
f) John Conway (twÃ³rca Gry w Å»ycie).


[#323] (#323) SÄ…siedztwa w automatach komÃ³rkowych:
>>a) SÄ…siedztwo von Neumanna (4 sÄ…siadÃ³w) oraz sÄ…siedztwo Moore'a (8 sÄ…siadÃ³w).
b) Dla siatki kwadratowej sÄ…siedztwo skÅ‚adajÄ…ce siÄ™ z czterech komÃ³rek stykajÄ…cych siÄ™ krawÄ™dziami nazywa siÄ™ sÄ…siedztwem von Neumanna.
c) SÄ…siedztwo Moore'a obejmuje tylko komÃ³rki stykajÄ…ce siÄ™ rogami.
d) SÄ…siedztwo jest zawsze definiowane dla caÅ‚ej siatki jednoczeÅ›nie.
e) IstniejÄ… sÄ…siedztwa o wiÄ™kszym promieniu (np. r=2).
f) SÄ…siedztwo von Neumanna obejmuje komÃ³rkÄ™ centralnÄ….


[#324] (#324) Emergencja w systemach zÅ‚oÅ¼onych:
>>a) Zjawisko powstawania nowych, zÅ‚oÅ¼onych wÅ‚aÅ›ciwoÅ›ci na poziomie makroskopowym.
b) Otrzymywaniu caÅ‚oÅ›ciowego obrazu makroskopowego systemu na podstawie dziaÅ‚ania mikroskopowych reguÅ‚.
c) Polega na centralnym sterowaniu kaÅ¼dym elementem systemu.
d) Jest synonimem chaosu deterministycznego.
e) PrzykÅ‚adem jest formowanie siÄ™ kluczy ptakÃ³w lub mrowisk.
f) Wymaga skomplikowanych reguÅ‚ dla kaÅ¼dego agenta.


[#325] (#325) Najprostszy agent, ktÃ³ry prowadzi prostÄ… adaptacjÄ™ swojego dziaÅ‚ania w zaleÅ¼noÅ›ci od zmian Å›rodowiska (bez efektÃ³w pamiÄ™ci i uczenia siÄ™)
okreÅ›lany jest jako:
>>a) Podejmuje decyzje wyÅ‚Ä…cznie na podstawie aktualnego stanu Å›rodowiska.
b) Agent reaktywny
c) Posiada rozbudowanÄ… pamiÄ™Ä‡ dÅ‚ugotrwaÅ‚Ä….
d) Planuje swoje dziaÅ‚ania z duÅ¼ym wyprzedzeniem.
e) Nie posiada wewnÄ™trznego modelu Å›wiata.
f) Jest przykÅ‚adem agenta BDI.


[#326] (#326) NajwaÅ¼niejszymi wÅ‚asnoÅ›ciami systemÃ³w zÅ‚oÅ¼onych (ang. complex systems) w domenie skali i czasu sÄ…:
>>a) Emergencja, samoorganizacja, nieliniowoÅ›Ä‡, sprzÄ™Å¼enia zwrotne.
b) Emergencja
c) PrzewidywalnoÅ›Ä‡ dÅ‚ugoterminowa.
d) Centralne zarzÄ…dzanie.
e) AdaptacyjnoÅ›Ä‡.
f) WraÅ¼liwoÅ›Ä‡ na warunki poczÄ…tkowe (efekt motyla).


[#327] (#327) WskaÅ¼ ktÃ³re zdania sÄ… prawdziwe w odniesieniu do homogenicznego i synchronicznego Automatu KomÃ³rkowego (CA)?
>>a) Homogeniczny - te same reguÅ‚y; Synchroniczny - jednoczesna aktualizacja.
>>b) Gra Life zaproponowana przez matematyka Johna Conwaya jest przykÅ‚adem homogenicznego i synchronicznego automatu komÃ³rkowego.
c) W grze Life reguÅ‚y zmieniajÄ… siÄ™ w kaÅ¼dej iteracji.
d) Gra Life wymaga interwencji uÅ¼ytkownika w kaÅ¼dym kroku.
>>e) Wszystkie komÃ³rki w automacie synchronicznym zmieniajÄ… stan w tym samym momencie zegarowym.
f) HomogenicznoÅ›Ä‡ oznacza, Å¼e siatka musi byÄ‡ nieskoÅ„czona.


[#328] (#328) WÅ‚asnoÅ›ci homogenicznego automatu komÃ³rkowego:
>>a) Identyczna reguÅ‚a przejÅ›cia, identyczny zbiÃ³r stanÃ³w i identyczny ksztaÅ‚t sÄ…siedztwa dla kaÅ¼dej komÃ³rki.
b) ReguÅ‚a przejÅ›cia identyczna dla caÅ‚ej siatki.
c) KaÅ¼da komÃ³rka ma innÄ… liczbÄ™ sÄ…siadÃ³w.
d) Siatka musi byÄ‡ zawsze skoÅ„czona.
e) Zapewnia niezmienniczoÅ›Ä‡ reguÅ‚ wzglÄ™dem przesuniÄ™cia (translativity).
f) Stany komÃ³rek muszÄ… byÄ‡ liczbami binarnymi.


[#329] (#329) Niehomogeniczny Automat KomÃ³rkowy:
>>a) MoÅ¼e posiadaÄ‡ rÃ³Å¼ne reguÅ‚y przejÅ›cia lub rÃ³Å¼ne zbiory stanÃ³w dla poszczegÃ³lnych komÃ³rek.
b) Niehomogeniczny automat komÃ³rkowy wyÅ‚Ä…cznie charakteryzuje siÄ™ rÃ³Å¼nymi zbiorami stanÃ³w.
c) Jest zawsze odwracalny.
d) Nie moÅ¼e byÄ‡ symulowany na komputerze.
e) Pozwala na modelowanie Å›rodowisk o zrÃ³Å¼nicowanych wÅ‚aÅ›ciwoÅ›ciach fizycznych.
f) Wymaga asynchronicznej aktualizacji.


[#330] (#330) Symulacja zdarzeÅ„ dyskretnych (DES):
>>a) Modeluje system jako sekwencyjnÄ… listÄ™ zdarzeÅ„ w czasie.
b) DES stanowiÄ… alternatywnÄ… metodÄ™ modelowania wobec systemÃ³w Agent Based Modeling (ABM).
c) Czas in DES pÅ‚ynie w sposÃ³b ciÄ…gÅ‚y.
d) SÅ‚uÅ¼y wyÅ‚Ä…cznie do modelowania procesÃ³w chemicznych.
e) Zdarzenia sÄ… umieszczane w kolejce priorytetowej (event list).
f) Stan systemu zmienia siÄ™ pÅ‚ynnie miÄ™dzy zdarzeniami.


[#331] (#331) Periodyczne warunki brzegowe dla Automatu KomÃ³rkowego oznaczajÄ… nastÄ™pujÄ…ce wÅ‚asnoÅ›ci dla obiektu poruszajÄ…cego siÄ™ po siatce:
>>a) PrzeciwlegÅ‚e krawÄ™dzie siatki sÄ… ze sobÄ… poÅ‚Ä…czone.
b) PoruszajÄ…cy siÄ™ obiekt definitywnie znika z siatki po osiÄ…gniÄ™ciu granicznych komÃ³rek.
c) PowodujÄ… odbicie siÄ™ obiektu od Å›ciany.
d) SÄ… stosowane tylko w automatach 1D.
e) Siatka 2D z takimi warunkami ma topologiÄ™ torusa.
f) EliminujÄ… efekty brzegowe w symulacjach.


[#332] (#332) Algorytmy poszukujÄ…ce ekstremum funkcji:
>>a) Gradient Descent, Adam, Algorytmy Genetyczne, Simulated Annealing.
>>b) Stochastic Gradient Descent
c) K-Means
d) PCA
>>e) PSO (Particle Swarm Optimization).
f) BFS (Breadth-First Search).


[#333] (#333) Algorytmy redukcji wymiarowoÅ›ci:
>>a) PCA (Principal Component Analysis), t-SNE, UMAP, Autoenkodery.
b) K-Nearest Neighbors
c) Linear Regression
d) Decision Trees
e) LDA (Linear Discriminant Analysis).
f) SVD (Singular Value Decomposition).


[#334] (#334) Metryki skutecznoÅ›ci modelu predykcyjnego:
>>a) MSE (Mean Squared Error), MAE, R-squared (dla regresji); Accuracy, F1 (dla klasyfikacji).
b) Wariancja
c) Odchylenie standardowe wag.
d) Liczba iteracji.
e) Log-Loss.
f) WspÃ³Å‚czynnik Giniego.


[#335] (#335) Uczenie czÄ™Å›ciowo nadzorowane (Semi-supervised Learning):
>>a) Wykorzystuje maÅ‚Ä… iloÅ›Ä‡ danych etykietowanych i duÅ¼Ä… iloÅ›Ä‡ danych nieetykietowanych.
b) Nie potrzebuje etykiet.
c) Jest toÅ¼same z uczeniem ze wzmocnieniem.
d) Wymaga etykiet dla wszystkich przykÅ‚adÃ³w.
e) Jest przydatne, gdy etykietowanie danych jest drogie lub czasochÅ‚onne.
f) Wykorzystuje techniki takie jak self-training lub co-training.


[#336] (#336) Funkcje aktywacji w sieciach neuronowych:
>>a) Sigmoid, ReLU, Tanh, Softmax.
b) Sigmoid
c) Linear (tylko w regresji).
d) Logarytmiczna.
e) ELU (Exponential Linear Unit).
f) Heaviside (funkcja skokowa).


[#337] (#337) Instancja odstajÄ…ca (Outlier):
>>a) PrzykÅ‚ad w zbiorze danych, ktÃ³ry znaczÄ…co odbiega od pozostaÅ‚ych obserwacji.
b) InnÄ… nazwÄ… instancji etykietowanej.
c) Element zawsze usuwany przed trenowaniem.
d) Åšrodek ciÄ™Å¼koÅ›ci klastra.
e) MoÅ¼e negatywnie wpÅ‚ywaÄ‡ na modele takie jak regresja liniowa.
f) Jest zawsze wynikiem bÅ‚Ä™du pomiarowego.


[#338] (#338) Algorytm K-Means:
>>a) Jest algorytmem uczenia nienadzorowanego sÅ‚uÅ¼Ä…cym do klasteryzacji.
b) Jest metodÄ… uczenia nadzorowanego.
c) Wymaga etykiet klas dla kaÅ¼dego punktu.
d) Zawsze znajduje globalne optimum.
>>e) DÄ…Å¼y do minimalizacji wariancji wewnÄ…trz klastrÃ³w.
>>f) Jest czuÅ‚y na poczÄ…tkowÄ… inicjalizacjÄ™ Å›rodkÃ³w klastrÃ³w.


[#339] (#339) Dla cech X, Y uzyskano wartoÅ›Ä‡ wspÃ³Å‚czynnika korelacji liniowej -0.95. Co on oznacza?
>>a) Oznacza bardzo silnÄ… ujemnÄ… korelacjÄ™ liniowÄ….
b) Wzrostowi wartoÅ›ci cechy X towarzyszy wzrost wartoÅ›ci cechy Y.
c) Oznacza brak zwiÄ…zku miÄ™dzy cechami.
d) Wskazuje na zwiÄ…zek nieliniowy.
e) Punkty na wykresie rozrzutu ukÅ‚adajÄ… siÄ™ blisko linii prostej o ujemnym nachyleniu.
f) Oznacza, Å¼e X powoduje Y (zwiÄ…zek przyczynowo-skutkowy).


[#340] (#340) MajÄ…c uzupeÅ‚nionÄ… macierz bÅ‚Ä™dÃ³w (confusion matrix), ktÃ³re metryki do oceny jakoÅ›ci modelu moÅ¼na obliczyÄ‡?
>>a) Accuracy, Precision (Precyzja), Recall (CzuÅ‚oÅ›Ä‡), F1-score, Specificity.
b) precyzjÄ™
c) Åšredni bÅ‚Ä…d kwadratowy.
d) WspÃ³Å‚czynnik determinacji R2.
>>e) Matthews Correlation Coefficient (MCC).
f) Entropia krzyÅ¼owa.


[#341] (#341) Algorytmy uczenia nadzorowanego:
>>a) Regresja liniowa, SVM, Drzewa decyzyjne, k-NN, Sieci neuronowe.
>>b) K-NearestNeighbors
c) K-Means
d) PCA
>>e) Naive Bayes.
>>f) Random Forest.


[#342] (#342) Algorytmy uczenia nienadzorowanego:
>>a) K-Means, DBSCAN, PCA, Apriori, Autoenkodery.
b) Regresja Liniowa
c) Random Forest
d) Naive Bayes
>>e) GMM (Gaussian Mixture Models).
>>f) t-SNE.


[#343] (#343) WskaÅ¼ poprawne wÅ‚aÅ›ciwoÅ›ci odnoszÄ…ce siÄ™ do analizy skÅ‚adowych gÅ‚Ã³wnych (PCA).
>>a) Metoda statystyczna sÅ‚uÅ¼Ä…ca do redukcji wymiarowoÅ›ci.
>>b) Jest metodÄ… nienadzorowanÄ….
c) SÅ‚uÅ¼y do klasyfikacji obrazÃ³w.
d) Wymaga danych w postaci tekstowej.
>>e) Maksymalizuje wariancjÄ™ rzutowanych danych.
f) SkÅ‚adowe gÅ‚Ã³wne sÄ… skorelowane.


[#344] (#344) Jakie zastrzeÅ¼enia przewidziaÅ‚ Turing przeciwko sensownoÅ›ci zaproponowanego przez siebie testu?
>>a) Turing rozwaÅ¼aÅ‚ m.in. argument z braku Å›wiadomoÅ›ci, argument z niepeÅ‚nosprawnoÅ›ci maszyny.
>>b) Maszyna cyfrowa jest w stanie zrobiÄ‡ tylko to, co nakazuje jej program.
c) Test Turinga jest niemoÅ¼liwy do przeprowadzenia.
d) Maszyny nigdy nie bÄ™dÄ… umiaÅ‚y graÄ‡ w szachy.
e) ChiÅ„ski PokÃ³j Searla jest znanym argumentem przeciwko testowi Turinga.
f) Turing przewidywaÅ‚, Å¼e maszyny nigdy nie przejdÄ… testu.


[#345] (#345) Parametr k w algorytmie kNN (k-Nearest Neighbors):
>>a) Oznacza liczbÄ™ najbliÅ¼szych sÄ…siadÃ³w branych pod uwagÄ™ przy klasyfikacji.
b) k oznacza liczbÄ™ rozpoznawanych klas.
c) k to liczba warstw w sieci.
d) k to wymiarowoÅ›Ä‡ danych.
e) MaÅ‚e k moÅ¼e prowadziÄ‡ do overfittingu.
f) k musi byÄ‡ zawsze liczbÄ… parzystÄ….


[#346] (#346) W ramach klasyfikacji binarnej uzyskano nastÄ™pujÄ…ce wyniki: TP = 90; TN = 30; FP = 10; FN = 70. Ile wynosi wartoÅ›Ä‡ predykcyjna
dodatnia?
>>a) PPV = TP / (TP + FP).
b) 0,5
c) 0,9
d) 0,7
e) Dla TP=90 i FP=10 wynosi 0.9.
f) Jest toÅ¼sama z czuÅ‚oÅ›ciÄ… (Recall).


[#347] (#347) Przewidywanie jednego ulubionego koloru danej osoby (z 5 moÅ¼liwych: {Å¼Ã³Å‚ty, rÃ³Å¼owy, niebieski, zielony, czerwony}) to:
>>a) Jest to zadanie klasyfikacji.
b) Klasteryzacja
c) Regresja
d) Redukcja wymiarowoÅ›ci
e) Zadanie uczenia nadzorowanego.
f) Zadanie optymalizacji globalnej.


[#348] (#348) Macierz pomyÅ‚ek (Confusion Matrix):
>>a) Jej rozmiar to N x N, gdzie N to liczba klas.
b) Macierz pomyÅ‚ek zawsze ma rozmiar 2x2.
c) Pokazuje tylko bÅ‚Ä™dy modelu.
d) Nie pozwala na obliczenie czuÅ‚oÅ›ci.
>>e) PrzekÄ…tna macierzy zawiera liczby poprawnych predykcji.
f) SÅ‚uÅ¼y do oceny modeli regresji.


[#349] (#349) Jakie parametry naleÅ¼y ustawiÄ‡ w algorytmie DBSCAN do grupowania danych?
>>a) Epsilon (promieÅ„ sÄ…siedztwa) oraz MinPts (minimalna liczba punktÃ³w).
b) Liczba iteracji.
c) Liczba klastrÃ³w k.
d) WspÃ³Å‚czynnik uczenia.
e) DBSCAN nie wymaga podania liczby klastrÃ³w z gÃ³ry.
f) DBSCAN radzi sobie z klastrami o rÃ³Å¼nych gÄ™stoÅ›ciach.


[#350] (#350) KtÃ³re z poniÅ¼szych cech najlepiej opisujÄ… algorytm k-Å›rednich (k-means)?
>>a) Grupuje dane poprzez minimalizacjÄ™ sumy kwadratÃ³w odlegÅ‚oÅ›ci od Å›rodkÃ³w klastrÃ³w.
>>b) Wymaga okreÅ›lenia liczby klastrÃ³w na poczÄ…tku.
c) Jest odporny na wartoÅ›ci odstajÄ…ce.
d) DziaÅ‚a dobrze dla klastrÃ³w o dowolnych ksztaÅ‚tach.
>>e) Jest algorytmem iteracyjnym.
f) Gwarantuje znalezienie globalnego minimum funkcji celu.


[#351] (#351) Jakie diagramy, ze wzglÄ™du na swoje wÅ‚aÅ›ciwoÅ›ci wizualne, sÄ… najbardziej efektywne do prezentacji wynikÃ³w grupowania przez algorytm k-
Å›rednich (k-means)?
>>a) Najlepiej widoczna na wykresie punktowym (scatter plot).
>>b) Wykres punktowy.
c) Wykres koÅ‚owy.
d) Histogram.
>>e) Wykres Å‚okcia (Elbow method) sÅ‚uÅ¼y do wyboru optymalnego k.
f) Dendrogram.


[#352] (#352) KtÃ³re z poniÅ¼szych opcji opisujÄ… cechy lub zastosowania algorytmu grupowania aglomeracyjnego?
>>a) Tworzy hierarchiÄ™ klastrÃ³w (dendrogram).
b) Redukcja wymiarowoÅ›ci danych.
c) Wymaga podania liczby klastrÃ³w przed startem.
d) Jest zawsze szybsze od k-means.
>>e) MoÅ¼e stosowaÄ‡ rÃ³Å¼ne kryteria Å‚Ä…czenia (linkage).
f) Jest metodÄ… uczenia nadzorowanego.


[#353] (#353) KtÃ³re z poniÅ¼szych stwierdzeÅ„ trafnie opisujÄ… metodÄ™ analizy gÅ‚Ã³wnych skÅ‚adowych (PCA)?
>>a) Nowe cechy (skÅ‚adowe) sÄ… liniowymi kombinacjami cech oryginalnych.
>>b) PCA tworzy skÅ‚adowe, ktÃ³re sÄ… wzajemnie ortogonalne.
c) Zawsze zachowuje 100% wariancji danych.
d) SÅ‚uÅ¼y do usuwania brakujÄ…cych danych.
>>e) SkÅ‚adowe gÅ‚Ã³wne sÄ… uporzÄ…dkowane wedÅ‚ug iloÅ›ci wyjaÅ›nianej wariancji.
>>f) PCA jest bardzo wraÅ¼liwe na skalowanie danych.


[#354] (#354) KtÃ³re z poniÅ¼szych zastosowaÅ„ sÄ… odpowiednie dla algorytmu Apriori?
>>a) SÅ‚uÅ¼y do odkrywania czÄ™stych zbiorÃ³w elementÃ³w i reguÅ‚ asocjacyjnych.
>>b) Analiza koszykowa w handlu detalicznym.
c) Klasyfikacja spamu.
d) Rozpoznawanie twarzy.
>>e) Wykorzystuje miary takie jak wsparcie (support), ufnoÅ›Ä‡ (confidence) i przyrost (lift).
>>f) Jest stosowany w systemach rekomendacyjnych.


[#355] (#355) KtÃ³re z poniÅ¼szych metod, algorytmÃ³w lub technik sÄ… stosowane w uczeniu nienadzorowanym?
>>a) K-Means, Hierarchical Clustering, PCA, Autoenkodery, SOM.
>>b) Autoenkodery, sieÄ‡ Kohonena
c) Regresja liniowa, k-NN
d) Random Forest, XGBoost
>>e) Analiza skÅ‚adowych niezaleÅ¼nych (ICA).
>>f) SVD.


[#356] (#356) Elementy uczenia ze wzmocnieniem (Reinforcement Learning):
>>a) Agent, Åšrodowisko (Environment), Stan (State), Akcja (Action), Nagroda (Reward), Polityka (Policy).
>>b) Polityka
c) Etykieta klasy.
d) ZbiÃ³r treningowy.
>>e) Funkcja wartoÅ›ci (Value Function).
>>f) Eksploracja vs Eksploatacja.
