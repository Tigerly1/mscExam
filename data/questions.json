{
  "metadata": {
    "generatedAt": "2026-02-04T01:06:06.284Z",
    "sources": [
      "drill copy.txt (IDs 1-233)",
      "nowe_pytania_isi.txt (IDs 1001-1356)"
    ],
    "stats": {
      "total": 575,
      "byTopic": {
        "algorithms": 34,
        "digital_systems": 27,
        "transmission": 1,
        "databases": 31,
        "software_engineering": 49,
        "functional_programming": 6,
        "java": 21,
        "c_cpp": 35,
        "numerical_methods": 44,
        "networks": 47,
        "operating_systems": 25,
        "oop_design": 5,
        "formal_languages": 41,
        "concurrent_programming": 6,
        "unix_admin": 19,
        "number_representation": 18,
        "programming_basics": 7,
        "logic": 12,
        "math": 36,
        "computer_graphics": 12,
        "compilation": 14,
        "image_processing": 1,
        "web_programming": 21,
        "machine_learning": 63
      },
      "bySemester": {
        "1": 76,
        "2": 65,
        "3": 154,
        "4": 123,
        "5": 60,
        "6": 22,
        "7": 75
      },
      "multipleChoice": 278,
      "singleChoice": 297
    }
  },
  "questions": [
    {
      "id": 1,
      "question": "Zadanie o rozmiarze n, realizowane pewnym algorytmem o złożoności f(n), zostało sprowadzone do dwóch podzadań o rozmiarze n/2 każde oraz do n działań o stałym czasie wykonania, zapewniających rozbicie i scalenie zadania. Złożoność f(n) wynosi:",
      "options": [
        {
          "key": "a",
          "text": "f(n) = O(log(n))",
          "correct": false
        },
        {
          "key": "b",
          "text": "f(n) = O(n*log(n))",
          "correct": true
        },
        {
          "key": "c",
          "text": "f(n) = O(n + log(n))",
          "correct": false
        },
        {
          "key": "d",
          "text": "f(n) = O(n)",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 2,
      "question": "Dana jest procedura: Proc(n){ if(warunek(x)) then { A(x); Proc(f(n)); B(x) } else C(x) }. Przyjmijmy konwencję, że np. zapis AAABCC oznacza trzykrotne wykonanie instrukcji A, po czym następuje wykonanie instrukcji B, a następnie dwukrotne wykonanie instrukcji C. Następujące sekwencje instrukcji mogą być wynikiem wywołania powyższej procedury:",
      "options": [
        {
          "key": "a",
          "text": "AACBB",
          "correct": true
        },
        {
          "key": "b",
          "text": "ACBB",
          "correct": false
        },
        {
          "key": "c",
          "text": "AACCBB",
          "correct": false
        },
        {
          "key": "d",
          "text": "ACCB",
          "correct": false
        },
        {
          "key": "e",
          "text": "C",
          "correct": true
        },
        {
          "key": "f",
          "text": "AAACCCBBB",
          "correct": false
        },
        {
          "key": "g",
          "text": "AABBC",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 3,
      "question": "Dla problemu komiwojażera algorytm pozwalający wyznaczyć rozwiązanie optymalne:",
      "options": [
        {
          "key": "a",
          "text": "istnieje i ma złożoność wielomianową",
          "correct": false
        },
        {
          "key": "b",
          "text": "istnieje i ma złożoność wykładniczą",
          "correct": true
        },
        {
          "key": "c",
          "text": "nie istnieje",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 4,
      "question": "Korzystając z układu FPGA można wykonać:",
      "options": [
        {
          "key": "a",
          "text": "na przykład dowolny układ kombinacyjny, ograniczony jedynie wielkością struktury FPGA",
          "correct": true
        },
        {
          "key": "b",
          "text": "na przykład dowolny układ sekwencyjny, ograniczony jedynie wielkością struktury FPGA",
          "correct": true
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 5,
      "question": "Układ kombinacyjny to:",
      "options": [
        {
          "key": "a",
          "text": "układ logiczny nie pamiętający stanów poprzednich",
          "correct": true
        },
        {
          "key": "b",
          "text": "w jego skład mogą wchodzić bramki logiczne w połączeniu z przerzutnikami JK",
          "correct": false
        },
        {
          "key": "c",
          "text": "układ cyfrowy, w którym stan wyjść zależy wyłącznie od stanu wejść",
          "correct": true
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 6,
      "question": "Układ sekwencyjny to:",
      "options": [
        {
          "key": "a",
          "text": "układ logiczny nie pamiętający stanów poprzednich",
          "correct": false
        },
        {
          "key": "b",
          "text": "może składać się z samych bramek logicznych",
          "correct": true
        },
        {
          "key": "c",
          "text": "może się składać z samych bramek logicznych bez sprzężeń zwrotnych",
          "correct": false
        },
        {
          "key": "d",
          "text": "w skład jego mogą wchodzić bramki logiczne w połączeniu z przerzutnikami JK",
          "correct": true
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 7,
      "question": "Pamięć RAM:",
      "options": [
        {
          "key": "a",
          "text": "posiada wejścia adresowe, wejścia sterujące oraz wejście/wyjście danych",
          "correct": true
        },
        {
          "key": "b",
          "text": "można wykonać z bramek NAND",
          "correct": true
        },
        {
          "key": "c",
          "text": "można wykonać z bramek NAND bez sprzężeń zwrotnych",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 8,
      "question": "Pamięć RAM dwuportowa:",
      "options": [
        {
          "key": "a",
          "text": "możemy wykonać z bramek NAND bez sprzężeń zwrotnych",
          "correct": false
        },
        {
          "key": "b",
          "text": "to pamięć RAM z dwoma interfejsami, pozwalającymi niezależnie uzyskać dostęp do tych samych komórek pamięci",
          "correct": true
        },
        {
          "key": "c",
          "text": "w układach FPGA taki rodzaj pamięci nie występuje",
          "correct": false
        },
        {
          "key": "d",
          "text": "to specjalne pamięci RAM, które umożliwiają dwóm niezależnym procesom (kontrolerom pamięci) dostęp do wspólnych danych",
          "correct": true
        },
        {
          "key": "e",
          "text": "można ją wykorzystać wyłącznie w procesorach wielordzeniowych",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 9,
      "question": "Procesor:",
      "options": [
        {
          "key": "a",
          "text": "możemy wykonać przy użyciu FPGA, ale tylko jednordzeniowy",
          "correct": false
        },
        {
          "key": "b",
          "text": "żadne z pozostałych",
          "correct": false
        },
        {
          "key": "c",
          "text": "to sekwencyjne urządzenie cyfrowe, które pobiera dane z pamięci operacyjnej, interpretuje je i wykonuje jako rozkazy",
          "correct": true
        },
        {
          "key": "d",
          "text": "tryby adresowania procesora wykonywanego przy użyciu FPGA muszą być zgodne z trybami przewidzianymi przez producenta układu",
          "correct": false
        },
        {
          "key": "e",
          "text": "możemy wykonać przy użyciu FPGA",
          "correct": true
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 10,
      "question": "Lista rozkazów procesora:",
      "options": [
        {
          "key": "a",
          "text": "w skład listy rozkazów zawsze wchodzi mnożenie",
          "correct": false
        },
        {
          "key": "c",
          "text": "w procesorze wykonywanym przy użyciu FPGA musi być zgodna z listą rozkazów przewidzianą przez producenta układu FPGA",
          "correct": false
        },
        {
          "key": "d",
          "text": "projektowana jest w zależności od potrzeb związanych z zastosowaniem procesora",
          "correct": true
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 11,
      "question": "Karta graficzna:",
      "options": [
        {
          "key": "a",
          "text": "może być układem kombinacyjnym",
          "correct": false
        },
        {
          "key": "b",
          "text": "przy użyciu FPGA nie można zbudować karty graficznej ze sprzętowym wspomaganiem OpenGL",
          "correct": false
        },
        {
          "key": "c",
          "text": "prostą wersję można zapisać w dwudziestu kilku liniach VHDL",
          "correct": true
        },
        {
          "key": "d",
          "text": "OpenGL to specyfikacja otwartego i uniwersalnego API do tworzenia grafiki; jest to zestaw podstawowych funkcji umożliwiających tworzenie grafiki",
          "correct": true
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 12,
      "question": "Licznik rozkazów:",
      "options": [
        {
          "key": "a",
          "text": "jest to licznik z wejściem równoległym wykorzystywanym wyłącznie przy skokach bezwarunkowych",
          "correct": false
        },
        {
          "key": "b",
          "text": "służy do pamiętania adresu mającego się wykonać rozkazu lub adresu aktualnie pobieranego argumentu z pamięci programu",
          "correct": true
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 13,
      "question": "Rozkaz skoku bezwarunkowego procesora:",
      "options": [
        {
          "key": "a",
          "text": "powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku niezależnie od warunku",
          "correct": true
        },
        {
          "key": "b",
          "text": "powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku, ale tylko w przypadku spełnienia warunku skoku",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie wpływa na stan licznika rozkazów procesora",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 14,
      "question": "Rozkaz skoku warunkowego procesora:",
      "options": [
        {
          "key": "a",
          "text": "nie wpływa na stan licznika rozkazów procesora",
          "correct": false
        },
        {
          "key": "b",
          "text": "powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku niezależnie od warunku",
          "correct": false
        },
        {
          "key": "c",
          "text": "powoduje wpisanie do licznika rozkazów adresu rozkazu mającego się wykonać po skoku, ale tylko w przypadku spełnienia warunku skoku",
          "correct": true
        },
        {
          "key": "d",
          "text": "żadne z pozostałych",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 15,
      "question": "Rozkaz procesora wykonujący dodanie dwóch liczb:",
      "options": [
        {
          "key": "a",
          "text": "powoduje dodanie dwóch liczb, wynik zapisuje do licznika rozkazów",
          "correct": false
        },
        {
          "key": "b",
          "text": "wykorzystuje ALU",
          "correct": true
        },
        {
          "key": "c",
          "text": "żadne z pozostałych",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 16,
      "question": "W procesorze wykorzystującym przetwarzanie potokowe:",
      "options": [
        {
          "key": "a",
          "text": "wykonanie pojedynczej instrukcji rozkłada się na ciąg prostszych etapów",
          "correct": true
        },
        {
          "key": "b",
          "text": "rozpoczęcie wykonania pierwszego etapu rozkazu może nastąpić dopiero po zakończeniu wykonania pierwszego etapu poprzedniego rozkazu",
          "correct": true
        },
        {
          "key": "c",
          "text": "rozpoczęcie wykonania rozkazu może nastąpić dopiero po zakończeniu wykonania poprzedniego rozkazu",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 17,
      "question": "W procesorze wykorzystującym superskalarność:",
      "options": [
        {
          "key": "a",
          "text": "rozpoczęcie wykonania pierwszego etapu rozkazu może nastąpić dopiero po zakończeniu wykonania pierwszego etapu poprzedniego rozkazu",
          "correct": false
        },
        {
          "key": "b",
          "text": "ten sam etap dwóch kolejnych rozkazów może być wykonywany w tej samej chwili",
          "correct": true
        },
        {
          "key": "c",
          "text": "możliwe jest jednoczesne wykonanie więcej niż jednej instrukcji",
          "correct": true
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 18,
      "question": "Rejestr rozkazów:",
      "options": [
        {
          "key": "a",
          "text": "przechowuje adres rozkazu wczytany z pamięci programu",
          "correct": false
        },
        {
          "key": "b",
          "text": "jego zawartość wykorzystywana jest przez jednostkę sterującą",
          "correct": true
        },
        {
          "key": "c",
          "text": "w trakcie wykonywania rozkazu zawartość rejestru rozkazów musi zmienić się bezpośrednio przed pobraniem argumentu rozkazu z pamięci programu",
          "correct": true
        },
        {
          "key": "d",
          "text": "przechowuje kod rozkazu wczytany z pamięci programu",
          "correct": true
        }
      ],
      "topic": "digital_systems",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 19,
      "question": "Transmisja asynchroniczna:",
      "options": [
        {
          "key": "a",
          "text": "układy nadawczy i odbiorczy synchronizowane są wspólną dodatkową linią z sygnałem synchronicznym",
          "correct": false
        },
        {
          "key": "b",
          "text": "podczas transmisji asynchronicznej występują kolejno po sobie wycinki czasu zawierające i nie zawierające informacji",
          "correct": true
        },
        {
          "key": "c",
          "text": "aby przygotować odbiorcę na przyjęcie sygnału zawierającego informacje, są wysyłane sygnały startu oraz sygnały stopu, rozpoczynające i kończące przesyłanie porcji informacji",
          "correct": true
        }
      ],
      "topic": "transmission",
      "semester": 1,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 34,
      "question": "Wskaż, w których przypadkach klauzule instrukcji SELECT są ułożone we właściwej kolejności:",
      "options": [
        {
          "key": "a",
          "text": "from, where, group by, having, order by",
          "correct": true
        },
        {
          "key": "b",
          "text": "from, group by, having, where, order by",
          "correct": false
        },
        {
          "key": "c",
          "text": "from, group by, where, having, order by",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": false
    },
    {
      "id": 35,
      "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące postaci normalnej Boyce'a-Codda:",
      "options": [
        {
          "key": "a",
          "text": "dowolną relację R o schemacie H można sprowadzić do BCNF stosując dekompozycję bezstratną, ale niekoniecznie zachowującą zależności funkcyjne",
          "correct": true
        },
        {
          "key": "b",
          "text": "dowolna relacja dwuatrybutowa jest w BCNF",
          "correct": true
        },
        {
          "key": "c",
          "text": "jeżeli schemat relacji znajduje się w postaci normalnej Boyce'a-Codda, to nie ma w nim redundancji",
          "correct": true
        },
        {
          "key": "d",
          "text": "BCNF oznacza, że lewa strona każdej nietrywialnej zależności funkcyjnej zawiera klucz",
          "correct": true
        },
        {
          "key": "e",
          "text": "atrybut z prawej strony zależności może być podstawowy",
          "correct": false
        },
        {
          "key": "f",
          "text": "schematy relacji zawsze należy doprowadzać do postaci BCNF",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 36,
      "question": "Dana jest relacja R o schemacie H = {A, B, C, D, E} oraz zbiór zależności funkcyjnych F = {{B, C} -> {D, E}, {C, D} -> {B, E}, {D} -> {C}, {E} -> {B}}. W jakiej maksymalnie postaci normalnej jest relacja R? Zakładamy, że jest w 1NF.",
      "options": [
        {
          "key": "a",
          "text": "1NF",
          "correct": false
        },
        {
          "key": "b",
          "text": "2NF",
          "correct": false
        },
        {
          "key": "c",
          "text": "3NF",
          "correct": true
        },
        {
          "key": "d",
          "text": "4NF",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": false
    },
    {
      "id": 37,
      "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące trzeciej postaci normalnej:",
      "options": [
        {
          "key": "a",
          "text": "jeżeli wszystkie atrybuty ze schematu relacji są atrybutami kluczowymi, to relacja jest w 3NF",
          "correct": true
        },
        {
          "key": "b",
          "text": "dowolną relację można sprowadzić do 3NF stosując dekompozycję bezstratną i zachowującą zależności funkcyjne",
          "correct": true
        },
        {
          "key": "c",
          "text": "3NF oznacza, że każdy atrybut niekluczowy (informacyjny) zależy wyłącznie od klucza; innymi słowy, atrybuty informacyjne są wzajemnie niezależne",
          "correct": true
        },
        {
          "key": "d",
          "text": "BCNF jest nieco bardziej restrykcyjną wersją 3NF - w BCNF wszystkie atrybuty (również kluczowe) muszą spełniać warunek zależności wyłącznie od klucza; ten dodatkowy wymóg ma znaczenie, gdy relacja zawiera wiele kluczy",
          "correct": true
        },
        {
          "key": "e",
          "text": "jeżeli relacja jest w BCNF, to jest również w 3NF",
          "correct": true
        },
        {
          "key": "f",
          "text": "jeżeli relacja jest w 3NF, to możliwe jest występowanie pewnych redundancji",
          "correct": true
        },
        {
          "key": "g",
          "text": "relacja jest w 3NF, jeżeli jest w 2NF i nie zawiera zależności funkcyjnych",
          "correct": false
        },
        {
          "key": "h",
          "text": "jeżeli relacja jest w 3NF, to jest również w BCNF",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 38,
      "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące kluczy obcych w relacyjnym modelu danych:",
      "options": [
        {
          "key": "a",
          "text": "wartości klucza obcego są unikatowe",
          "correct": false
        },
        {
          "key": "b",
          "text": "klucze obce są sposobem łączenia danych przechowywanych w różnych tabelach",
          "correct": true
        },
        {
          "key": "c",
          "text": "klucz obcy jest kolumną lub grupą kolumn tabeli, która czerpie swoje wartości z tej samej dziedziny, co klucz główny powiązanej z nią tabeli",
          "correct": true
        },
        {
          "key": "d",
          "text": "klucz obcy musi odnosić się do istniejącej krotki lub przyjmować wartość NULL, aby jawnie stwierdzić, że nie ma związku z reprezentowanymi obiektami w bazie danych albo że ten związek jest nieznany",
          "correct": true
        },
        {
          "key": "e",
          "text": "klucz obcy nie musi być unikatowy w obrębie tabeli",
          "correct": true
        },
        {
          "key": "f",
          "text": "klucz obcy może pochodzić z tej samej tabeli, gdy chcemy stworzyć związek rekurencyjny",
          "correct": true
        },
        {
          "key": "g",
          "text": "klucz obcy i klucz do którego się on odwołuje muszą mieć tyle samo atrybutów",
          "correct": true
        },
        {
          "key": "h",
          "text": "muszą się nazywać tak samo jak klucz tabeli głównej",
          "correct": false
        },
        {
          "key": "i",
          "text": "muszą zawierać nazwę tabeli głównej w swojej nazwie",
          "correct": false
        },
        {
          "key": "j",
          "text": "powinny wskazywać na klucz główny w tabeli głównej",
          "correct": true
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 39,
      "question": "Wskaż, które ograniczenia można definiować na poziomie kolumny (w instrukcji create table):",
      "options": [
        {
          "key": "a",
          "text": "wartość domyślna atrybutu",
          "correct": true
        },
        {
          "key": "b",
          "text": "krótsze ścieżki na płycie głownej",
          "correct": false
        },
        {
          "key": "c",
          "text": "większy bufor",
          "correct": false
        },
        {
          "key": "d",
          "text": "unikalne wartości atrybutu",
          "correct": true
        },
        {
          "key": "e",
          "text": "proste klucze główne",
          "correct": true
        },
        {
          "key": "f",
          "text": "NULL / NOT NULL",
          "correct": true
        },
        {
          "key": "g",
          "text": "wyrażenia regularne",
          "correct": false
        },
        {
          "key": "h",
          "text": "funkcje walidujące",
          "correct": false
        },
        {
          "key": "i",
          "text": "wyzwalacze typu \"zdarzenie, warunek, akcja\"",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 40,
      "question": "Wskaż wszystkie prawdziwe stwierdzenia dotyczące wartości NULL:",
      "options": [
        {
          "key": "a",
          "text": "w modelu relacyjnym wartość NULL jest traktowana jako trzecia, różna od false i true, wartość logiczna",
          "correct": true
        },
        {
          "key": "b",
          "text": "dwie wartości NULL są traktowane jako równe",
          "correct": false
        },
        {
          "key": "c",
          "text": "wartości NULL są różne od spacji, zera czy też pustego łańcucha znaków",
          "correct": true
        },
        {
          "key": "d",
          "text": "jeżeli wystąpi w wartości atrybutu NULL, to suma po tym atrybucie też jest NULL",
          "correct": true
        },
        {
          "key": "e",
          "text": "klucz obcy musi zawierać przynajmniej jedną wartość NULL",
          "correct": false
        },
        {
          "key": "f",
          "text": "wartość NULL oznacza zero",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 41,
      "question": "Które wyrażenie SQL zwraca wszystkie wiersze tabeli \"Osoby\" posortowane malejąco według atrybutu \"Imie\"?",
      "options": [
        {
          "key": "a",
          "text": "SELECT * FROM Osoby SORT BY 'Imie' DESC",
          "correct": false
        },
        {
          "key": "b",
          "text": "SELECT * FROM Osoby ORDER BY Imie DESC",
          "correct": true
        },
        {
          "key": "c",
          "text": "SELECT * FROM Osoby SORT 'Imie' DESC",
          "correct": false
        },
        {
          "key": "d",
          "text": "SELECT * FROM Osoby ORDER Imie DESC",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": false
    },
    {
      "id": 42,
      "question": "Jak możesz zmienić wartość \"Kowalski\" na \"Nowak\" w atrybucie \"Nazwisko\" w tabeli \"Osoby\"?",
      "options": [
        {
          "key": "a",
          "text": "MODIFY Osoby SET Nazwisko='Nowak' WHERE Nazwisko='Kowalski'",
          "correct": false
        },
        {
          "key": "b",
          "text": "MODIFY Osoby SET Nazwisko='Kowalski' INTO Nazwisko='Nowak'",
          "correct": false
        },
        {
          "key": "c",
          "text": "UPDATE Osoby SET Nazwisko='Kowalski' INTO Nazwisko='Nowak'",
          "correct": false
        },
        {
          "key": "d",
          "text": "UPDATE Osoby SET Nazwisko='Nowak' WHERE Nazwisko='Kowalski'",
          "correct": true
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": false
    },
    {
      "id": 43,
      "question": "Jak można przy pomocy SQL uzyskać informację o liczbie wierszy w tabeli \"Osoby\"?",
      "options": [
        {
          "key": "a",
          "text": "SELECT COUNT(*) FROM Osoby",
          "correct": true
        },
        {
          "key": "b",
          "text": "SELECT COUNT() FROM Osoby",
          "correct": false
        },
        {
          "key": "c",
          "text": "SELECT COLUMNS() FROM Osoby",
          "correct": false
        },
        {
          "key": "d",
          "text": "SELECT COLUMNS(*) FROM Osoby",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": false
    },
    {
      "id": 44,
      "question": "Jako można przy pomocy SQL wybrać wszystkie wiersze z tabeli \"Osoby\", w których wartość atrybutu \"Imie\" zaczyna się od \"a\"?",
      "options": [
        {
          "key": "a",
          "text": "SELECT * FROM Osoby WHERE Imie LIKE '%a'",
          "correct": false
        },
        {
          "key": "b",
          "text": "SELECT * FROM Osoby WHERE Imie='%a%'",
          "correct": false
        },
        {
          "key": "c",
          "text": "SELECT * FROM Osoby WHERE Imie LIKE 'a%'",
          "correct": true
        },
        {
          "key": "d",
          "text": "SELECT * FROM Osoby WHERE Imie='a'",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": false
    },
    {
      "id": 45,
      "question": "Którą z poniższych cech musi posiadać klucz właściwy?",
      "options": [
        {
          "key": "a",
          "text": "jego wartość jednoznacznie wyznacza wiersz w danej tabeli",
          "correct": true
        },
        {
          "key": "b",
          "text": "jest automatycznie generowany przez System Zarządzania Bazą Danych",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie może być generowany przez SZBD",
          "correct": false
        },
        {
          "key": "d",
          "text": "jego wartość składa się tylko z jednego atrybutu",
          "correct": false
        },
        {
          "key": "e",
          "text": "nie może być pomniejszony o żaden atrybut",
          "correct": true
        },
        {
          "key": "f",
          "text": "żaden podzbiór jego atrybutów nie może być kluczem",
          "correct": true
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 46,
      "question": "Algebra relacji jest podstawą dla:",
      "options": [
        {
          "key": "a",
          "text": "realizacji przez relacyjny SZBD operacji języka manipulacji danymi",
          "correct": true
        },
        {
          "key": "b",
          "text": "budowy diagramów ERD",
          "correct": false
        },
        {
          "key": "c",
          "text": "budowy diagramów DFD",
          "correct": false
        },
        {
          "key": "d",
          "text": "algorytmicznych języków relacyjnych baz danych",
          "correct": true
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 47,
      "question": "Które z poniższych cech posiadają widoki (view)?",
      "options": [
        {
          "key": "a",
          "text": "mogą realizować politykę ograniczania dostępu do danych",
          "correct": true
        },
        {
          "key": "b",
          "text": "ułatwiają konstrukcję zapytań SQL do bazy danych",
          "correct": true
        },
        {
          "key": "c",
          "text": "zabezpieczają dane przed ich utratą w trakcie realizacji złożonych transakcji",
          "correct": false
        },
        {
          "key": "d",
          "text": "powodują problemy z konstrukcją zapytań SQL do bazy danych",
          "correct": false
        },
        {
          "key": "e",
          "text": "dostarczają prostego mechanizmu uaktualniania danych",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 48,
      "question": "Z jakim problemem trzeba się uporać przy odwzorowaniu w schemacie relacyjnej bazy danych relacji typu n:m (wiele do wiele)?",
      "options": [
        {
          "key": "a",
          "text": "zdefiniować podwójne indeksowanie plików odpowiadających każdej z tabel",
          "correct": false
        },
        {
          "key": "b",
          "text": "trzeba zaprojektować dodatkową tabelę",
          "correct": true
        },
        {
          "key": "c",
          "text": "dobrać odpowiedni klucz obcy w drugiej z tabel",
          "correct": false
        },
        {
          "key": "d",
          "text": "trzeba użyć dodatkowo widoku (view)",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": false
    },
    {
      "id": 49,
      "question": "Które z poniższych stwierdzeń są prawdziwe, jeśli dotyczą systemów baz danych realizowanych w architekturze klient-serwer?",
      "options": [
        {
          "key": "a",
          "text": "mocno obciążają sieć w stosunku do systemów scentralizowanych",
          "correct": false
        },
        {
          "key": "b",
          "text": "pozwalają klientom pracować w różnych systemach operacyjnych",
          "correct": true
        },
        {
          "key": "c",
          "text": "uniezależniają sposób realizacji aplikacji od serwera",
          "correct": true
        },
        {
          "key": "d",
          "text": "wymagają co najmniej dwóch komputerów",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 50,
      "question": "Systemy OLTP i OLAP różnią się przede wszystkim:",
      "options": [
        {
          "key": "a",
          "text": "czasem reakcji na zapytanie",
          "correct": true
        },
        {
          "key": "b",
          "text": "stopniem szczegółowości przechowywanych danych",
          "correct": true
        },
        {
          "key": "c",
          "text": "zakresem realizowanych funkcji użytkowych",
          "correct": true
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 51,
      "question": "Rolą hurtowni danych jest:",
      "options": [
        {
          "key": "a",
          "text": "przygotowanie danych do szybkiej analizy",
          "correct": true
        },
        {
          "key": "b",
          "text": "kontrola poprawności danych realizowana podczas wykonywania transakcji",
          "correct": false
        },
        {
          "key": "c",
          "text": "minimalizacja plików fizycznych przez ujednolicenie sposobu przechowywania danych",
          "correct": false
        },
        {
          "key": "d",
          "text": "przechowywanie danych w sposób scentralizowany",
          "correct": true
        },
        {
          "key": "e",
          "text": "wydajne odpowiadanie na zapytania o charakterze analitycznym",
          "correct": true
        },
        {
          "key": "f",
          "text": "zwiększenie bezpieczeństwa",
          "correct": false
        },
        {
          "key": "g",
          "text": "obsługa dużej ilości równoległych transakcji modyfikujących dane",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 52,
      "question": "Modele danych w postaci gwiazdy i płatka śniegu:",
      "options": [
        {
          "key": "a",
          "text": "ich implementacja przyspiesza analizę danych",
          "correct": true
        },
        {
          "key": "b",
          "text": "pozwalają oddać sens złożonej struktury danych",
          "correct": true
        },
        {
          "key": "c",
          "text": "zapewniają brak redundancji danych",
          "correct": false
        },
        {
          "key": "d",
          "text": "pomagają utrzymać spójność danych",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 53,
      "question": "Celem testowania oprogramowania jest:",
      "options": [
        {
          "key": "a",
          "text": "zbadanie zgodności z wymaganiami",
          "correct": true
        },
        {
          "key": "b",
          "text": "wykrycie błędów w oprogramowaniu",
          "correct": true
        },
        {
          "key": "c",
          "text": "zbadanie zgodności z oczekiwaniami użytkownika",
          "correct": true
        },
        {
          "key": "d",
          "text": "sprawdzenie poprawności komentarzy w kodzie",
          "correct": false
        },
        {
          "key": "e",
          "text": "ocena jakości oprogramowania",
          "correct": true
        },
        {
          "key": "f",
          "text": "zdefiniowanie jakości kodu",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 54,
      "question": "Jakie są główne aktywności w modelu spiralnym?",
      "options": [
        {
          "key": "a",
          "text": "Planowanie, Analiza Ryzyka, Konstrukcja, Walidacja",
          "correct": true
        },
        {
          "key": "b",
          "text": "Szybki Projekt, Budowa Prototypu, Ocena Prototypu, Redefinicja Prototypu",
          "correct": false
        },
        {
          "key": "c",
          "text": "Analiza Wymagań, Projektowanie, Kodowanie, Testowanie",
          "correct": false
        },
        {
          "key": "d",
          "text": "Definiowanie, Prototypowanie, Testowanie, Dostarczenie Produktu",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 55,
      "question": "Jakiego widoku nie znajdziesz w modelu architektonicznym Kruchtena?",
      "options": [
        {
          "key": "a",
          "text": "przypadków użycia",
          "correct": false
        },
        {
          "key": "b",
          "text": "konstrukcji",
          "correct": false
        },
        {
          "key": "c",
          "text": "logicznego",
          "correct": false
        },
        {
          "key": "d",
          "text": "przepływu danych",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 56,
      "question": "Jaką rolę na diagramach klas UML pełni kompozycja?",
      "options": [
        {
          "key": "a",
          "text": "jest związkiem typu gen-spec między instancjami klasy",
          "correct": false
        },
        {
          "key": "b",
          "text": "jest związkiem typu część-całość między obiektami",
          "correct": true
        },
        {
          "key": "c",
          "text": "wspomaga graficzne rozlokowanie symboli klas na diagramie",
          "correct": false
        },
        {
          "key": "d",
          "text": "oznacza ukrywanie złożoności obiektów przed użytkownikiem",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 57,
      "question": "Jednym z celów inżynierii oprogramowania jest tworzenie oprogramowania, które jest:",
      "options": [
        {
          "key": "a",
          "text": "wolne od błędów",
          "correct": true
        },
        {
          "key": "b",
          "text": "dostarczane zgodnie z harmonogramem",
          "correct": true
        },
        {
          "key": "c",
          "text": "niezawodne i efektywne",
          "correct": true
        },
        {
          "key": "d",
          "text": "niezgodne z wymaganiami",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 58,
      "question": "Przykładem ryzyka występującego podczas wytwarzania oprogramowania jest:",
      "options": [
        {
          "key": "a",
          "text": "odejście kluczowych osób z zespołu projektowego, zanim produkt zostanie wdrożony",
          "correct": true
        },
        {
          "key": "b",
          "text": "konkurenci mogą sprzedawać taniej system o podobnej funkcjonalności",
          "correct": false
        },
        {
          "key": "c",
          "text": "problemy ze zdefiniowaniem specyfikacji produktu",
          "correct": true
        },
        {
          "key": "d",
          "text": "wykonywanie kolejnych faz zgodnie z ustalonym harmonogramem",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 59,
      "question": "Tworzenie modelu obiektowego z istniejącej relacyjnej bazy danych jest określane jako:",
      "options": [
        {
          "key": "a",
          "text": "forward engineering",
          "correct": false
        },
        {
          "key": "b",
          "text": "backward engineering",
          "correct": false
        },
        {
          "key": "c",
          "text": "reverse engineering",
          "correct": true
        },
        {
          "key": "d",
          "text": "inverse engineering",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 60,
      "question": "Stosowanie techniki prototypowania jest zalecane dla:",
      "options": [
        {
          "key": "a",
          "text": "aplikacji budowanej w oparciu o frameworki",
          "correct": false
        },
        {
          "key": "b",
          "text": "gdy liczy się czas dostarczenia",
          "correct": false
        },
        {
          "key": "c",
          "text": "zespołów programistów, którym brakuje znajomości dziedziny",
          "correct": true
        },
        {
          "key": "d",
          "text": "gdy istnieje trudność uzyskania pełnej informacji o wymaganiach systemu",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 61,
      "question": "Które z poniższych stwierdzeń nie jest celem budowy modeli analitycznych:",
      "options": [
        {
          "key": "a",
          "text": "opracowanie rozwiązań problemów",
          "correct": true
        },
        {
          "key": "b",
          "text": "ustalenie wszystkich czynników / warunków w dziedzinie przedmiotowej / w otoczeniu projektu, które mogą wpłynąć na decyzje projektowe",
          "correct": false
        },
        {
          "key": "c",
          "text": "stworzenie logicznego modelu systemu, opisującego sposób realizacji wymagań, ale bez szczegółów implementacyjnych",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 62,
      "question": "Wstępna próba zdefiniowania elementów systemu oraz ich wzajemnych relacji, organizowanie tych elementów w dobrze określone warstwy z wyraźnie nakreślonymi zależnościami nazywa się analizą:",
      "options": [
        {
          "key": "a",
          "text": "przypadków użycia",
          "correct": false
        },
        {
          "key": "b",
          "text": "architektoniczną",
          "correct": true
        },
        {
          "key": "c",
          "text": "strukturalną",
          "correct": false
        },
        {
          "key": "d",
          "text": "systemową",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 63,
      "question": "Którego z poniższych narzędzi nie używa się podczas analizy systemowej?",
      "options": [
        {
          "key": "a",
          "text": "Data Flow Diagram",
          "correct": false
        },
        {
          "key": "b",
          "text": "Decision Tree",
          "correct": true
        },
        {
          "key": "c",
          "text": "Object Modelling Technique",
          "correct": false
        },
        {
          "key": "d",
          "text": "HOOD",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 64,
      "question": "Które z podanych rodzajów wymagań nie są określane podczas przygotowywania definicji wymagań systemowych?",
      "options": [
        {
          "key": "a",
          "text": "abstrakcyjne wymagania funkcjonalne",
          "correct": false
        },
        {
          "key": "b",
          "text": "szczegółowe wymagania funkcjonalne",
          "correct": true
        },
        {
          "key": "c",
          "text": "cechy lub zachowania, których system nie powinien przejawiać",
          "correct": false
        },
        {
          "key": "d",
          "text": "właściwości systemu",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 65,
      "question": "Które z wymienionych czynności występują dla wszystkich procesów wytwarzania oprogramowania?",
      "options": [
        {
          "key": "a",
          "text": "budowa i ulepszanie prototypów",
          "correct": false
        },
        {
          "key": "b",
          "text": "retrospektywa celem polepszenia procesu",
          "correct": false
        },
        {
          "key": "c",
          "text": "pozyskiwanie wymagań",
          "correct": true
        },
        {
          "key": "d",
          "text": "ciągła integracja",
          "correct": false
        },
        {
          "key": "e",
          "text": "testowanie wydajności",
          "correct": false
        },
        {
          "key": "f",
          "text": "walidacja oprogramowania",
          "correct": true
        },
        {
          "key": "g",
          "text": "specyfikowanie oprogramowania",
          "correct": true
        },
        {
          "key": "h",
          "text": "zarządzanie konfiguracjami",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 66,
      "question": "Zapis wymagania powinien bezwzględnie zawierać:",
      "options": [
        {
          "key": "a",
          "text": "informację o kolejności wprowadzenia danego wymagania w stosunku do innych wymagań",
          "correct": false
        },
        {
          "key": "b",
          "text": "informację o uzależnieniu danego wymagania od innych wymagań lub powiązaniu z nimi",
          "correct": true
        },
        {
          "key": "c",
          "text": "informację o pochodzeniu danego wymagania i jego uzasadnienie",
          "correct": true
        },
        {
          "key": "d",
          "text": "informację o uzależnieniu projektu od wymagania, tj. powiązaniu danego wymagania ze składnikami systemu, które je implementują",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 67,
      "question": "Prototypowanie z porzuceniem jest wariantem ewolucyjnego tworzenia oprogramowania, w którym:",
      "options": [
        {
          "key": "a",
          "text": "tworzony jest fragment systemu zwany prototypem, odpowiadający ograniczonej części wymagań, celem eksperymentalnego rozeznania wymagań klienta i ustalenia lub walidacji ich specyfikacji oraz zbadania możliwości ich spełnienia",
          "correct": true
        },
        {
          "key": "b",
          "text": "ze względu na dwukrotną realizację systemu - jako prototypu i systemu finalnego - wydłużony jest znacznie czas realizacji i powiększony koszt przedsięwzięcia, przez co ta metoda stosowana jest głównie wtedy, gdy przez oddanie prototypu zamiast finalnej wersji systemu można oddalić groźbę katastrofalnego opóźnienia i całkowitego załamania projektu",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie powstaje prawie żadna dokumentacja projektowa i stąd używana niekiedy nazwa \"metoda studencka\"",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie przywiązuje wagi do jakości oprogramowania wytworzonego prototypu ani nawet jego zdolności do funkcjonowania, o ile nie przeszkadza to w wykorzystaniu go do realizacji jego głównego celu",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 68,
      "question": "Do modeli iteracyjnych tworzenia oprogramowania zaliczamy:",
      "options": [
        {
          "key": "a",
          "text": "metodę przyrostową",
          "correct": true
        },
        {
          "key": "b",
          "text": "model kaskadowy",
          "correct": false
        },
        {
          "key": "c",
          "text": "model spiralny tworzenia oprogramowania",
          "correct": true
        },
        {
          "key": "d",
          "text": "ewolucyjny tworzenie oprogramowania",
          "correct": false
        },
        {
          "key": "e",
          "text": "metodykę Kanban",
          "correct": false
        },
        {
          "key": "f",
          "text": "programowanie ekstremalne",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 69,
      "question": "Inspekcja (przegląd) wymagań jest:",
      "options": [
        {
          "key": "a",
          "text": "metodą walidacji wymagań",
          "correct": true
        },
        {
          "key": "b",
          "text": "nazywana formalną bądź nieformalną, zależnie od tego, czy zespół twórców systemu wyjaśnia znaczenie każdego wymagania, czy tylko prowadzi luźną rozmowę z przestawicielami klienta",
          "correct": true
        },
        {
          "key": "c",
          "text": "procesem \"ręcznym\" polegającym na grupowym czytaniu dokumentacji wymagań",
          "correct": true
        },
        {
          "key": "d",
          "text": "niepodobna do inspekcji programów (kodu)",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 70,
      "question": "Systemy odziedziczone:",
      "options": [
        {
          "key": "a",
          "text": "to systemy starsze niż kilka-kilkanaście lat, których działanie pozostaje krytycznym czynnikiem z punktu widzenia funkcjonowania instytucji, ale technologia nie odpowiada aktualnym potrzebom",
          "correct": true
        },
        {
          "key": "b",
          "text": "mają oprogramowanie i sprzęt niezmieniony od czasów ich zainstalowania, ale ich przeróbka i unowocześnienie nie jest możliwe z braku kompatybilnego sprzętu, odpowiednich kompilatorów języków programowania, bibliotek i odpowiednik specjalistów",
          "correct": false
        },
        {
          "key": "c",
          "text": "można tylko całkowicie wycofać i/lub zastąpić nowymi systemami",
          "correct": false
        },
        {
          "key": "d",
          "text": "obejmują oprogramowanie, sprzęt na którym może ono działać, dane użytkowe przez nie udostępniane i gromadzone, procedury biznesowe, prowadzone z użyciem oprogramowania",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 71,
      "question": "Jakie aspekty powinien uwzględniać pełny model systemu w podejściu strukturalnym do analizy i projektowania?",
      "options": [
        {
          "key": "a",
          "text": "aspekt funkcjonalny, aspekt danych i ich powiązań",
          "correct": false
        },
        {
          "key": "b",
          "text": "aspekt funkcjonalny i aspekt dynamiki systemu",
          "correct": false
        },
        {
          "key": "c",
          "text": "aspekt danych i ich powiązań, aspekt dynamiki systemu",
          "correct": false
        },
        {
          "key": "d",
          "text": "aspekt funkcjonalny, aspekt danych i ich powiązań, oraz dynamiki systemu",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 72,
      "question": "Aspekt funkcjonalny systemu informatycznego modelowany jest w podejściu strukturalnym przy pomocy:",
      "options": [
        {
          "key": "a",
          "text": "Data Flow Diagrams",
          "correct": true
        },
        {
          "key": "b",
          "text": "Entity Relationship Diagrams",
          "correct": false
        },
        {
          "key": "c",
          "text": "State Transition Diagrams",
          "correct": false
        },
        {
          "key": "d",
          "text": "Structure Charts",
          "correct": false
        },
        {
          "key": "e",
          "text": "Behaviour Diagrams",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 73,
      "question": "Które z wymienionych podziałów wymagań niefunkcjonalnych są wyczerpujące i rozłączne?",
      "options": [
        {
          "key": "a",
          "text": "produktowe, organizacyjne, prawne",
          "correct": false
        },
        {
          "key": "b",
          "text": "produktowe, prawne, parametryczne",
          "correct": false
        },
        {
          "key": "c",
          "text": "produktowe, zewnętrzne, strategiczne",
          "correct": false
        },
        {
          "key": "d",
          "text": "produktowe, organizacyjne, zewnętrzne",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 74,
      "question": "Wymień elementy modelu środowiskowego w strukturalnym podejściu do analizy i projektowania systemów informatycznych:",
      "options": [
        {
          "key": "a",
          "text": "ERD, DFD, STD",
          "correct": false
        },
        {
          "key": "b",
          "text": "diagram kontekstowy, słownik danych, specyfikacja funkcji",
          "correct": false
        },
        {
          "key": "c",
          "text": "opis celu systemu, wymagania funkcjonalne, wymagania niefunkcjonalne",
          "correct": false
        },
        {
          "key": "d",
          "text": "opis celu systemu, lista zdarzeń, diagram kontekstowy",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 75,
      "question": "Jaki zestaw diagramów jest używany w metodyce strukturalnej analizy i projektowania systemów informatycznych do pokazania wszystkich aspektów modelowanego systemu?",
      "options": [
        {
          "key": "a",
          "text": "DFD, ERD i STC",
          "correct": false
        },
        {
          "key": "b",
          "text": "DFD i ERD",
          "correct": false
        },
        {
          "key": "c",
          "text": "DFD, ERD i STD (lub ELH)",
          "correct": true
        },
        {
          "key": "d",
          "text": "DFD i STD",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 76,
      "question": "Które obiekty graficzne są używane do tworzenia diagramu kontekstowego w metodyce strukturalnej analizy i projektowania systemów informatycznych:",
      "options": [
        {
          "key": "a",
          "text": "proces, przepływ danych (data flow), magazyn danych (data store)",
          "correct": false
        },
        {
          "key": "b",
          "text": "proces, obiekt zewnętrzny (external entity), magazyn danych (data store)",
          "correct": false
        },
        {
          "key": "c",
          "text": "przepływ danych (data flow), obiekt zewnętrzny (external entity), magazyn danych",
          "correct": false
        },
        {
          "key": "d",
          "text": "proces, przepływ danych (data flow), obiekt zewnętrzny (external entity)",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 77,
      "question": "Wybierz nazwy wszystkich obiektów graficznych używanych do konstruowania DFD (Data Flow Diagram) - diagramów przepływu danych w metodyce strukturalnej:",
      "options": [
        {
          "key": "a",
          "text": "proces (process)",
          "correct": true
        },
        {
          "key": "b",
          "text": "obiekt zewnętrzny (external entity)",
          "correct": true
        },
        {
          "key": "c",
          "text": "magazyn danych (data store)",
          "correct": true
        },
        {
          "key": "d",
          "text": "przepływ danych (data flow)",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 78,
      "question": "Wskaż ten element dokumentacji projektowej, który zawiera zapis w postaci pseudokodu (metodyka strukturalna analizy i projektowania systemów informatycznych):",
      "options": [
        {
          "key": "a",
          "text": "opis wymagań niefunkcjonalnych",
          "correct": false
        },
        {
          "key": "b",
          "text": "opis wymagań funkcjonalnych",
          "correct": false
        },
        {
          "key": "c",
          "text": "specyfikacja funkcji",
          "correct": true
        },
        {
          "key": "d",
          "text": "opis celu przedsięwzięcia projektowego",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 79,
      "question": "Który element DFD w metodyce strukturalnej stanowi podstawę konstruowania ERD (Entity Relationship Diagram) - diagramu związków encji:",
      "options": [
        {
          "key": "a",
          "text": "przepływ danych (data flow)",
          "correct": false
        },
        {
          "key": "b",
          "text": "diagram kontekstowy (context diagram)",
          "correct": false
        },
        {
          "key": "c",
          "text": "obiekt zewnętrzny (external entity)",
          "correct": false
        },
        {
          "key": "d",
          "text": "magazyn danych (data store)",
          "correct": true
        }
      ],
      "topic": "software_engineering",
      "semester": 5,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 80,
      "question": "Jaki typ danych w Haskellu będzie miało następujące wyrażenie: r x = x:r x",
      "options": [
        {
          "key": "a",
          "text": "r :: [a]",
          "correct": false
        },
        {
          "key": "b",
          "text": "r :: Integer a => a -> [a]",
          "correct": false
        },
        {
          "key": "c",
          "text": "r :: a -> [a]",
          "correct": true
        }
      ],
      "topic": "functional_programming",
      "semester": 2,
      "courseName": "Podstawy programowania",
      "multipleCorrect": false
    },
    {
      "id": 81,
      "question": "Jak wygląda poprawna wartość w Haskellu dla typu: data Tree a = L a | N (Tree a) a (Tree a)",
      "options": [
        {
          "key": "a",
          "text": "Tree 5 Nil Nil",
          "correct": false
        },
        {
          "key": "b",
          "text": "N (L 4) 5 (L '4')",
          "correct": false
        },
        {
          "key": "c",
          "text": "N (L 4) 5 (L 4)",
          "correct": true
        },
        {
          "key": "d",
          "text": "N (L '4') '5' (L '4')",
          "correct": true
        }
      ],
      "topic": "functional_programming",
      "semester": 2,
      "courseName": "Podstawy programowania",
      "multipleCorrect": true
    },
    {
      "id": 82,
      "question": "Haskell jest językiem opartym o paradygmat:",
      "options": [
        {
          "key": "a",
          "text": "funkcyjny",
          "correct": true
        },
        {
          "key": "b",
          "text": "strukturalny",
          "correct": false
        },
        {
          "key": "c",
          "text": "imperatywny",
          "correct": false
        },
        {
          "key": "d",
          "text": "obiektowy",
          "correct": false
        }
      ],
      "topic": "functional_programming",
      "semester": 2,
      "courseName": "Podstawy programowania",
      "multipleCorrect": false
    },
    {
      "id": 83,
      "question": "Zaznacz prawdziwe zdania odnoszące się do programowania funkcyjnego:",
      "options": [
        {
          "key": "a",
          "text": "w programowaniu funkcyjnym koncepcja funkcji jest taka, jak w algebrze",
          "correct": true
        },
        {
          "key": "b",
          "text": "programowanie funkcyjne opiera się na rachunku lambda",
          "correct": true
        },
        {
          "key": "c",
          "text": "dobrym nawykiem w programowaniu funkcyjnym jest, aby zmienne były niemutowalne",
          "correct": true
        },
        {
          "key": "d",
          "text": "w programowaniu funkcyjnym możemy korzystać jedynie z wbudowanych typów danych",
          "correct": false
        },
        {
          "key": "e",
          "text": "funkcyjny styl programowania można uprawiać w ograniczonym zakresie w językach imperatywnych jak C albo JavaScript",
          "correct": true
        },
        {
          "key": "f",
          "text": "funkcyjnymi językami programowania są: Erlang, Haskell, C#, Perl",
          "correct": false
        },
        {
          "key": "g",
          "text": "można używać funkcyjnego stylu programowania w języku JavaScript",
          "correct": true
        },
        {
          "key": "h",
          "text": "niektóre języki imperatywne zostały wyposażone w konstrukcje z języków funkcyjnych",
          "correct": true
        }
      ],
      "topic": "functional_programming",
      "semester": 2,
      "courseName": "Podstawy programowania",
      "multipleCorrect": true
    },
    {
      "id": 84,
      "question": "Funkcje wyższego rzędu w programowaniu funkcyjnym to:",
      "options": [
        {
          "key": "a",
          "text": "funkcje zwracające inne funkcje jako rezultat obliczeń",
          "correct": true
        },
        {
          "key": "b",
          "text": "funkcje, które przyjmują inne funkcje jako parametry",
          "correct": true
        },
        {
          "key": "c",
          "text": "potoczne określenie funkcji trudnych w implementacji",
          "correct": false
        }
      ],
      "topic": "functional_programming",
      "semester": 2,
      "courseName": "Podstawy programowania",
      "multipleCorrect": true
    },
    {
      "id": 85,
      "question": "Jaki mechanizm w językach funkcyjnych pozwala na wykonanie operacji na zbiorze danych?",
      "options": [
        {
          "key": "a",
          "text": "iteracja",
          "correct": false
        },
        {
          "key": "b",
          "text": "rekurencja",
          "correct": true
        },
        {
          "key": "c",
          "text": "funkcje specyficzne dla języka",
          "correct": true
        },
        {
          "key": "d",
          "text": "warunkowy skok do etykiety",
          "correct": false
        },
        {
          "key": "e",
          "text": "pętla",
          "correct": false
        }
      ],
      "topic": "functional_programming",
      "semester": 2,
      "courseName": "Podstawy programowania",
      "multipleCorrect": true
    },
    {
      "id": 86,
      "question": "Aby sprawdzić, czy dwa obiekty typu String w języku Java mają taką samą zawartość, można:",
      "options": [
        {
          "key": "a",
          "text": "użyć metody equals()",
          "correct": true
        },
        {
          "key": "b",
          "text": "==",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 87,
      "question": "Który z poniższych fragmentów kodu w języku Java sprawdza, czy obiekt wskazywany przez referencję xyz należy do klasy XYZ?",
      "options": [
        {
          "key": "a",
          "text": "if (xyz instanceof XYZ)",
          "correct": true
        },
        {
          "key": "b",
          "text": "if (xyz.dynamicCastTo(XYZ.class) != null)",
          "correct": false
        },
        {
          "key": "c",
          "text": "XYZ.class.isInstance(xyz)",
          "correct": true
        },
        {
          "key": "d",
          "text": "XYZ.class.isAssignableFrom(xyz.getClass())",
          "correct": true
        }
      ],
      "topic": "java",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": true
    },
    {
      "id": 88,
      "question": "Tablica w języku Java jest zadeklarowana jako: int tab[] = new int[]{3, 2, 1, 0}; Który z fragmentów kodu poprawnie wypisze jej elementy?",
      "options": [
        {
          "key": "a",
          "text": "for (int i: tab) System.out.println(tab[i] + \" \");",
          "correct": false
        },
        {
          "key": "b",
          "text": "for (int i = 0; i < tab.length; i++) System.out.println(tab[i] + \" \");",
          "correct": true
        },
        {
          "key": "c",
          "text": "for (int i: tab) System.out.println(i + \" \");",
          "correct": true
        }
      ],
      "topic": "java",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": true
    },
    {
      "id": 89,
      "question": "Które zdanie opisujące własności klas w języku Java jest prawdziwe?",
      "options": [
        {
          "key": "a",
          "text": "aby zaznaczyć, że klasa dziedziczy po kilku klasach, należy podać ich listę po słowie kluczowym extends, np. class D extends A, B, C {}",
          "correct": false
        },
        {
          "key": "b",
          "text": "dla każdej klasy w języku Java możliwe jest zdefiniowanie klasy potomnej",
          "correct": false
        },
        {
          "key": "c",
          "text": "klasa może implementować wiele interfejsów",
          "correct": true
        },
        {
          "key": "d",
          "text": "w języku Java zawsze bezpośrednio możemy dziedziczyć po jednej klasie",
          "correct": true
        }
      ],
      "topic": "java",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": true
    },
    {
      "id": 90,
      "question": "W jaki sposób usuwane są obiekty w języku Java?",
      "options": [
        {
          "key": "a",
          "text": "usuwa się je przez przekazanie referencji do usuwanego obiektu do metody System.gc()",
          "correct": false
        },
        {
          "key": "b",
          "text": "nie są programowo usuwane, to środowisko wykonawcze podejmuje decyzje czy i kiedy je usunąć",
          "correct": true
        }
      ],
      "topic": "java",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 91,
      "question": "Które z poniższych stwierdzeń odnoszące się do klas wewnętrznych i zagnieżdżonych w języku Java są prawdziwe?",
      "options": [
        {
          "key": "a",
          "text": "w metodach klasy zagnieżdżonej (zadeklarowanej z modyfikatorem static) jest dostępna referencja Outer.this, gdzie Outer jest nazwą klasy zewnętrznej",
          "correct": false
        },
        {
          "key": "b",
          "text": "obiekt klasy wewnętrznej ma swój stan niezależny od innych obiektów powiązanych z obiektem klasy zewnętrznej",
          "correct": true
        },
        {
          "key": "c",
          "text": "klasy wewnętrzne muszą dziedziczyć po otaczających je klasach zewnętrznych",
          "correct": false
        },
        {
          "key": "d",
          "text": "klasa wewnętrzna (zadeklarowana bez modyfikatora static) nie ma dostępu do prywatnych zmiennych klasy zewnętrznej",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 92,
      "question": "W językach imperatywnych (również obiektowych) przy wyborze reprezentacji dla danych rzeczywistych (zmiennoprzecinkowych) pojawiają się problemy:",
      "options": [
        {
          "key": "a",
          "text": "wystąpienia nadmiaru",
          "correct": true
        },
        {
          "key": "b",
          "text": "wystąpienia niedomiaru",
          "correct": true
        },
        {
          "key": "c",
          "text": "dokładności",
          "correct": true
        }
      ],
      "topic": "c_cpp",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 93,
      "question": "Wskazania (pointers) w C, C++ używane są do reprezentowania (wskazywania):",
      "options": [
        {
          "key": "a",
          "text": "obszarów pamięci operacyjnej",
          "correct": true
        },
        {
          "key": "b",
          "text": "zmiennych złożonych",
          "correct": true
        },
        {
          "key": "c",
          "text": "zmiennych skalarnych",
          "correct": true
        },
        {
          "key": "d",
          "text": "funkcji i metod",
          "correct": true
        }
      ],
      "topic": "c_cpp",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 94,
      "question": "W jaki sposób można obliczyć długość tekstu przekazanego jako argument w poniższej funkcji w języku C? void foo(const char* txt) { ... }",
      "options": [
        {
          "key": "a",
          "text": "sizeof(txt)",
          "correct": false
        },
        {
          "key": "b",
          "text": "strlen(txt)",
          "correct": true
        },
        {
          "key": "c",
          "text": "txt.length()",
          "correct": false
        },
        {
          "key": "d",
          "text": "zliczając, ile znaków występuje w tekście od znaku na który wskazuje wskaźnik do znaku końca łańcucha znaków ('\\0')",
          "correct": true
        }
      ],
      "topic": "c_cpp",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 95,
      "question": "Co możesz powiedzieć o poniższej deklaracji w języku C? int t[10] = {1, 2, [4]=1};",
      "options": [
        {
          "key": "a",
          "text": "zgodnie ze standardem C99 spowoduje ona utworzenie tablicy zawierającej 10 elementów, z których 7 ma wartość 0",
          "correct": true
        },
        {
          "key": "b",
          "text": "da ona taki sam efekt, jak deklaracja: int t[] = {1, 2, 0, 0, 1}",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 96,
      "question": "W jaki sposób obliczyć długość tablicy w funkcji foo() w języku C? void foo(double f[]) { // dlugosc tablicy t? }",
      "options": [
        {
          "key": "a",
          "text": "nie da się obliczyć",
          "correct": true
        },
        {
          "key": "b",
          "text": "po wykonaniu poniższej instrukcji długość tablicy będzie umieszczona w zmiennej len: int len; for(len=0; t[len]; len++)",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 97,
      "question": "Która z implementacji funkcji zawierającej tablicę w języku C jest poprawna?",
      "options": [
        {
          "key": "a",
          "text": "int[] getTable() { int tab[10]; return tab; }",
          "correct": false
        },
        {
          "key": "b",
          "text": "int * getTable(int n) { return (int*) malloc(n * sizeof(int)); }",
          "correct": true
        },
        {
          "key": "c",
          "text": "int * getTable(int n) { return (int*) calloc(n, sizeof(n)); }",
          "correct": true
        }
      ],
      "topic": "c_cpp",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 98,
      "question": "Przeanalizuj poniższą deklarację w języku C: int (*x)(int, int);",
      "options": [
        {
          "key": "a",
          "text": "zmienna x jest dwuwymiarową tablicą wskaźników typu int* o zmiennym rozmiarze",
          "correct": false
        },
        {
          "key": "b",
          "text": "deklaracja jest niezgodna ze składnią języka",
          "correct": false
        },
        {
          "key": "c",
          "text": "zmienna x jest wskaźnikiem na funkcję przyjmującą dwa argumenty typu int, zwracającą wartość typu int",
          "correct": true
        }
      ],
      "topic": "c_cpp",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 99,
      "question": "Które stwierdzenia dotyczące operatorów w języku C/C++ są poprawne:",
      "options": [
        {
          "key": "a",
          "text": "operatory addytywne mają mniejszy priorytet niż multiplikatywne",
          "correct": true
        },
        {
          "key": "b",
          "text": "wyrażenie z == ++z jest zawsze fałszywe dla zmiennej z typu int",
          "correct": false
        },
        {
          "key": "c",
          "text": "żadne z pozostałych",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 100,
      "question": "Dzięki konwencji wywołania funkcji w języku C/C++ znanej jako __cdecl możliwa jest implementacja funkcji o zmiennej liczbie argumentów, jak printf(). Które stwierdzenia charakteryzujące funkcje typu __cdecl są prawdziwe?",
      "options": [
        {
          "key": "a",
          "text": "w wygenerowanym kodzie wywołania funkcji argumenty umieszczane są na stosie od końca, dzięki temu na szczycie stosu jest jej pierwszy argument i analizując jego zawartość można określić spodziewaną liczbę argumentów wywołania",
          "correct": true
        },
        {
          "key": "b",
          "text": "w języku C kompilator może utworzyć kod wywołania funkcji typu __cdecl nie mając żadnych informacji o typach jej parametrów",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 101,
      "question": "W jaki sposób przekazywany jest parametr będący tablicą do funkcji w języku C, np.: int main(int argc, char* argv[]) { ... }",
      "options": [
        {
          "key": "a",
          "text": "cała zawartość tablicy kopiowana jest na stos i funkcja działa na kopii tablicy",
          "correct": false
        },
        {
          "key": "b",
          "text": "na stos przekazywany jest adres pierwszego elementu tablicy",
          "correct": true
        },
        {
          "key": "c",
          "text": "tablice są zawsze przekazywane do funkcji jako wskaźnik",
          "correct": true
        },
        {
          "key": "d",
          "text": "tablice są zawsze przekazywane do funkcji przez referencję",
          "correct": false
        },
        {
          "key": "e",
          "text": "funkcja działa na kopii tablicy, dla której pamięć przydzielona jest na stercie; do funkcji trafia adres kopii tablicy",
          "correct": false
        },
        {
          "key": "f",
          "text": "na stosie umieszczany jest pierwszy element tablicy",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 6,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 102,
      "question": "Algorytmy optymalizacji statycznej:",
      "options": [
        {
          "key": "a",
          "text": "metoda simpleksu Neldera-Meada jest metodą bezgradientową",
          "correct": true
        },
        {
          "key": "b",
          "text": "metoda Newtona wymaga obliczania w każdym kroku gradientu i hesjanu",
          "correct": true
        },
        {
          "key": "c",
          "text": "metody z funkcją kary (penalty methods) stosuje się w przypadkach optymalizacji bez ograniczeń",
          "correct": false
        },
        {
          "key": "d",
          "text": "metoda najszybszego spadku wymaga obliczania hesjanu",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 103,
      "question": "Dla n + 1 wartości zmiennej niezależnej ^^x_i^^, i = 0, 1, ..., n, ^^x_{i-1} < x_i^^, i = 1, 2, ..., n wykonano pomiary i otrzymano n + 1 wartości ^^y_i^^. Zależność wielkości mierzonej od x aproksymowano wielomianem ^^W_m(x) = \\sum_{j=0}^m a_{j, m}x^j^^. Zaznacz prawdziwe implikacje.",
      "options": [
        {
          "key": "a",
          "text": "m = n => ^^E_m = 0^^",
          "correct": true
        },
        {
          "key": "b",
          "text": "m > n => ^^E_m < 0^^",
          "correct": false
        },
        {
          "key": "c",
          "text": "^^E_m > 0^^ => n > m",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 104,
      "question": "Dla n + 1 wartości zmiennej niezależnej ^^x_i^^, i = 0, 1, ..., n wykonano pomiary i otrzymano n + 1 wartości ^^y_i^^. Zależność wielkości mierzonej od x aproksymowano wielomianem ^^W_m(x) = \\sum_{j=0}^m a_{j,m}x^j^^. Rozważamy 3 sposoby obliczania błędu aproksymacji ^^E_m^^: 1. ^^E_m = \\min_{a_{0,m}, a_{1, m}, ..., a_{m, m}} \\sum_{i=0}^n |y_i-W_m(x_i)|^^ 2. ^^E_m = \\min_{a_{0,m}, a_{1, m}, ..., a_{m, m}} \\sum_{i=0}^n (y_i-W_m(x_i))^2^^ 3. ^^E_m = \\min_{a_{0,m}, a_{1, m}, ..., a_{m, m}} \\max_{i=0, 1, ..., n} |y_i-W_m(x_i)|^^ Obliczanie współczynników ^^a_i^^ można sprowadzić do zagadnienia liniowego:",
      "options": [
        {
          "key": "a",
          "text": "w przypadku 1",
          "correct": true
        },
        {
          "key": "b",
          "text": "w przypadku 2",
          "correct": true
        },
        {
          "key": "c",
          "text": "w przypadku 3",
          "correct": false
        },
        {
          "key": "d",
          "text": "w żadnym z tych przypadków",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 105,
      "question": "Dla tych samych danych eksperymentalnych podanych poniżej wyznaczono 3 funkcje aproksymujące. i | 0 1 2 x | 2 4 6 y | 1 2 1 W każdym przypadku k = 1, 2, 3 funkcja aproksymująca miała taką samą postać ^^f_k(x) = a_k * x + b_k^^, ale użyto innego kryterium jakości aproksymacji: 1. Dla k = 1: ^^min_{a_1, b_1} \\sum_{i=0}^2 |y_i-f_1(x_i)|^^ 2. Dla k = 2: ^^min_{a_2, b_2} \\sum_{i=0}^2 (y_i-f_2(x_i))^2^^ 3. Dla k = 3: ^^min_{a_3, b_3} max_{i=0,1,2} |y_i-f_3(x_i)|^^ Zaznacz prawidłowe odpowiedzi.",
      "options": [
        {
          "key": "a",
          "text": "a_1 = a_2 = a_3, b_1 = b_2 = b_3",
          "correct": false
        },
        {
          "key": "b",
          "text": "a_1 = a_2 = a_3, b_1 != b_2 != b_3",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 106,
      "question": "Rozważmy funkcję kwadratową n zmiennych: ^^f(x) = x^TAx + b^Tx + c^^ A jest macierzą (n x n), b wektorem (n x 1) o stałych współczynnikach, c jest skalarem. Załóżmy, że macierz A jest dodatnio określona. Funkcja ^f ma minimum w punkcie ^^x_{min}^^. Rozważmy tylko 3 metody szukania minimum tej funkcji: simpleksu Neldera-Meada, najszybszego spadku (steepest descent) oraz Newtona. Startujemy z dowolnego punktu ^^x_0^^, różnym od ^^x_{min}^^.",
      "options": [
        {
          "key": "a",
          "text": "metoda Newtona gwarantuje znalezienie minimum funkcji f w pierwszym kroku",
          "correct": true
        },
        {
          "key": "b",
          "text": "metoda najszybszego spadku gwarantuje znalezienie minimum funkcji f w pierwszym kroku",
          "correct": false
        },
        {
          "key": "c",
          "text": "metoda simpleksu Neldera-Meada gwarantuje znalezienie minimum funkcji f w pierwszym kroku",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 107,
      "question": "Czy obliczanie parametrów (współczynników) funkcji aproksymującej można sprowadzić do rozwiązywania układu równań?",
      "options": [
        {
          "key": "a",
          "text": "tak, ale wtedy i tylko wtedy, gdy funkcja aproksymująca jest funkcją liniową względem zmiennej niezależnej",
          "correct": false
        },
        {
          "key": "b",
          "text": "tak, ale wtedy i tylko wtedy, gdy funkcja aproksymująca jest wielomianem (zmiennej niezależnej)",
          "correct": true
        },
        {
          "key": "d",
          "text": "nie można",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 108,
      "question": "Do aproksymacji zbioru punktów ^^P = \\{ (x_i, y_i) | i = 0, 1, ..., n \\}^^ używamy funkcji ^^f^{(k)}(x;a_{k,j}|j=0,1,...,m)^^. ^^a_{k, j}^^ to parametry funkcji. Stosując 3 różne kryteria jakości aproksymacji (miary błędu aproksymacji) podane poniżej otrzymujemy trzy różne funkcje aproksymujące ^^f_k(x)^^, k = 1, 2, 3 dla tej samej wartości m, a różniące się między sobą wartościami parametrów ^^a_{k, j}^^. 1. k = 1: ^^min \\sum_{i=0}^n |y_i-f^{(1)}(x_i)|^^ 2. k = 2: ^^min \\sum_{i=0}^n (f_i-f^{(2)}(x_i))^2^^ 3. k = 3: ^^min^^ ^^max_{i=0,1,...,n} |y_i-f^{(3)}(x_i)|^^ Niech ^^\\Delta^{(k)}_{max}^^ oznacza odległość (w sensie metryki maksimum) k-tej funkcji aproksymującej ^^f_k^^ od najbardziej oddalonego punktu ze zbioru P, tzn. ^^\\Delta^{(k)}_{max} = \\max_{i=0,...,n}|y_i-f^{(k)}(x_i)|^^. Zaznacz prawdziwe relacje:",
      "options": [
        {
          "key": "a",
          "text": "^^\\Delta_{\\max}^{(1)} \\geq \\Delta_{\\max}^{(2)}^^",
          "correct": true
        },
        {
          "key": "b",
          "text": "^^\\Delta_{\\max}^{(1)} \\leq \\Delta_{\\max}^{(2)}^^",
          "correct": false
        },
        {
          "key": "c",
          "text": "^^\\Delta_{\\max}^{(3)} \\leq \\Delta_{\\max}^{(2)}^^",
          "correct": true
        },
        {
          "key": "d",
          "text": "^^\\Delta_{\\max}^{(3)} \\leq \\Delta_{\\max}^{(1)}^^",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 109,
      "question": "Warunkiem koniecznym i wystarczającym zbieżności metod iteracyjnych prostych (takich jak metoda Jacobiego czy metoda Gaussa-Seidla) rozwiązywania układów równań liniowych jest:",
      "options": [
        {
          "key": "a",
          "text": "promień spektralny macierzy iterowanej w danej metodzie jest zawsze mniejszy od 1",
          "correct": true
        },
        {
          "key": "b",
          "text": "promień spektralny macierzy iterowanej w danej metodzie jest zawsze większy od 1",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 110,
      "question": "Do metod nazywanych metodami dokładnymi rozwiązywania układów równań liniowych zalicza się:",
      "options": [
        {
          "key": "a",
          "text": "metoda Jacobiego",
          "correct": false
        },
        {
          "key": "b",
          "text": "metoda rozkładu LU",
          "correct": true
        },
        {
          "key": "c",
          "text": "metoda Gaussa",
          "correct": true
        },
        {
          "key": "d",
          "text": "metoda Jordana",
          "correct": true
        },
        {
          "key": "e",
          "text": "eliminacja Gaussa z wyborem elementu głównego",
          "correct": true
        },
        {
          "key": "f",
          "text": "metoda Cramera",
          "correct": true
        },
        {
          "key": "g",
          "text": "metoda SOR (Successive Over-Relaxation)",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 111,
      "question": "Które z poniżej wymienionych zagadnień numerycznych wykorzystują właściwości przybliżania funkcji wielomianem interpolującym:",
      "options": [
        {
          "key": "a",
          "text": "metoda siecznych, metoda stycznych szukania miejsc zerowych funkcji",
          "correct": false
        },
        {
          "key": "b",
          "text": "obliczanie całki oznaczonej funkcji za pomocą kwadratur Newtona-Cotesa",
          "correct": true
        },
        {
          "key": "c",
          "text": "równania różniczkowe zwyczajne",
          "correct": true
        },
        {
          "key": "d",
          "text": "rozwiązywanie układów równań metodami iteracyjnymi",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 112,
      "question": "Wielomiany sklejane (ang. spline) trzeciego stopnia muszą spełniać następujące warunki w punktach sklejeń:",
      "options": [
        {
          "key": "a",
          "text": "przechodzenie funkcji interpolującej przez węzły interpolacji",
          "correct": true
        },
        {
          "key": "b",
          "text": "ciągłość pochodnej funkcji interpolującej",
          "correct": true
        },
        {
          "key": "c",
          "text": "ciągłość funkcji interpolującej",
          "correct": true
        },
        {
          "key": "d",
          "text": "ciągłość drugiej pochodnej funkcji interpolującej",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 113,
      "question": "Wskaż zdania prawdziwe dotyczące zagadnienia interpolacji wielomianowej z wykorzystaniem jednomianów (tzw. bazy naturalnej):",
      "options": [
        {
          "key": "a",
          "text": "jest to zadanie dobrze uwarunkowane",
          "correct": false
        },
        {
          "key": "b",
          "text": "ma zdecydowanie lepsze właściwości numeryczne niż metoda Lagrange'a",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest to zadanie źle uwarunkowane",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 114,
      "question": "Błędy związane z ograniczeniem nieskończonego ciągu wymaganych obliczeń do skończonej liczby działań nazywamy:",
      "options": [
        {
          "key": "a",
          "text": "błędami zaokrągleń (ang. rounding errors)",
          "correct": false
        },
        {
          "key": "b",
          "text": "błędami niedomiaru (ang. underflow errors)",
          "correct": false
        },
        {
          "key": "c",
          "text": "błędami obcięcia (ang. truncation errors)",
          "correct": true
        },
        {
          "key": "d",
          "text": "błędami nadmiaru (ang. overflow errors)",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 115,
      "question": "Jeśli niewielkie względne zaburzenia danych wejściowych powodują niewielkie względne zmiany wyników, to wówczas:",
      "options": [
        {
          "key": "a",
          "text": "współczynnik uwarunkowania osiąga wysoką wartość",
          "correct": false
        },
        {
          "key": "b",
          "text": "współczynnik uwarunkowania osiąga niską wartość",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 116,
      "question": "Warunkami wystarczającymi, gwarantującymi zbieżność poszukiwania miejsc zerowych funkcji f(x) metodą bisekcji są:",
      "options": [
        {
          "key": "a",
          "text": "funkcja f(x) jest ciągła w przedziale domkniętym [a, b]",
          "correct": true
        },
        {
          "key": "b",
          "text": "pierwsza i druga pochodna f(x) istnieją i są ciągłe w przedziale domkniętym [a, b]",
          "correct": false
        },
        {
          "key": "c",
          "text": "pierwsza i druga pochodna mają stały znak w całym przedziale",
          "correct": false
        },
        {
          "key": "d",
          "text": "na końcach przedziału [a, b] wartości funkcji f(x) przyjmują przeciwne znaki, czyli zachodzi f(a) * f(b) < 0",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 117,
      "question": "Stosując algorytm stycznych poszukiwania jednokrotnego miejsca zerowego funkcji f(x) w przedziale domkniętym [a, b] w dostatecznej bliskości pierwiastka uzyskujemy zbieżność:",
      "options": [
        {
          "key": "a",
          "text": "kwadratową",
          "correct": true
        },
        {
          "key": "b",
          "text": "wykładniczą",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 118,
      "question": "Do całkowania numerycznego używa się m. in. kwadratur Newtona-Cotesa. Do prostych kwadratur Newtona-Cotesa należą:",
      "options": [
        {
          "key": "a",
          "text": "metoda Eulera",
          "correct": false
        },
        {
          "key": "b",
          "text": "metoda Romberga",
          "correct": false
        },
        {
          "key": "c",
          "text": "metoda trapezów",
          "correct": true
        },
        {
          "key": "d",
          "text": "metoda Simpsona",
          "correct": true
        },
        {
          "key": "e",
          "text": "reguła 3/8",
          "correct": true
        },
        {
          "key": "f",
          "text": "metoda Boole'a",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 119,
      "question": "Efekt Rungego jest charakterystyczny dla następujących metod interpolacji:",
      "options": [
        {
          "key": "a",
          "text": "interpolacji funkcjami sklejanymi 1 stopnia dla węzłów równoodległych",
          "correct": false
        },
        {
          "key": "b",
          "text": "interpolacji funkcjami sklejanymi 3 stopnia dla węzłów równoodległych",
          "correct": false
        },
        {
          "key": "c",
          "text": "interpolacji metodą Lagrange'a (wielomianowej) dla węzłów równoodległych",
          "correct": true
        },
        {
          "key": "d",
          "text": "interpolacji metodą Lagrange'a dla węzłów będących zerami wielomianów Czebyszewa",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 120,
      "question": "Które zdania dotyczące metody eliminacji Gaussa rozwiązywania układów równań są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "jest to metoda iteracyjna",
          "correct": false
        },
        {
          "key": "b",
          "text": "jest to metoda dokładna",
          "correct": true
        },
        {
          "key": "c",
          "text": "przekształca macierz do postaci macierzy schodkowej",
          "correct": true
        },
        {
          "key": "d",
          "text": "nie wymaga przekształcenia układu równań do postaci z macierzą trójkątną górną",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 121,
      "question": "Aby wyeliminować lub znacząco ograniczyć efekt Rungego przy zadaniu interpolacji można:",
      "options": [
        {
          "key": "a",
          "text": "zastosować interpolację funkcjami sklejanymi zamiast metody Lagrange'a",
          "correct": true
        },
        {
          "key": "b",
          "text": "zastosować interpolację z węzłami gęściej upakowanymi na końcach przedziału",
          "correct": true
        },
        {
          "key": "c",
          "text": "zastosować do interpolacji miejsca zerowa wielomianów Czebyszewa",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 122,
      "question": "Dokładność reprezentacji zmiennoprzecinkowej jest określona przez:",
      "options": [
        {
          "key": "a",
          "text": "liczbę bitów mantysy",
          "correct": true
        },
        {
          "key": "b",
          "text": "liczbę bitów mantysy i wykładnika",
          "correct": false
        },
        {
          "key": "c",
          "text": "zakres wykładnika",
          "correct": false
        },
        {
          "key": "d",
          "text": "liczbę bitów mantysy i zakres wykładnika",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 123,
      "question": "Efekt Rungego w interpolacji wielomianowej to:",
      "options": [
        {
          "key": "a",
          "text": "wynik wyboru złej funkcji interpolującej",
          "correct": false
        },
        {
          "key": "b",
          "text": "wynik braku jednoznaczności rozwiązania zadania interpolacji",
          "correct": false
        },
        {
          "key": "c",
          "text": "konsekwencja arytmetyki zmiennoprzecinkowej",
          "correct": false
        },
        {
          "key": "d",
          "text": "wynik błędu metody",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 124,
      "question": "Funkcje sklejane stopnia m na przedziale [a, b]:",
      "options": [
        {
          "key": "a",
          "text": "są ciągłe wraz z (m-1) pochodnymi na [a, b]",
          "correct": true
        },
        {
          "key": "b",
          "text": "są ciągłe wraz z (m+1) pochodnymi na [a, b]",
          "correct": false
        },
        {
          "key": "c",
          "text": "są używane tylko do interpolacji przedziałowej",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie są przydatne do interpolowania funkcji periodycznych",
          "correct": false
        },
        {
          "key": "e",
          "text": "są jednoznacznie określone przez podanie warunków brzegowych",
          "correct": false
        },
        {
          "key": "f",
          "text": "nadają się tylko do interpolowania przedziałowego funkcji z nieciągłymi osobliwościami",
          "correct": false
        },
        {
          "key": "g",
          "text": "są przydatne nie tylko do interpolacji, ale też do aproksymacji",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 125,
      "question": "Wybierz poprawną odpowiedź:",
      "options": [
        {
          "key": "a",
          "text": "interpolacja z węzłami będącymi zerami wielomianu Czebyszewa odpowiedniego stopnia eliminuje efekt Rungego",
          "correct": true
        },
        {
          "key": "b",
          "text": "przybliżenia Pade to technika aproksymacji średniokwadratowej",
          "correct": false
        },
        {
          "key": "c",
          "text": "funkcje sklejane nie mogą być wykorzystane do aproksymacji średniokwadratowej ze względu na postać minimalizowanej normy",
          "correct": false
        },
        {
          "key": "d",
          "text": "aproksymacja średniokwadratowa polega na minimalizacji normy Czebyszewa",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 126,
      "question": "Metoda Newtona-Raphsona rozwiązywania równań nieliniowych:",
      "options": [
        {
          "key": "a",
          "text": "wykorzystuje niejawnie przyspieszenie Aitkena",
          "correct": false
        },
        {
          "key": "b",
          "text": "jest przykładem metody iteracyjnej o stałym punkcie",
          "correct": true
        },
        {
          "key": "c",
          "text": "jest przykładem metody interpolacyjnej",
          "correct": false
        },
        {
          "key": "d",
          "text": "ma rząd zbieżności równy 1",
          "correct": false
        },
        {
          "key": "e",
          "text": "ma rząd zbieżności równy 2",
          "correct": true
        },
        {
          "key": "f",
          "text": "jest szybciej zbieżna niż metoda siecznych",
          "correct": true
        },
        {
          "key": "g",
          "text": "jest szybciej zbieżna niż metoda bisekcji",
          "correct": true
        },
        {
          "key": "h",
          "text": "nie może być uogólniona dla układów równań nieliniowych",
          "correct": false
        },
        {
          "key": "i",
          "text": "wymaga znajomości pochodnej funkcji",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 127,
      "question": "Metoda eliminacji Gaussa rozwiązywania układów równań liniowych:",
      "options": [
        {
          "key": "a",
          "text": "wymaga wyszukiwania elementu wiodącego i polega na przekształceniu macierzy do postaci trójkątnej górnej",
          "correct": true
        },
        {
          "key": "b",
          "text": "polega na doprowadzeniu macierzy do postaci diagonalnej",
          "correct": false
        },
        {
          "key": "c",
          "text": "ma złożoność ^^O(n^3)^^, gdzie ^^n^^ - liczba równań",
          "correct": true
        },
        {
          "key": "d",
          "text": "jest przykładem metody iteracyjnej niestacjonarnej",
          "correct": false
        },
        {
          "key": "e",
          "text": "ma złożoność ^^O(n^2)^^, gdzie ^^n^^ - liczba równań",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 128,
      "question": "Metody dekompozycji LU:",
      "options": [
        {
          "key": "a",
          "text": "mają znacznie lepsze własności numeryczne niż metoda eliminacji Gaussa",
          "correct": true
        },
        {
          "key": "b",
          "text": "należą do rodziny metod iteracyjnych niestacjonarnych",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie wymagają wyszukiwania elementu wiodącego",
          "correct": false
        },
        {
          "key": "d",
          "text": "są przydatne tylko do rozwiązywania układów równań z macierzą symetryczną dodatnio określoną",
          "correct": false
        },
        {
          "key": "e",
          "text": "mają lepszą złożoność obliczeniową niż metoda Gaussa, gdyż nie wymagają wyszukiwania elementu wiodącego",
          "correct": false
        },
        {
          "key": "f",
          "text": "są metodami iteracyjnymi stacjonarnymi",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 129,
      "question": "Wybierz poprawne zdania opisujące metody minimalizacji:",
      "options": [
        {
          "key": "a",
          "text": "wzór Davidona-Fletchera-Powella jest podstawą metody zmiennej metryki",
          "correct": true
        },
        {
          "key": "b",
          "text": "metoda sprzężonych kierunków jest przykładem ogólnej metody poszukiwania minimum globalnego",
          "correct": false
        },
        {
          "key": "c",
          "text": "metoda największego spadku jest przykładem metody poszukiwania minimum globalnego",
          "correct": false
        },
        {
          "key": "d",
          "text": "metoda simpleksów należy do metod gradientowych",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 130,
      "question": "Szybka transformata Fouriera:",
      "options": [
        {
          "key": "a",
          "text": "jest możliwa tylko wtedy, gdy liczba punktów jest całkowitą potęgą 2",
          "correct": false
        },
        {
          "key": "b",
          "text": "ma złożoność obliczeniową ^^O(n)^^, gdzie ^^n^^ - liczba węzłów",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest realizacją wzoru całkowego Fouriera na architekturach równoległych",
          "correct": false
        },
        {
          "key": "d",
          "text": "polega na zamianie pojedynczej transformaty Fouriera na sumę transformat Fouriera",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 131,
      "question": "Podejście wariacyjne do rozwiązywania równań różniczkowych:",
      "options": [
        {
          "key": "a",
          "text": "nie nadaje się do obliczeń numerycznych",
          "correct": false
        },
        {
          "key": "b",
          "text": "polega na tym, że szukamy funkcji minimalizującej odpowiedni funkcjonał",
          "correct": true
        },
        {
          "key": "c",
          "text": "polega na wprowadzeniu specjalnej siatki całkowania",
          "correct": false
        },
        {
          "key": "d",
          "text": "polega na uzmiennieniu położeń części punktów siatki",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 132,
      "question": "Wymagania stawiane schematom rozwiązywania numerycznego zagadnienia początkowego to:",
      "options": [
        {
          "key": "a",
          "text": "jawne uwzględnienie warunków brzegowych",
          "correct": false
        },
        {
          "key": "b",
          "text": "wprowadzenie siatki przestrzennej zgodnej z siatką czasową",
          "correct": false
        },
        {
          "key": "c",
          "text": "zgodność aproksymacji różnicowej, dokładność, stabilność, efektywność czasowa i pamięciowa",
          "correct": true
        },
        {
          "key": "d",
          "text": "algorytm powinien mieć względnie małe wskaźniki uwarunkowania",
          "correct": false
        },
        {
          "key": "e",
          "text": "współczynnik propagacji błędu < 1, zgodność aproksymacji różnicowej",
          "correct": true
        },
        {
          "key": "f",
          "text": "wskaźniki uwarunkowania powinny mieć takie same wartości w każdej iteracji algorytmu",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 133,
      "question": "Zaletami prowadzenia transmisji w trybie pełnego dupleksu w standardzie Ethernet są:",
      "options": [
        {
          "key": "a",
          "text": "całkowita likwidacja kolizji w segmencie sieci",
          "correct": true
        },
        {
          "key": "b",
          "text": "możliwość dwukrotnego zwiększenia sumarycznej przepustowości sieci",
          "correct": true
        },
        {
          "key": "c",
          "text": "brak ograniczenia długości medium transmisyjnego w segmencie warstwy fizycznej wynikającego z wymogów protokołu CSMA/CD",
          "correct": true
        },
        {
          "key": "d",
          "text": "możliwości wykorzystania urządzeń hub",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 134,
      "question": "Model odniesienia OSI/ISO:",
      "options": [
        {
          "key": "a",
          "text": "jest modelem czterowarstwowym",
          "correct": false
        },
        {
          "key": "b",
          "text": "definiuje standardy w ramach każdej warstwy (np. protokół IP w warstwie sieciowej)",
          "correct": false
        },
        {
          "key": "c",
          "text": "określa zadania poszczególnych warstw",
          "correct": true
        },
        {
          "key": "d",
          "text": "pozwala na niezależny rozwój sprzętu i oprogramowania w ramach poszczególnych warstw",
          "correct": true
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 135,
      "question": "Osiągnięcie przepustowości 1 Gb/s na kablu UTP kategorii 5e (tym samym, który jest używany w transmisji 100 Mb/s) w standardzie Ethernet jest:",
      "options": [
        {
          "key": "a",
          "text": "możliwe dzięki wykorzystaniu do transmisji wszystkich czterech par",
          "correct": true
        },
        {
          "key": "b",
          "text": "możliwe dzięki wykorzystaniu bardziej złożonego kodowania",
          "correct": true
        },
        {
          "key": "c",
          "text": "nie jest możliwe - wymaga kabla o lepszych parametrach",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie jest możliwe - taką przepustowość można osiągnąć tylko używając światłowodu",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 136,
      "question": "Kodowanie sygnałów w transmisji w sieciach komputerowych:",
      "options": [
        {
          "key": "a",
          "text": "wpływa na uzyskiwaną przepustowość",
          "correct": true
        },
        {
          "key": "b",
          "text": "jest zależne od wykorzystywanego medium",
          "correct": true
        },
        {
          "key": "c",
          "text": "jest przedmiotem zainteresowania warstwy sieciowej modelu OSI/ISO",
          "correct": false
        },
        {
          "key": "d",
          "text": "może pozwalać na osiągnięcie samosynchronizacji nadajnika i odbiornika",
          "correct": true
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 137,
      "question": "Istnienie ograniczenia maksymalnej odległości między komunikującymi się hostami wynika z:",
      "options": [
        {
          "key": "a",
          "text": "w ramach jednego segmentu sieci: wymogów protokołu warstwy łącza danych",
          "correct": true
        },
        {
          "key": "b",
          "text": "w ramach jednego segmentu sieci: parametrów medium fizycznego",
          "correct": true
        },
        {
          "key": "c",
          "text": "w ramach jednego segmentu sieci: wymogów protokołu warstwy sieciowej",
          "correct": false
        },
        {
          "key": "d",
          "text": "w ramach kilku segmentów sieci rozdzielonych przełącznicami: wymogów protokołu warstwy sieciowej",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 138,
      "question": "Wirtualne sieci lokalne:",
      "options": [
        {
          "key": "a",
          "text": "można definiować w oparciu o adresy fizyczne",
          "correct": true
        },
        {
          "key": "b",
          "text": "mogą być rozpięte na wielu urządzeniach warstwy drugiej modelu OSI/ISO",
          "correct": true
        },
        {
          "key": "c",
          "text": "stanowią mechanizm alternatywny dla budowy drzewa rozpinającego",
          "correct": false
        },
        {
          "key": "d",
          "text": "stanowią podstawowy mechanizm zapobiegania przeciążeniom mostka",
          "correct": false
        },
        {
          "key": "e",
          "text": "wyznaczają domenę rozgłoszeniową",
          "correct": true
        },
        {
          "key": "f",
          "text": "poprawiają bezpieczeństwo sieci",
          "correct": true
        },
        {
          "key": "g",
          "text": "można definiować w oparciu o adresy logiczne",
          "correct": true
        },
        {
          "key": "h",
          "text": "można definiować w oparciu o porty routera",
          "correct": false
        },
        {
          "key": "i",
          "text": "służą do dynamicznego uzyskiwania adresu IP",
          "correct": false
        },
        {
          "key": "j",
          "text": "mogą być używane zamiast protokołu ARP",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 139,
      "question": "Algorytm budowy drzewa rozpinającego:",
      "options": [
        {
          "key": "a",
          "text": "jest stosowany w przypadku mostków uczących się",
          "correct": true
        },
        {
          "key": "b",
          "text": "służy zapobieżeniu występowania zapętleń transmisji ramek",
          "correct": true
        },
        {
          "key": "c",
          "text": "jest jednym ze sposobów elekcji głównego routera w sieci",
          "correct": false
        },
        {
          "key": "d",
          "text": "służy zrównoważeniu obciążenia pomiędzy łączami o takich samych przepustowościach",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 140,
      "question": "Które warstwy modelu OSI/ISO są różne dla sieci WAN i LAN?",
      "options": [
        {
          "key": "a",
          "text": "fizyczna i łącza danych",
          "correct": true
        },
        {
          "key": "b",
          "text": "fizyczna i sieci",
          "correct": false
        },
        {
          "key": "c",
          "text": "łącza danych i sieci",
          "correct": false
        },
        {
          "key": "d",
          "text": "fizyczna, łącza danych i sieci",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 141,
      "question": "Dopisz, do czego jest wykorzystywany protokół ARP:",
      "options": [
        {
          "key": "a",
          "text": "uzyskiwania adresu IP",
          "correct": false
        },
        {
          "key": "b",
          "text": "uzyskiwania adresu MAC urządzenia spoza naszej sieci lokalnej",
          "correct": false
        },
        {
          "key": "c",
          "text": "określenie odwzorowania między adresami warstwy 3 i 2 modelu OSI/ISO",
          "correct": true
        },
        {
          "key": "d",
          "text": "wyznaczania ścieżki pakietu",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 142,
      "question": "Jeżeli dwie stacje znajdujące się w innych sieciach IP połączone są ze sobą dokładnie jednym routerem i chcą komunikować się ze sobą, to:",
      "options": [
        {
          "key": "a",
          "text": "obydwie stacje muszą posiadać jednakową maskę",
          "correct": false
        },
        {
          "key": "b",
          "text": "musi być uruchomiony mechanizm Proxy ARP na routerze",
          "correct": false
        },
        {
          "key": "c",
          "text": "na routerze konieczne jest dodanie pozycji routingu statycznego",
          "correct": false
        },
        {
          "key": "d",
          "text": "wymagane jest ustawienie na każdej stacji adresu IP",
          "correct": true
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 143,
      "question": "Protokół IP w wersji 4 posiada następujące cechy:",
      "options": [
        {
          "key": "a",
          "text": "pozwala na fragmentację pakietów w węzłach pośrednich i u nadawcy",
          "correct": true
        },
        {
          "key": "b",
          "text": "zawiera mechanizmy potwierdzania doręczenia pakietów",
          "correct": false
        },
        {
          "key": "c",
          "text": "umożliwia kontrolę nagłówka pakietu za pomocą sumy kontrolnej",
          "correct": true
        },
        {
          "key": "d",
          "text": "jest protokołem połączeniowym",
          "correct": false
        },
        {
          "key": "e",
          "text": "umożliwia komunikację priorytetową",
          "correct": true
        },
        {
          "key": "f",
          "text": "jest zawodny, ale każda utrata pakietu jest sygnalizowana",
          "correct": false
        },
        {
          "key": "g",
          "text": "posiada płaską adresację",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 144,
      "question": "W jakich przypadkach jest stosowany protokół ICMP?",
      "options": [
        {
          "key": "a",
          "text": "transmisji danych wysokopriorytetowych",
          "correct": false
        },
        {
          "key": "b",
          "text": "uzyskiwania informacji o konfiguracji sieci",
          "correct": true
        },
        {
          "key": "c",
          "text": "sygnalizacji sytuacji awaryjnych",
          "correct": true
        },
        {
          "key": "d",
          "text": "wyszukiwania odbiorców ruchu multicastowego",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 145,
      "question": "Jaki mechanizm uniemożliwia nieskończone krążenie ramek IP w sieci w przypadku wystąpienia pętli?",
      "options": [
        {
          "key": "a",
          "text": "mechanizm split-horizon",
          "correct": false
        },
        {
          "key": "b",
          "text": "mechanizm trigger-update",
          "correct": false
        },
        {
          "key": "c",
          "text": "pole TTL",
          "correct": true
        },
        {
          "key": "d",
          "text": "NAT",
          "correct": false
        },
        {
          "key": "e",
          "text": "STP",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 146,
      "question": "Parametr \"niezawodność łącza\" wchodzi w skład metryki protokołu routingu:",
      "options": [
        {
          "key": "a",
          "text": "EIGRP",
          "correct": true
        },
        {
          "key": "b",
          "text": "RIPv2",
          "correct": false
        },
        {
          "key": "c",
          "text": "IGRP",
          "correct": true
        },
        {
          "key": "d",
          "text": "OSPF",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 147,
      "question": "Protokół UDP:",
      "options": [
        {
          "key": "a",
          "text": "wprowadza mechanizmy fragmentacji dla danych użytkownika przekraczających maksymalny rozmiar datagramu UDP",
          "correct": false
        },
        {
          "key": "b",
          "text": "pozwala na grupowanie danych otrzymanych do wysłania w celu zoptymalizowania wykorzystania połączeń sieciowych",
          "correct": false
        },
        {
          "key": "c",
          "text": "stosuje porty jako adresy warstwy transportowej",
          "correct": true
        },
        {
          "key": "d",
          "text": "nie zabezpiecza przed duplikacją i zmianą kolejności datagramów",
          "correct": true
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 148,
      "question": "Adres typu broadcast (rozgłoszenia) IP w wersji 4, w której znajduje się host 110.104.1.10 i którą określa maska 255.0.0.0, to:",
      "options": [
        {
          "key": "a",
          "text": "110.104.1.10",
          "correct": false
        },
        {
          "key": "b",
          "text": "110.255.255.255",
          "correct": true
        },
        {
          "key": "c",
          "text": "110.104.1.255",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 149,
      "question": "Pole o nazwie Time To Live w datagramie IP, które zabezpiecza przed zapętleniem routowania datagramu pomiędzy kolejnymi routerami w sieci, zawiera:",
      "options": [
        {
          "key": "a",
          "text": "liczbę routerów, przez jakie datagram IP może zostać przekazany danej",
          "correct": true
        },
        {
          "key": "b",
          "text": "czas w sekundach, w którym datagram IP można jeszcze przekazywać dalej",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 150,
      "question": "Protokół UDP definiuje identyfikatory przesyłanych do hosta-odbiorcy datagramów zwane numerami portów, o długości:",
      "options": [
        {
          "key": "a",
          "text": "8 bitów",
          "correct": false
        },
        {
          "key": "b",
          "text": "32 bity",
          "correct": false
        },
        {
          "key": "c",
          "text": "4 bity",
          "correct": false
        },
        {
          "key": "d",
          "text": "16 bitów",
          "correct": true
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 151,
      "question": "Wartości adresu IPv6 oraz maski, określające wszystkie hosty w internecie, to:",
      "options": [
        {
          "key": "a",
          "text": "::/0",
          "correct": true
        },
        {
          "key": "b",
          "text": "0.0.0.0/0",
          "correct": false
        },
        {
          "key": "c",
          "text": "::/2000",
          "correct": false
        },
        {
          "key": "d",
          "text": "ff02::1",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 152,
      "question": "Istnienie zasady “Longest prefix match” w rutowaniu IP spowoduje, że adres docelowy 200.200.200.1 datagramu IP przy istnieniu w tablicy rutowania jednocześnie reguł o wzorcach i maskach (podano w notacji CIDR): 200.200.200.0/18, 200.200.200.0/20, 200.200.200.0/22, 200.200.200.0/24 zostanie dopasowany do:",
      "options": [
        {
          "key": "a",
          "text": "200.200.200.0/20",
          "correct": false
        },
        {
          "key": "b",
          "text": "200.200.200.0/18",
          "correct": false
        },
        {
          "key": "c",
          "text": "200.200.200.0/22",
          "correct": false
        },
        {
          "key": "d",
          "text": "200.200.200.0/24",
          "correct": true
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 153,
      "question": "Maksymalna długość pakietu IP wersja 4, licząc w bajtach, to:",
      "options": [
        {
          "key": "a",
          "text": "nie istnieje taki limit",
          "correct": false
        },
        {
          "key": "b",
          "text": "1500",
          "correct": false
        },
        {
          "key": "c",
          "text": "65535",
          "correct": true
        },
        {
          "key": "d",
          "text": "576",
          "correct": false
        },
        {
          "key": "e",
          "text": "1025",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 154,
      "question": "Router iBGP (internal Border Gateway Protocol), którego wprowadzenie do systemu rutowania iBGP umożliwia znaczne zredukowanie ilości otwartych sesji BGP między innymi routerami (rezygnację z tzw. full-mesh) nosi nazwę:",
      "options": [
        {
          "key": "a",
          "text": "BGP Mirror",
          "correct": false
        },
        {
          "key": "b",
          "text": "Route Reflector Client (RRC)",
          "correct": true
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 155,
      "question": "Liczba klas CoS (Class of Service), definiowanych przez podstawowy mechanizm implementacji QoS (Quality of Service) w Ethernet (czyli standard IEEE 802.1p), to:",
      "options": [
        {
          "key": "a",
          "text": "8",
          "correct": true
        },
        {
          "key": "b",
          "text": "255",
          "correct": false
        },
        {
          "key": "c",
          "text": "16",
          "correct": false
        },
        {
          "key": "d",
          "text": "65536",
          "correct": false
        },
        {
          "key": "e",
          "text": "7",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 156,
      "question": "Wariant protokołu STP (Spanning Tree Protocol, IEEE 802.1d) pozwalający w technologii Ethernet na logiczne pogrupowanie sieci VLAN i budowanie mniejszej liczby drzew rozpinających (po 1 drzewie dla każdej grupy) to:",
      "options": [
        {
          "key": "a",
          "text": "PVSTP (Per VLAN Spanning Tree Protocol)",
          "correct": false
        },
        {
          "key": "b",
          "text": "MSTP (Multiple Spanning Tree Protocol)",
          "correct": true
        },
        {
          "key": "c",
          "text": "RSTP (Rapid Spanning Tree Protocol)",
          "correct": false
        },
        {
          "key": "d",
          "text": "SPB (Shortest Path Bridging)",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 157,
      "question": "Nazwa procesu przekazywania wiedzy o trasach pomiędzy różnymi protokołami rutowania dynamicznego IP w routerach IP, to:",
      "options": [
        {
          "key": "a",
          "text": "redystrybucja",
          "correct": true
        },
        {
          "key": "b",
          "text": "IP Route Spoofing",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 158,
      "question": "Co określa standard IEEE 802.1Q?",
      "options": [
        {
          "key": "a",
          "text": "wirtualne sieci LAN (VLAN) budowane w środowisku transportującym ramki",
          "correct": true
        },
        {
          "key": "b",
          "text": "technologię tunelowania sieci VLAN o nazwie Q-in-Q",
          "correct": false
        },
        {
          "key": "c",
          "text": "private VLAN nadbudowaną nad Ethernet",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 159,
      "question": "Protokół umożliwiający konwersję adresu IP zdalnej stacji na jej adres MAC w Ethernet, to:",
      "options": [
        {
          "key": "a",
          "text": "SLIP (Serial Line Internet Protocol)",
          "correct": false
        },
        {
          "key": "b",
          "text": "ARP (Address Resolution Protocol)",
          "correct": true
        },
        {
          "key": "c",
          "text": "MLD (Multicast Listener Discovery)",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 160,
      "question": "Dwie podwarstwy definiowane w ramach warstwy drugiej modelu ISO-OSI to odpowiednio:",
      "options": [
        {
          "key": "a",
          "text": "FDDI i CDDI",
          "correct": false
        },
        {
          "key": "b",
          "text": "LAN i WAN",
          "correct": false
        },
        {
          "key": "c",
          "text": "LP (Link Pulse) i PHY (Physical)",
          "correct": false
        },
        {
          "key": "d",
          "text": "LLC (Logical Link Control) i MAC (Media Access Control)",
          "correct": true
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 161,
      "question": "Rodzaj obszaru (area) w domenie OSPF (Open Shortest Path First) nie otrzymującego żadnych informacji o zewnętrznych (external) trasach rutowania OSPF, to:",
      "options": [
        {
          "key": "a",
          "text": "backbone",
          "correct": false
        },
        {
          "key": "b",
          "text": "internal",
          "correct": false
        },
        {
          "key": "c",
          "text": "stub area",
          "correct": true
        },
        {
          "key": "d",
          "text": "NSSA",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 162,
      "question": "Parametr o nazwie “Wielkość okna” (Window size), którego wartość przekazywana jest w datagramach potwierdzenia TCP (Transmission Control Protocol Acknowledgment) w kierunku od odbiorcy do nadawcy ma na celu:",
      "options": [
        {
          "key": "a",
          "text": "określenie długości następnego datagramu, oraz wszystkich kolejnych",
          "correct": false
        },
        {
          "key": "b",
          "text": "określić ilość danych, jaką nadawca może w danej chwili wysłać (służy do sterowania przepływem)",
          "correct": true
        },
        {
          "key": "c",
          "text": "określenie ilości danych w datagramie, w którym się znajduje - i w przypadku potwierdzeń TCP nie ma żadnego znaczenia",
          "correct": false
        },
        {
          "key": "d",
          "text": "informowanie o wielkości datagramu, jaką może przyjąć host w aktualnym stanie",
          "correct": true
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 163,
      "question": "Dwa rodzaje obszarów (area) w protokole routingu dynamicznego IS-IS (Intermediate System to Intermediate System), to:",
      "options": [
        {
          "key": "a",
          "text": "intra-area i inter-area",
          "correct": true
        },
        {
          "key": "b",
          "text": "stub i backbone",
          "correct": false
        },
        {
          "key": "c",
          "text": "LAN i WAN",
          "correct": false
        },
        {
          "key": "d",
          "text": "Autonomous System i Internal System",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 164,
      "question": "Dla uniknięcia błędów uwarunkowanych czasowo, maksymalna liczba procesów, które mogą znajdować się wewnątrz sekcji krytycznej, wynosi:",
      "options": [
        {
          "key": "a",
          "text": "8",
          "correct": false
        },
        {
          "key": "b",
          "text": "1",
          "correct": true
        },
        {
          "key": "c",
          "text": "0",
          "correct": false
        },
        {
          "key": "d",
          "text": "16",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 165,
      "question": "Inicjalna wartość semafora uogólnionego implementującego sekcję krytyczną wynosi:",
      "options": [
        {
          "key": "a",
          "text": "0",
          "correct": false
        },
        {
          "key": "b",
          "text": "1",
          "correct": true
        },
        {
          "key": "c",
          "text": "-1",
          "correct": false
        },
        {
          "key": "d",
          "text": "dowolna liczba dodatnia",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 166,
      "question": "Proces transferowania danych, które mają być docelowo wyprowadzone na urządzenie peryferyjne, do przestrzeni pamięci pomocniczej i transferowanie ich na to urządzenie w dogodniejszym czasie nosi nazwę:",
      "options": [
        {
          "key": "a",
          "text": "spooling",
          "correct": true
        },
        {
          "key": "b",
          "text": "virtualization",
          "correct": false
        },
        {
          "key": "c",
          "text": "caching",
          "correct": false
        },
        {
          "key": "d",
          "text": "throttling",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 167,
      "question": "Centralny Procesor, po otrzymaniu informacji o przerwaniu z urządzenia wejścia/wyjścia:",
      "options": [
        {
          "key": "a",
          "text": "zatrzymuje się na określony okres czasu",
          "correct": false
        },
        {
          "key": "b",
          "text": "przekazuje sterowanie do systemu obsługi przerwań po zakończeniu wykonywania bieżącej instrukcji",
          "correct": true
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 168,
      "question": "Który z problemów rozwiązuje zaproponowany przez Dijkstrę algorytm bankiera:",
      "options": [
        {
          "key": "a",
          "text": "wzajemnego wykluczania (mutual exclusion)",
          "correct": false
        },
        {
          "key": "b",
          "text": "wzajemnego zakleszczenia (deadlock exclusion)",
          "correct": false
        },
        {
          "key": "c",
          "text": "unikania zakleszczenia (deadlock avoidance)",
          "correct": true
        },
        {
          "key": "d",
          "text": "unikania wykluczania (exclusion avoidance)",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 169,
      "question": "System operacyjny jest:",
      "options": [
        {
          "key": "a",
          "text": "zbiorem składników sprzętowych (hardware routines)",
          "correct": false
        },
        {
          "key": "b",
          "text": "zbiorem driverów obsługujących urządzenia wejścia-wyjścia (input-output devices)",
          "correct": false
        },
        {
          "key": "c",
          "text": "zbiorem składników programowych (software routines)",
          "correct": true
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 170,
      "question": "Szyfrowanie kluczem publicznym w szyfrowaniu asymetrycznym:",
      "options": [
        {
          "key": "a",
          "text": "pozwala jedynie właściwemu odbiorcy odkodować komunikat",
          "correct": false
        },
        {
          "key": "b",
          "text": "tylko posiadacz klucza prywatnego może odkodować komunikat",
          "correct": true
        },
        {
          "key": "c",
          "text": "wystarczy użyć tego samego klucza do deszyfrowania wiadomości",
          "correct": false
        },
        {
          "key": "d",
          "text": "wiadomość zaszyfrowana za pomocą klucza publicznego może być odszyfrowana tylko za pomocą klucza prywatnego",
          "correct": true
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 171,
      "question": "Buforowanie plików realizowane jest w celu:",
      "options": [
        {
          "key": "a",
          "text": "zwiększenia wydajności dostępu do pamięci pomocniczej",
          "correct": false
        },
        {
          "key": "b",
          "text": "wspomagania obsługi przerwań",
          "correct": false
        },
        {
          "key": "c",
          "text": "zwiększenia wydajności procesora",
          "correct": false
        },
        {
          "key": "d",
          "text": "wyrównania różnic prędkości przesyłania danych między różnymi urządzeniami",
          "correct": true
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 172,
      "question": "Zaznacz prawdziwe stwierdzenia na temat stronicowania:",
      "options": [
        {
          "key": "a",
          "text": "stronicowanie rozwiązuje problem zewnętrznej fragmentacji pamięci",
          "correct": true
        },
        {
          "key": "b",
          "text": "tablica stron jest stosowana do translacji adresu logicznego na adres fizyczny",
          "correct": true
        },
        {
          "key": "c",
          "text": "podczas stronicowania przyjmuje się, że pamięć fizyczna jest podzielona na strony, a pamięć logiczna na ramki, oraz że rozmiary stron i ramek są jednakowe",
          "correct": false
        },
        {
          "key": "d",
          "text": "stronicowanie rozwiązuje problem wewnętrznej fragmentacji pamięci",
          "correct": false
        },
        {
          "key": "e",
          "text": "podczas stronicowania przyjmuje się, że pamięć fizyczna jest podzielona na ramki, a pamięć logiczna na strony, oraz że rozmiary stron i ramek są jednakowe",
          "correct": true
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 173,
      "question": "Zaznacz prawdziwe stwierdzenia na temat segmentacji:",
      "options": [
        {
          "key": "a",
          "text": "segmentacja ułatwia nadanie częściom procesu odpowiednich atrybutów ochrony: dopuszczalny odczyt, dopuszczalny zapis, dopuszczalne wykonanie",
          "correct": true
        },
        {
          "key": "b",
          "text": "zastosowanie segmentacji wyklucza zastosowanie stronicowania",
          "correct": false
        },
        {
          "key": "c",
          "text": "mogą istnieć następujące przykładowe rodzaje segmentów: kodu, danych, stosu",
          "correct": true
        },
        {
          "key": "d",
          "text": "elementy tablicy segmentów zawierają adresy/numery ramek, w których znajdują się segmenty oraz rozmiary poszczególnych segmentów",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 174,
      "question": "Zaznacz prawdziwe stwierdzenia na temat algorytmów wywłaszczania stron:",
      "options": [
        {
          "key": "a",
          "text": "zaletą algorytmu zastępowania stron FIFO jest to, że nie zachodzi w nim efekt zwany anomalią Belady'ego",
          "correct": false
        },
        {
          "key": "b",
          "text": "w algorytmie zastępowania stron LRU zastępowana jest strona, która najdłużej nie była używana",
          "correct": true
        },
        {
          "key": "c",
          "text": "w algorytmie zastępowania stron zwanym algorytmem drugiej szansy algorytm wykorzystuje bit odniesienia, który określa, czy w pewnym przedziale czasu nastąpiło odwołanie do strony",
          "correct": true
        },
        {
          "key": "d",
          "text": "zasadą działania algorytmu optymalnego zastępowania stron jest to, że zastąpiona zostaje strona, która najdłużej nie będzie używana",
          "correct": true
        },
        {
          "key": "e",
          "text": "w algorytmie zastępowania stron LRU zachodzi efekt zwany anomalią Belady'ego",
          "correct": false
        },
        {
          "key": "f",
          "text": "optymalny algorytm wywłaszczania stron zapewnia minimalną ilość wywłaszczeń stron przy ustalonej liczbie ramek",
          "correct": true
        },
        {
          "key": "g",
          "text": "algorytm FIFO wywłaszcza stronę, do której czas dostępu był najdawniejszy",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 175,
      "question": "Zaznacz prawdziwe stwierdzenia dotyczące pamięci wirtualnej:",
      "options": [
        {
          "key": "a",
          "text": "stronicowanie na żądanie jest jednym ze sposobów realizacji pamięci wirtualnej",
          "correct": true
        },
        {
          "key": "b",
          "text": "procedura leniwej wymiany (ang. lazy swapper) polega na tym, że nie wykonuje się wymiany stron w pamięci, jeśli nie zachodzi taka potrzeba",
          "correct": true
        },
        {
          "key": "c",
          "text": "pamięć wirtualna umożliwia wykonywanie procesów, które nie są w całości przechowywane w pamięci operacyjnej",
          "correct": true
        },
        {
          "key": "d",
          "text": "przydział ramek oparty na globalnym algorytmie zastępowania może ograniczyć szamotanie (w porównaniu do algorytmu lokalnego zastępowania), gdyż szamoczący się proces nie doprowadza do szamotania innych procesów",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 176,
      "question": "Zaznacz prawdziwe zdania na temat semaforów:",
      "options": [
        {
          "key": "a",
          "text": "zaletą aktywnego czekania w trybie użytkownika jest brak konieczności kosztownego przejścia do trybu uprzywilejowanego (systemowego)",
          "correct": true
        },
        {
          "key": "b",
          "text": "semafor może być użyty do synchronizacji dostępu do sekcji krytycznej",
          "correct": true
        },
        {
          "key": "c",
          "text": "aktywne czekanie oznacza ciągłe testowanie wartości wyrażenia do momentu, gdy przyjmie ono wartość, dla której czekanie może być zakończone",
          "correct": true
        },
        {
          "key": "d",
          "text": "semafor nie nadaje się do zdeterminowania kolejności wykonywanych operacji w grupie współbieżnych procesów",
          "correct": false
        },
        {
          "key": "e",
          "text": "semafor może być użyty do synchronizacji dostępu do sekcji krytycznej, poprzez sygnalizowanie (V) przed wejściem i czekanie (P) po zakończeniu",
          "correct": false
        },
        {
          "key": "f",
          "text": "mogą wykonywać operacje czekaj (P) i sygnalizuj (V)",
          "correct": true
        },
        {
          "key": "g",
          "text": "aktywne czekanie polega na uśpieniu procesu i aktywnym oczekiwaniu na sygnał wybudzający",
          "correct": false
        },
        {
          "key": "h",
          "text": "można stworzyć semafor zliczający z 2 semaforów binarnych i zmiennej zliczającej wykorzystującej te semafory",
          "correct": true
        },
        {
          "key": "i",
          "text": "przed wejściem do sekcji krytycznej wykonywana jest operacja sygnalizuj (V)",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 4,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 177,
      "question": "Generalizacja:",
      "options": [
        {
          "key": "a",
          "text": "organizuje obiekty w hierarchię uogólniania/uszczegóławiania",
          "correct": false
        },
        {
          "key": "b",
          "text": "organizuje klasy w hierarchię całości/części",
          "correct": false
        },
        {
          "key": "c",
          "text": "znajduje swoje odzwierciedlenie w mechanizmie dziedziczenia interfejsów",
          "correct": true
        },
        {
          "key": "d",
          "text": "znajduje swoje odzwierciedlenie w mechanizmie dziedziczenia implementacji",
          "correct": false
        }
      ],
      "topic": "oop_design",
      "semester": 6,
      "courseName": "Programowanie obiektowe",
      "multipleCorrect": false
    },
    {
      "id": 178,
      "question": "Kompozycja:",
      "options": [
        {
          "key": "a",
          "text": "jest to struktura agregacji, w której klasy części mogą być powiązane tylko z jedną klasą całości",
          "correct": false
        },
        {
          "key": "b",
          "text": "ogranicza powiązanie klasy części do jednej klasy całości",
          "correct": false
        },
        {
          "key": "c",
          "text": "ogranicza powiązanie obiektu części do jednego obiektu całości",
          "correct": true
        },
        {
          "key": "d",
          "text": "jest silnym powiązaniem z czasem życia części ograniczonym do czasu życia całości",
          "correct": true
        }
      ],
      "topic": "oop_design",
      "semester": 6,
      "courseName": "Programowanie obiektowe",
      "multipleCorrect": true
    },
    {
      "id": 179,
      "question": "Relacja zależności wskazuje, że:",
      "options": [
        {
          "key": "a",
          "text": "klasa dostarcza implementacji usług interfejsu",
          "correct": false
        },
        {
          "key": "b",
          "text": "istnieje szczególne powiązanie między klasami",
          "correct": false
        },
        {
          "key": "c",
          "text": "obiekt klasy może być argumentem wywołania usługi innej klasy",
          "correct": true
        },
        {
          "key": "d",
          "text": "implementacja klasy może się zmienić, gdy zmieni się implementacja innej klasy",
          "correct": true
        },
        {
          "key": "e",
          "text": "zmiana specyfikacji jednej usługi może mieć wpływ na poprawność działania innej",
          "correct": false
        },
        {
          "key": "f",
          "text": "zmiana stanu obiektu zależy od stanu innego obiektu",
          "correct": false
        },
        {
          "key": "g",
          "text": "przypadek użycia zależy od innego przypadku użycia",
          "correct": false
        }
      ],
      "topic": "oop_design",
      "semester": 6,
      "courseName": "Programowanie obiektowe",
      "multipleCorrect": true
    },
    {
      "id": 180,
      "question": "Relacja realizacji wskazuje, że",
      "options": [
        {
          "key": "a",
          "text": "obiekt klasy może być argumentem wywołania usługi innej klasy",
          "correct": false
        },
        {
          "key": "b",
          "text": "klasa dostarcza implementacji usług interfejsu",
          "correct": true
        },
        {
          "key": "c",
          "text": "klasa realizuje usługi delegowane z innej klasy",
          "correct": false
        },
        {
          "key": "d",
          "text": "klasa wykorzystuje usługi interfejsu",
          "correct": false
        }
      ],
      "topic": "oop_design",
      "semester": 6,
      "courseName": "Programowanie obiektowe",
      "multipleCorrect": false
    },
    {
      "id": 181,
      "question": "Wielokrotne użycie wspierane jest w modelu obiektowym przez:",
      "options": [
        {
          "key": "a",
          "text": "kwalifikowane powiązania",
          "correct": false
        },
        {
          "key": "b",
          "text": "kompozycje z delegacją roli",
          "correct": true
        },
        {
          "key": "c",
          "text": "istnienie klas obiektów",
          "correct": true
        },
        {
          "key": "d",
          "text": "dziedziczenie implementacji",
          "correct": true
        }
      ],
      "topic": "oop_design",
      "semester": 6,
      "courseName": "Programowanie obiektowe",
      "multipleCorrect": true
    },
    {
      "id": 182,
      "question": "Wybierz, które z poniższych stwierdzeń są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "autorem klasyfikacji (hierarchii) języków formalnych jest Noam Chomsky",
          "correct": true
        },
        {
          "key": "b",
          "text": "zbiór wszystkich palindromów nad danym alfabetem jest językiem regularnym",
          "correct": false
        },
        {
          "key": "c",
          "text": "istnieją języki, które nie należą do hierarchii Chomsky'ego, więc nie są generowane przez żadną gramatykę ani akceptowane przez żaden automat",
          "correct": true
        },
        {
          "key": "d",
          "text": "językiem formalnym nazywamy dowolny podzbiór zbioru wszystkich możliwych słów zbudowanych z symboli należących do skończonego alfabetu",
          "correct": true
        },
        {
          "key": "e",
          "text": "język oznaczany jako ^^\\{\\epsilon\\}^^ jest językiem pustym",
          "correct": false
        },
        {
          "key": "f",
          "text": "najszerszą klasą języków w hierarchii Chomsky'ego jest klasa języków rekurencyjnie przeliczalnych generowanych przez gramatyki bez ograniczeń",
          "correct": true
        },
        {
          "key": "g",
          "text": "jeżeli L jest językiem bezkontekstowym, to istnieje automat ze stosem akceptujący ten język i jest on mu równoważny",
          "correct": true
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 183,
      "question": "Niech N będzie niedeterministycznym automatem skończonym posiadającym ^^n^^ stanów, oraz niech M będzie minimalnym deterministycznym automatem skończonym rozpoznającym ten sam język, posiadającym ^^m^^ stanów. Wtedy:",
      "options": [
        {
          "key": "a",
          "text": "^^m \\leq n^^",
          "correct": false
        },
        {
          "key": "b",
          "text": "^^m \\leq 2^n^^",
          "correct": true
        },
        {
          "key": "c",
          "text": "^^n \\leq m^^",
          "correct": false
        },
        {
          "key": "d",
          "text": "M posiada dokładnie jeden stan akceptujący",
          "correct": false
        },
        {
          "key": "e",
          "text": "każdy deterministyczny automat skończony rozpoznający ten sam język musi posiadać co najmniej ^^2^n^^ stanów",
          "correct": false
        },
        {
          "key": "f",
          "text": "każdy automat deterministyczny akceptujący ten sam język co N musi mieć co najwyżej ^^2^n^^ stanów",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 184,
      "question": "Wybierz, które z poniższych stwierdzeń są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "jeśli język ^^L^^ spełnia tezę lematu o pompowaniu dla języków regularnych, to język ^^L^^ jest regularny",
          "correct": false
        },
        {
          "key": "b",
          "text": "jeśli język ^^L^^ jest skończony, to ^^L*^^ musi być regularny",
          "correct": true
        },
        {
          "key": "c",
          "text": "każdy język, który nie jest regularny, jest nieskończony",
          "correct": true
        },
        {
          "key": "d",
          "text": "pomimo, że języki regularne w trywialny sposób są bezkontekstowe, to istnieją języki regularne nie spełniające lematu o pompowaniu dla języków bezkontekstowych",
          "correct": false
        },
        {
          "key": "e",
          "text": "żeby sprawdzić, czy dany automat akceptuje język nieskończony, można iterując po wszystkich słowach złożonych z alfabetu sprawdzić, czy liczba słów przez niego akceptowanych jest nieskończona",
          "correct": false
        },
        {
          "key": "f",
          "text": "zupełny deterministyczny automat skończony, który nie akceptuje żadnego słowa, nie ma osiągalnych stanów akceptujących",
          "correct": true
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 185,
      "question": "Dla języków i gramatyk formalnych, odnośnie postaci normalnej Chomsky'ego oraz postaci normalnej Greibach można sformułować następujące stwierdzenia (duże litery alfabetu łacińskiego to symbole nieterminalne, a litery małe to symbole terminalne):",
      "options": [
        {
          "key": "a",
          "text": "gramatyka w postaci Chomsky'ego zawiera produkcje postaci ^^A \\rightarrow BC^^, ^^A \\rightarrow a^^, a gramatyka w postaci Greibach zawiera produkcje postaci ^^A \\rightarrow aX^^ (gdzie ^^X^^ to ciąg symboli nieterminalnych, może być pusty), oraz każdą gramatykę bezkontekstową w postaci normalnej Chomsky'ego można przekształcić do postaci normalnej Greibach",
          "correct": true
        },
        {
          "key": "b",
          "text": "dla dowolnej gramatyki bezkontekstowej ^^G^^ istnieje taka gramatyka bezkontekstowa ^^G'^^ będąca w postaci normalnej Chomsky'ego, że ^^L(G') = L(G) - \\{\\epsilon\\}^^",
          "correct": true
        },
        {
          "key": "c",
          "text": "dla każdego języka bezkontekstowego istnieje gramatyka w postaci normalnej Chomsky'ego",
          "correct": false
        },
        {
          "key": "d",
          "text": "każdą gramatykę bezkontekstową można przekształcić do postaci normalnej Chomsky'ego",
          "correct": false
        },
        {
          "key": "e",
          "text": "każdą gramatykę bezkontekstową można przekształcić do postaci normalnej Greibach",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 186,
      "question": "Odnośnie lematu o pompowaniu dla języków regularnych prawdziwe są następujące stwierdzenia:",
      "options": [
        {
          "key": "a",
          "text": "lemat służy pokazaniu, że określone języki są regularne",
          "correct": false
        },
        {
          "key": "b",
          "text": "schemat postępowania jest następujący: skoro język posiada pewne własności regularności, to jest regularny",
          "correct": false
        },
        {
          "key": "c",
          "text": "lemat służy do dowodzenia, że dany język nie jest językiem regularnym",
          "correct": true
        },
        {
          "key": "d",
          "text": "lemat służy do dowodzenia, że dany język jest językiem regularnym",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 187,
      "question": "Jeżeli ^^r^^ oraz ^^s^^ są wyrażeniami regularnymi dla języków odpowiednio ^^R^^ oraz ^^S^^, to ^^(r + s)^^, ^^rs^^ oraz ^^r*^^ są wyrażeniami regularnymi reprezentującymi odpowiednio zbiory:",
      "options": [
        {
          "key": "a",
          "text": "^^R \\cup S^^, ^^R \\times S^^, ^^R^{+}^^",
          "correct": false
        },
        {
          "key": "b",
          "text": "^^R \\cup S^^, ^^R \\times S^^, ^^R*^^",
          "correct": false
        },
        {
          "key": "c",
          "text": "^^R \\cup S^^, ^^RS^^, ^^R*^^",
          "correct": true
        },
        {
          "key": "d",
          "text": "^^R \\cup S^^, ^^RS^^, ^^R^{+}^^",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 188,
      "question": "Mamy języki ^^L1 = \\{ a^{2^n}, n > 0 \\}^^ oraz ^^L2 = \\{ a^{2n}, n > 0 \\}^^. Które z tych języków są regularne?",
      "options": [
        {
          "key": "a",
          "text": "^^L1^^ - nie, ^^L2^^ - nie",
          "correct": false
        },
        {
          "key": "b",
          "text": "^^L1^^ - tak, ^^L2^^ - nie",
          "correct": false
        },
        {
          "key": "c",
          "text": "^^L1^^ - nie, ^^L2^^ - tak",
          "correct": true
        },
        {
          "key": "d",
          "text": "^^L1^^ - tak, ^^L2^^ - tak",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 189,
      "question": "Eliminując niejednoznaczność gramatyki poprzez konwersję do innej gramatyki musimy zachować bez zmian:",
      "options": [
        {
          "key": "a",
          "text": "drzewo wyprowadzenia oryginalnej gramatyki dla każdego jednoznacznego słowa wejściowego",
          "correct": false
        },
        {
          "key": "b",
          "text": "wyprowadzenia oryginalnej gramatyki dla każdego słowa wejściowego",
          "correct": false
        },
        {
          "key": "c",
          "text": "zbiór słów generowanych przez oryginalną gramatykę",
          "correct": true
        },
        {
          "key": "d",
          "text": "drzewo wyprowadzenia oryginalnej gramatyki dla każdego słowa wejściowego",
          "correct": false
        },
        {
          "key": "e",
          "text": "wyprowadzenia oryginalnej gramatyki dla każdego jednoznacznego słowa wejściowego",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 190,
      "question": "Która z następujących metod parsingu może przetworzyć najszerszą klasę gramatyk:",
      "options": [
        {
          "key": "a",
          "text": "parser SLR",
          "correct": false
        },
        {
          "key": "b",
          "text": "zstępujący parser rekurencyjny bez nawracania",
          "correct": false
        },
        {
          "key": "c",
          "text": "kanoniczny parser LR",
          "correct": false
        },
        {
          "key": "d",
          "text": "parser Earleya",
          "correct": true
        },
        {
          "key": "e",
          "text": "parser LL(1)",
          "correct": false
        },
        {
          "key": "f",
          "text": "parser CYK",
          "correct": true
        },
        {
          "key": "g",
          "text": "parser LALR(1)",
          "correct": false
        },
        {
          "key": "h",
          "text": "parser oparty na priorytecie operatorów",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 191,
      "question": "Wybierz stwierdzenia, które są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "LR wymaga usunięcia lewostronnej rekurencji",
          "correct": false
        },
        {
          "key": "b",
          "text": "LL wymaga na początku faktoryzacji lewostronnej",
          "correct": false
        },
        {
          "key": "c",
          "text": "gramatyki parsowane przez LR są nadzbiorem właściwym gramatyk parsowanych przez LL",
          "correct": true
        },
        {
          "key": "d",
          "text": "LR parsuje od prawej do lewej, LL od lewej do prawej",
          "correct": false
        },
        {
          "key": "e",
          "text": "dla każdej gramatyki jednoznacznej można skonstruować parser LR(1)",
          "correct": false
        },
        {
          "key": "f",
          "text": "żadna gramatyka niejednoznaczna nie może być gramatyką LR(1)",
          "correct": true
        },
        {
          "key": "g",
          "text": "tworzenie parsera jest sensowną procedurą tylko dla jednoznacznej gramatyki bezkontekstowej (nie ma sensu konstruowanie parsera dla gramatyki niejednoznacznej)",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 192,
      "question": "Typowy skaner języka formalnego ma za zadanie",
      "options": [
        {
          "key": "a",
          "text": "wyodrębnić symbole leksykalne",
          "correct": true
        },
        {
          "key": "b",
          "text": "zliczyć słowa kluczowe i sprawdzić ich kolokacje",
          "correct": false
        },
        {
          "key": "c",
          "text": "zliczyć lewe i prawe nawiasy sprawdzając wstępnie ich sparowanie",
          "correct": false
        },
        {
          "key": "d",
          "text": "wczytać kod źródłowy programu do postaci tokenów",
          "correct": true
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 193,
      "question": "W odniesieniu do pracy parserów klasy LR(k) i funkcji action prawdziwe są stwierdzenia:",
      "options": [
        {
          "key": "a",
          "text": "funkcja action przyjmuje wartości ze zbioru {shift, reduce, goto, accept, error}",
          "correct": false
        },
        {
          "key": "b",
          "text": "na stosie trzymane są prefiksy i sufiksy form zdaniowych, co do których jest nadzieja na ich wykorzystanie",
          "correct": false
        },
        {
          "key": "c",
          "text": "funkcja action przyjmuje wartości ze zbioru {shift, reduce, accept, error}",
          "correct": true
        },
        {
          "key": "d",
          "text": "na stosie trzymane są prefiksy wszystkich form zdaniowych",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 194,
      "question": "Budowa tablic sterujących dla analizatorów klasy LR może stwarzać pewne trudności, szczególnie w zakresie automatyzacji, co ma pośredni wpływ na istnienie wielu odmian tych parserów. Które z poniższych prostych stwierdzeń są poprawne:",
      "options": [
        {
          "key": "a",
          "text": "pierwsza litera w nazwie SLR oznacza Shift",
          "correct": false
        },
        {
          "key": "b",
          "text": "pierwsza litera w nazwie SLR oznacza Simple",
          "correct": true
        },
        {
          "key": "c",
          "text": "pierwsze litery w nazwie LALR oznaczają LookAhead",
          "correct": true
        },
        {
          "key": "d",
          "text": "pierwsza litera w nazwie GLR oznacza Grammar",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 195,
      "question": "Porównując gramatyki LL oraz LR można powiedzieć, że:",
      "options": [
        {
          "key": "a",
          "text": "gramatyki LL opisują szerszą klasę niż LR",
          "correct": false
        },
        {
          "key": "b",
          "text": "gramatyki LR opisują szerszą klasę niż LL",
          "correct": true
        },
        {
          "key": "c",
          "text": "każda gramatyka LL jest również gramatyką LR",
          "correct": true
        },
        {
          "key": "d",
          "text": "każda gramatyka LR jest również gramatyką LL",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 196,
      "question": "Sekcja krytyczna procesu jest to:",
      "options": [
        {
          "key": "a",
          "text": "część procesu, w której wykorzystywany jest zasób dzielony",
          "correct": true
        },
        {
          "key": "b",
          "text": "część procesu, w której wykonywana jest komunikacja z użytkownikiem",
          "correct": false
        },
        {
          "key": "c",
          "text": "część procesu, w której wykonywana jest nieskończona pętla",
          "correct": false
        },
        {
          "key": "d",
          "text": "część procesu, w której deklarowane są lokalne zmienne",
          "correct": false
        }
      ],
      "topic": "concurrent_programming",
      "semester": 7,
      "courseName": "Programowanie współbieżne",
      "multipleCorrect": false
    },
    {
      "id": 197,
      "question": "Wzajemnym wykluczaniem nazywamy problem współzawodnictwa procesów o zasób, który:",
      "options": [
        {
          "key": "a",
          "text": "musi zostać zainicjalizowany przez jeden z procesów",
          "correct": false
        },
        {
          "key": "b",
          "text": "jest zmienną przechowywaną w rejestrach procesora",
          "correct": false
        },
        {
          "key": "c",
          "text": "jednocześnie może być wykorzystywany tylko przez jeden z nich",
          "correct": true
        },
        {
          "key": "d",
          "text": "może być wykorzystywany tylko przez z góry określony czas",
          "correct": false
        }
      ],
      "topic": "concurrent_programming",
      "semester": 7,
      "courseName": "Programowanie współbieżne",
      "multipleCorrect": false
    },
    {
      "id": 198,
      "question": "Komunikację nazywamy asynchroniczną jeżeli:",
      "options": [
        {
          "key": "a",
          "text": "nadawca żąda, by odbiorca był gotów do odebrania komunikatu",
          "correct": false
        },
        {
          "key": "b",
          "text": "nadawca może wysłać wiadomość i kontynuować pracę bez wstrzymania",
          "correct": true
        },
        {
          "key": "c",
          "text": "przy komunikacji mamy do czynienia z synchronizacją procesów",
          "correct": false
        },
        {
          "key": "d",
          "text": "nadawca nie żąda, by odbiorca był gotów do odebrania komunikatu",
          "correct": true
        }
      ],
      "topic": "concurrent_programming",
      "semester": 7,
      "courseName": "Programowanie współbieżne",
      "multipleCorrect": true
    },
    {
      "id": 199,
      "question": "Zjawisko blokady w programie współbieżnym jest:",
      "options": [
        {
          "key": "a",
          "text": "zatrzymaniem pracy jednego ze współbieżnych procesów",
          "correct": false
        },
        {
          "key": "b",
          "text": "stanem, w którym każdy proces oczekuje na działanie innego procesu",
          "correct": true
        },
        {
          "key": "c",
          "text": "przejawem braku bezpieczeństwa programu współbieżnego",
          "correct": true
        },
        {
          "key": "d",
          "text": "stanem, w którym proces czekający na dane zdarzenie nie zostaje wznowiony mimo, że występuje ono dowolną liczbę razy",
          "correct": false
        }
      ],
      "topic": "concurrent_programming",
      "semester": 7,
      "courseName": "Programowanie współbieżne",
      "multipleCorrect": true
    },
    {
      "id": 200,
      "question": "Zjawisko zagłodzenia w programie współbieżnym jest:",
      "options": [
        {
          "key": "a",
          "text": "stanem, w którym każdy proces oczekuje na działanie innego procesu",
          "correct": false
        },
        {
          "key": "b",
          "text": "przejawem braku bezpieczeństwa programu współbieżnego",
          "correct": false
        },
        {
          "key": "c",
          "text": "stanem, w którym proces czekający na dane zdarzenie nie zostaje wznowiony, mimo że występuje ono dowolną liczbę razy",
          "correct": true
        },
        {
          "key": "d",
          "text": "nienaturalnym przerwaniem pracy jednego ze współbieżnych procesów",
          "correct": false
        },
        {
          "key": "e",
          "text": "sytuacją, kiedy nie ma gwarancji, że określone zdarzenie wykona się w skończonym czasie",
          "correct": true
        },
        {
          "key": "f",
          "text": "pojawieniem się cyklu w relacji Lamporta \"happen-before\"",
          "correct": false
        }
      ],
      "topic": "concurrent_programming",
      "semester": 7,
      "courseName": "Programowanie współbieżne",
      "multipleCorrect": true
    },
    {
      "id": 201,
      "question": "Komunikację nazywamy synchroniczną jeżeli:",
      "options": [
        {
          "key": "a",
          "text": "nadawca żąda, by odbiorca był gotów do odebrania komunikatu",
          "correct": true
        },
        {
          "key": "b",
          "text": "nadawca nie żąda, by odbiorca był gotów do odebrania komunikatu",
          "correct": false
        },
        {
          "key": "c",
          "text": "przy komunikacji mamy do czynienia z synchronizacją procesów",
          "correct": true
        },
        {
          "key": "d",
          "text": "nadawca może wysłać wiadomość i kontynuować pracę bez wstrzymania",
          "correct": false
        }
      ],
      "topic": "concurrent_programming",
      "semester": 7,
      "courseName": "Programowanie współbieżne",
      "multipleCorrect": true
    },
    {
      "id": 202,
      "question": "Prawo dostępu do pliku 453 pozwala:",
      "options": [
        {
          "key": "a",
          "text": "właścicielowi czytać plik",
          "correct": true
        },
        {
          "key": "b",
          "text": "wszystkim czytać plik",
          "correct": false
        },
        {
          "key": "c",
          "text": "właścicielowi na odczyt, grupie na odczyt i uruchomienie, pozostałym na zapis i uruchomienie",
          "correct": true
        },
        {
          "key": "d",
          "text": "grupie na odczyt i zapis, pozostałym tylko na odczyt",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 7,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 203,
      "question": "Przy konfiguracji obsługi sieci w Unixie:",
      "options": [
        {
          "key": "a",
          "text": "plik /etc/hosts przechowuje listę znanych hostów i interfejsów sieciowych",
          "correct": true
        },
        {
          "key": "b",
          "text": "plik /etc/hosts zawiera tylko adresy IP lokalnych interfejsów",
          "correct": false
        },
        {
          "key": "c",
          "text": "plik /etc/networks zawiera adresy IP znanych sieci IP",
          "correct": true
        },
        {
          "key": "d",
          "text": "plik /etc/networks przechowuje listę lokalnych interfejsów",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 7,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 204,
      "question": "W systemie operacyjnym UNIX prawdziwe są następujące stwierdzenia dotyczące użytkownika i jego sesji:",
      "options": [
        {
          "key": "a",
          "text": "praca programu logującego (login) jest sterowana m. in. zawartością plików /etc/nologin lub /etc/motd",
          "correct": true
        },
        {
          "key": "b",
          "text": "o możliwościach użytkownika w systemie decyduje przynależność do odpowiednich grup użytkowników",
          "correct": true
        },
        {
          "key": "c",
          "text": "w zależności od konfiguracji systemu mogą być odnotowywane podłączenia do systemu poprzez zmianę kontekstu użytkownika (komenda su)",
          "correct": true
        },
        {
          "key": "d",
          "text": "grupy użytkowników wprowadzono, aby ułatwić zarządzanie użytkownikami oraz podnieść bezpieczeństwo systemu",
          "correct": true
        }
      ],
      "topic": "unix_admin",
      "semester": 7,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 205,
      "question": "W systemie operacyjnym UNIX prawdziwe są następujące stwierdzenia dotyczące procesu logowania się i uprawnień użytkowników:",
      "options": [
        {
          "key": "a",
          "text": "o postaci hasła decyduje administrator systemu zapisując ograniczenia w różnych wersjach systemu w różnych plikach konfiguracyjnych",
          "correct": true
        },
        {
          "key": "b",
          "text": "wszystkie grupy użytkowników dają im jednakowe uprawnienia",
          "correct": false
        },
        {
          "key": "c",
          "text": "cała informacja dotycząca konfiguracji użytkownika w systemie jest zapisana jedynie w pliku /etc/passwd co zapewnia spójność informacji",
          "correct": false
        },
        {
          "key": "d",
          "text": "do systemu użytkownik może podłączać się jedynie z konsoli systemu oraz zdalnie poprzez sieć",
          "correct": false
        },
        {
          "key": "e",
          "text": "nazwa użytkownika w systemie UNIX musi być unikalna zaś numer identyfikacyjny może się powtarzać",
          "correct": true
        },
        {
          "key": "f",
          "text": "technika shadow umożliwia podglądnięcie postaci zaszyfrowanej hasła każdego użytkownika w systemie przez dowolnego użytkownika",
          "correct": false
        },
        {
          "key": "g",
          "text": "system PAM umożliwia m.in. odnotowywanie nieudanych prób podłączania się do systemu",
          "correct": true
        }
      ],
      "topic": "unix_admin",
      "semester": 7,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 206,
      "question": "Zaznacz prawdziwe stwierdzenia na temat procesów:",
      "options": [
        {
          "key": "a",
          "text": "proces jest wykonaniem programu i składa się ze zbiorowości bajtów, w których wyróżnia się instrukcje maszynowe (tzw. tekst), dane i stos",
          "correct": true
        },
        {
          "key": "b",
          "text": "w kategoriach praktycznych proces w systemie UNIX jest jednostką utworzoną za pomocą funkcji systemowej fork (z wyjątkiem procesu o numerze 0)",
          "correct": true
        },
        {
          "key": "c",
          "text": "każdy uruchomiony w systemie UNIX proces otrzymuje od procesu potomnego dostęp do jego (procesu macierzystego) zmiennych środowiskowych",
          "correct": false
        },
        {
          "key": "d",
          "text": "liczba możliwych do uruchomienia w systemie UNIX procesów jest ograniczona jedynie rozmiarem pamięci o dostępie swobodnym danego systemu komputerowego",
          "correct": false
        },
        {
          "key": "e",
          "text": "wartość parametru NICE dla nowo utworzonego procesu jest wyliczana na podstawie średniego obciążenia systemu",
          "correct": false
        },
        {
          "key": "f",
          "text": "każdy uruchomiony w systemie UNIX proces otrzymuje od systemu trzy otwarte pliki o numerach 0, 1 i 2",
          "correct": true
        },
        {
          "key": "g",
          "text": "rekord w tablicy procesów znajdującej się w jądrze systemu operacyjnego zawiera podstawowe informacje o procesie, w tym jego właścicieli, listę segmentów oraz wskaźniki do U-obszaru",
          "correct": true
        },
        {
          "key": "h",
          "text": "zmiana kontekstu z trybu użytkownika na tryb jądra następuje między innymi wówczas, gdy system przydziela procesor kolejnemu procesowi z kolejki gotowych do wykonania procesów",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 7,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 207,
      "question": "Interpretery poleceń systemu UNIX:",
      "options": [
        {
          "key": "a",
          "text": "w niektórych interpreterach poleceń można uniemożliwić odłączanie się od systemu poprzez wykorzystanie sekwencji Ctrl-D dzięki ustawieniu wartości odpowiedniej zmiennej środowiskowej",
          "correct": true
        },
        {
          "key": "b",
          "text": "wszystkie polecenia shella zwracają 0 (zero), kiedy wykonanie ich zakończy się niepowodzeniem lub wartość różną od 0 (zazwyczaj 1) w przypadku przeciwnym",
          "correct": false
        },
        {
          "key": "c",
          "text": "każdy interpreter wykorzystuje trzy podstawowe typy zmiennych: specjalne, środowiska oraz programowe",
          "correct": true
        },
        {
          "key": "d",
          "text": "błędne wykonanie komendy w linii komend można rozpoznać m. in. po zapisach do urządzenia /dev/null",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 7,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 208,
      "question": "Wartość 5/16 ma postać w systemie binarnym:",
      "options": [
        {
          "key": "a",
          "text": "0.0101",
          "correct": true
        },
        {
          "key": "b",
          "text": "0.1011",
          "correct": false
        },
        {
          "key": "c",
          "text": "0.1010",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 209,
      "question": "Wartość 1/10 ma postać w systemie binarnym:",
      "options": [
        {
          "key": "a",
          "text": "0.1010",
          "correct": false
        },
        {
          "key": "b",
          "text": "0.0(0011)",
          "correct": true
        },
        {
          "key": "c",
          "text": "0.(1010)",
          "correct": false
        },
        {
          "key": "d",
          "text": "0.0(1010)",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 210,
      "question": "Język formalny jest:",
      "options": [
        {
          "key": "a",
          "text": "sposobem zapisu algorytmów opartym na blokach operacyjnych",
          "correct": false
        },
        {
          "key": "b",
          "text": "sposobem zapisu algorytmów opartym na pseudokodzie",
          "correct": true
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 211,
      "question": "Syntaktyka języka programowania opisuje:",
      "options": [
        {
          "key": "a",
          "text": "znaczenie instrukcji w języku",
          "correct": false
        },
        {
          "key": "b",
          "text": "formalnie poprawne programy",
          "correct": false
        },
        {
          "key": "c",
          "text": "budowę instrukcji w języku",
          "correct": true
        },
        {
          "key": "d",
          "text": "działanie poprawnego programu",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 212,
      "question": "Semantyka języka programowania opisuje:",
      "options": [
        {
          "key": "a",
          "text": "znaczenie instrukcji w języku",
          "correct": true
        },
        {
          "key": "b",
          "text": "formalnie poprawne programy",
          "correct": false
        },
        {
          "key": "c",
          "text": "budowę instrukcji w języku",
          "correct": false
        },
        {
          "key": "d",
          "text": "działanie poprawnego programu",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 213,
      "question": "Nawiasy <> w notacji EBNF oznaczają:",
      "options": [
        {
          "key": "a",
          "text": "opcjonalne wystąpienie elementu",
          "correct": false
        },
        {
          "key": "b",
          "text": "symbol terminalny",
          "correct": false
        },
        {
          "key": "c",
          "text": "symbol nieterminalny",
          "correct": true
        },
        {
          "key": "d",
          "text": "wielokrotne występowanie elementu",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 214,
      "question": "Kodem ASCII możemy zakodować:",
      "options": [
        {
          "key": "a",
          "text": "dowolny znak z zakresu 0-128",
          "correct": false
        },
        {
          "key": "b",
          "text": "dowolny znak z zakresu 0-255",
          "correct": false
        },
        {
          "key": "c",
          "text": "dowolny znak z zakresu 32-255",
          "correct": false
        },
        {
          "key": "d",
          "text": "dowolny znak z zakresu 0-127",
          "correct": true
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 215,
      "question": "Kodowanie znaków metodą UTF-8 cechuje:",
      "options": [
        {
          "key": "a",
          "text": "pozwala zakodować dowolne znaki Unicode",
          "correct": true
        },
        {
          "key": "b",
          "text": "zmienna długość kodu",
          "correct": true
        },
        {
          "key": "c",
          "text": "pozwala zakodować dowolne znaki ASCII za pomocą 1 bajta",
          "correct": true
        },
        {
          "key": "d",
          "text": "pozwala zakodować dowolne znaki ASCII za pomocą 8 bajtów",
          "correct": false
        },
        {
          "key": "e",
          "text": "pozwala zakodować dowolne znaki Unicode za pomocą nie więcej niż 6 bajtów",
          "correct": true
        },
        {
          "key": "f",
          "text": "kod znaku ASCII może być częścią dłuższego kodu",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": true
    },
    {
      "id": 216,
      "question": "Cechami kodu uzupełnień do dwóch są:",
      "options": [
        {
          "key": "a",
          "text": "podwójna reprezentacja 0",
          "correct": false
        },
        {
          "key": "b",
          "text": "pojedyncza reprezentacja 0",
          "correct": true
        },
        {
          "key": "c",
          "text": "symetryczny zakres liczb",
          "correct": false
        },
        {
          "key": "d",
          "text": "asymetryczny zakres liczb",
          "correct": true
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": true
    },
    {
      "id": 217,
      "question": "Dana jest następująca reprezentacja liczb zmiennopozycyjnych: mantysa zajmuje 22 bity, w tym bit znaku, cecha zajmuje 10 bitów, w tym bit znaku. Cecha i mantysa zapisywane są w kodzie U2. Przecinek leży na lewo od mantysy (mantysa jest ułamkiem [1/2...1)). Jaka jest największa możliwa liczba w tym systemie?",
      "options": [
        {
          "key": "a",
          "text": "10^10",
          "correct": false
        },
        {
          "key": "b",
          "text": "(1-2^(-21)) * 2^(2^9-1)",
          "correct": true
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 218,
      "question": "Jaka jest minimalna liczba bitów, aby reprezentować liczby zmiennopozycyjne z zakresu -106...106 z dokładnością do 2 miejsc znaczących?",
      "options": [
        {
          "key": "a",
          "text": "8 bitów",
          "correct": false
        },
        {
          "key": "b",
          "text": "12 bitów",
          "correct": true
        },
        {
          "key": "c",
          "text": "4 bity",
          "correct": false
        },
        {
          "key": "d",
          "text": "14 bitów",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 219,
      "question": "W standardzie IEEE 754 liczby zmiennopozycyjne podwójnej precyzji:",
      "options": [
        {
          "key": "a",
          "text": "mantysa zawiera 52 bity łącznie z bitem znaku",
          "correct": false
        },
        {
          "key": "b",
          "text": "mantysa zawiera 53 bity łącznie z bitem znaku",
          "correct": true
        },
        {
          "key": "c",
          "text": "wykładnik zawiera 11 bitów",
          "correct": true
        },
        {
          "key": "d",
          "text": "wykładnik zawiera 12 bitów",
          "correct": false
        },
        {
          "key": "e",
          "text": "gwarantują 7-8 dziesiętnych miejsc znaczących",
          "correct": true
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": true
    },
    {
      "id": 220,
      "question": "Do czego służy stos systemowy?",
      "options": [
        {
          "key": "a",
          "text": "do przechowywania wszystkich zmiennych w programie",
          "correct": false
        },
        {
          "key": "b",
          "text": "do przechowywania zmiennych alokowanych procedurą ^^new(p)^^",
          "correct": false
        },
        {
          "key": "c",
          "text": "do przechowywania zmiennych lokalnych procedur i funkcji",
          "correct": true
        },
        {
          "key": "d",
          "text": "do przechowywania adresów powrotu z funkcji",
          "correct": true
        },
        {
          "key": "e",
          "text": "do przechowywania zmiennych alokowanych dynamicznie",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": true
    },
    {
      "id": 221,
      "question": "Liczby stałopozycyjne w komputerze są reprezentowane w kodzie uzupełnień do 2. Dla jakich wartości funkcja abs(x) będzie obliczona prawidłowo?",
      "options": [
        {
          "key": "a",
          "text": "tylko dla liczb ujemnych",
          "correct": false
        },
        {
          "key": "b",
          "text": "tylko dla liczb nieujemnych",
          "correct": false
        },
        {
          "key": "c",
          "text": "dla wszystkich liczb typu integer",
          "correct": false
        },
        {
          "key": "d",
          "text": "wszystkich poza najmniejszą liczbą w reprezentacji",
          "correct": true
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 222,
      "question": "Zmienna typu wskaźnik zajmuje 4 bajty. Ile pamięci można zaadresować takim wskaźnikiem?",
      "options": [
        {
          "key": "a",
          "text": "64 kilobajty",
          "correct": false
        },
        {
          "key": "b",
          "text": "4 gigabajty",
          "correct": true
        },
        {
          "key": "c",
          "text": "2 megabajty",
          "correct": false
        },
        {
          "key": "d",
          "text": "6 gigabajtów",
          "correct": false
        },
        {
          "key": "e",
          "text": "8 kilobajtów",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": false
    },
    {
      "id": 223,
      "question": "Jaki paradygmat programowania jest realizowany w języku C?",
      "options": [
        {
          "key": "a",
          "text": "aplikatywny",
          "correct": false
        },
        {
          "key": "b",
          "text": "imperatywny",
          "correct": true
        },
        {
          "key": "c",
          "text": "deklaratywny",
          "correct": false
        },
        {
          "key": "d",
          "text": "strukturalny",
          "correct": true
        },
        {
          "key": "e",
          "text": "żaden z wymienionych",
          "correct": false
        }
      ],
      "topic": "programming_basics",
      "semester": 2,
      "courseName": "Podstawy programowania",
      "multipleCorrect": true
    },
    {
      "id": 224,
      "question": "Jeżeli w programie następuje odwołanie poza obszar tablicy:",
      "options": [
        {
          "key": "a",
          "text": "zawsze sygnalizowany jest błąd wykonania",
          "correct": false
        },
        {
          "key": "b",
          "text": "nie jest sygnalizowany błąd, jeżeli pamięć jest zaalokowana",
          "correct": true
        }
      ],
      "topic": "programming_basics",
      "semester": 2,
      "courseName": "Podstawy programowania",
      "multipleCorrect": false
    },
    {
      "id": 225,
      "question": "Translacja analizuje symbole:",
      "options": [
        {
          "key": "a",
          "text": "od lewej do prawej strony",
          "correct": true
        },
        {
          "key": "b",
          "text": "od prawej do lewej strony",
          "correct": false
        }
      ],
      "topic": "programming_basics",
      "semester": 2,
      "courseName": "Podstawy programowania",
      "multipleCorrect": false
    },
    {
      "id": 226,
      "question": "Jaki wynik da następujące wyrażenie napisane w ONP: 2 3 4 5 + * +?",
      "options": [
        {
          "key": "a",
          "text": "25",
          "correct": false
        },
        {
          "key": "b",
          "text": "29",
          "correct": true
        }
      ],
      "topic": "programming_basics",
      "semester": 2,
      "courseName": "Podstawy programowania",
      "multipleCorrect": false
    },
    {
      "id": 227,
      "question": "Co oznacza, że algorytm sortowania tablicy posiada złożoność ^^O(n^2)^^?",
      "options": [
        {
          "key": "a",
          "text": "wykonywana liczba porównań wynosi ^^n^2^^",
          "correct": false
        },
        {
          "key": "b",
          "text": "wykonywana liczba porównań jest rzędu ^^n^2^^",
          "correct": true
        },
        {
          "key": "c",
          "text": "wykonywana liczba przestawień elementów tablicy w algorytmie wynosi ^^n^2^^",
          "correct": false
        },
        {
          "key": "d",
          "text": "dwukrotne zwiększenie rozmiaru tablicy spowoduje czterokrotne zwiększenie czasu sortowania",
          "correct": true
        },
        {
          "key": "e",
          "text": "wykonywana liczba porównań i wykonywana liczba przestawień elementów tablicy w algorytmie wynosi ^^n^2^^",
          "correct": false
        },
        {
          "key": "f",
          "text": "wykonywana liczba porównań lub wykonywana liczba przestawień elementów tablicy w algorytmie wynosi ^^n^2^^",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 2,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 228,
      "question": "Jakie byłyby konsekwencje znalezienia wielomianowego deterministycznego algorytmu dla problemu NP-zupełnego?",
      "options": [
        {
          "key": "a",
          "text": "stanowiłoby to dowód, że P = NP",
          "correct": true
        },
        {
          "key": "b",
          "text": "oznaczałoby to, że P =/= NP",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie miałoby to żadnych konsekwencji dla teorii złożoności obliczeniowej",
          "correct": false
        },
        {
          "key": "d",
          "text": "żadna z pozostałych odpowiedzi",
          "correct": false
        },
        {
          "key": "e",
          "text": "każdy problem algorytmiczny można byłoby rozwiązać w czasie wielomianowym",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 2,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 229,
      "question": "Jakie problemy zaliczamy do klasy problemów NP-zupełnych?",
      "options": [
        {
          "key": "a",
          "text": "z definicji należą jednocześnie do NP i co-NP",
          "correct": false
        },
        {
          "key": "b",
          "text": "należą do klasy NP, ale nie należą do P",
          "correct": false
        },
        {
          "key": "c",
          "text": "żadna z pozostałych odpowiedzi",
          "correct": false
        },
        {
          "key": "d",
          "text": "wszystkie problemy z klasy NP redukują się do nich i same należą do klasy NP",
          "correct": true
        },
        {
          "key": "e",
          "text": "takie, które są w NP i redukuje się do nich problem SAT",
          "correct": true
        },
        {
          "key": "f",
          "text": "takie, które są w NP i redukują się do problemu SAT",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 2,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 230,
      "question": "Co można powiedzieć o podproblemach problemu ^^\\pi^^, wiedząc, że ^^\\pi \\notin P^^?",
      "options": [
        {
          "key": "a",
          "text": "żaden jego podproblem nie należy do P",
          "correct": false
        },
        {
          "key": "b",
          "text": "każdy jego podproblem należy do klasy P",
          "correct": false
        },
        {
          "key": "c",
          "text": "pojęcie podproblemu nie jest zdefiniowane",
          "correct": false
        },
        {
          "key": "d",
          "text": "istnieje taki jego podproblem, który należy do P",
          "correct": true
        }
      ],
      "topic": "algorithms",
      "semester": 2,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 231,
      "question": "Która z poniższych złożoności czasowych jest wykładnicza:",
      "options": [
        {
          "key": "a",
          "text": "^^O(n^100)^^",
          "correct": false
        },
        {
          "key": "b",
          "text": "^^O(n^{1/n!})^^",
          "correct": false
        },
        {
          "key": "c",
          "text": "^^O((\\log{10})^n)^^",
          "correct": true
        },
        {
          "key": "d",
          "text": "^^O(n!)^^",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 2,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 232,
      "question": "Co nazywamy mostem grafu?",
      "options": [
        {
          "key": "a",
          "text": "minimalną liczbę krawędzi grafu, których usunięcie zmienia graf w niespójny lub trywialny",
          "correct": false
        },
        {
          "key": "b",
          "text": "krawędź grafu spójnego, której usunięcie z grafu rozspójnia go",
          "correct": true
        },
        {
          "key": "c",
          "text": "krawędź, której usunięcie zwiększa liczbę spójnych składowych grafu",
          "correct": true
        },
        {
          "key": "d",
          "text": "maksymalną liczbę krawędzi grafu, których usunięcie zmienia graf w niespójny",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 2,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 233,
      "question": "W teorii złożoności obliczeniowej wszystkie problemy decyzyjne, które w wielomianowym czasie rozwiązuje niedeterministyczna maszyna Turinga, tworzą pewną klasę problemów. Jak brzmi jej nazwa?",
      "options": [
        {
          "key": "a",
          "text": "klasa NP",
          "correct": true
        },
        {
          "key": "b",
          "text": "klasa P",
          "correct": false
        },
        {
          "key": "c",
          "text": "klasa coNP",
          "correct": false
        },
        {
          "key": "d",
          "text": "klasa RE",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 2,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1001,
      "question": "Które z poniższych twierdzeń jest prawdziwe dotyczące złożoności Quicksort?",
      "options": [
        {
          "key": "a",
          "text": "Pesymistyczna złożoność obliczeniowa dla sortowania Quicksort to O(n log n)",
          "correct": false
        },
        {
          "key": "b",
          "text": "Pesymistyczna złożoność obliczeniowa dla sortowania Quicksort to O(n^2)",
          "correct": true
        },
        {
          "key": "c",
          "text": "Średnia złożoność obliczeniowa dla sortowania Quicksort to O(n^2)",
          "correct": false
        },
        {
          "key": "d",
          "text": "Najlepsza złożoność obliczeniowa dla sortowania Quicksort to O(n!)",
          "correct": false
        },
        {
          "key": "e",
          "text": "Quicksort jest algorytmem stabilnym",
          "correct": false
        },
        {
          "key": "f",
          "text": "Quicksort zawsze wymaga O(n) dodatkowej pamięci",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1002,
      "question": "Wskaż zdania prawdziwe dotyczące algorytmu Dijkstry:",
      "options": [
        {
          "key": "a",
          "text": "Algorytm Dijkstry znajdowania najkrótszych ścieżek jest algorytmem heurystycznym o złożoności O(n2 log n).",
          "correct": false
        },
        {
          "key": "b",
          "text": "Algorytm Dijkstry znajduje najkrótsze ścieżki z jednego źródła w grafie o nieujemnych wagach krawędzi.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Algorytm Dijkstry poprawnie obsługuje grafy z ujemnymi wagami krawędzi.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Złożoność algorytmu Dijkstry przy użyciu kopca binarnego wynosi O(E log V).",
          "correct": true
        },
        {
          "key": "e",
          "text": "Algorytm Dijkstry służy do wyznaczania minimalnego drzewa rozpinającego.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Algorytm Dijkstry jest algorytmem typu \"dziel i zwyciężaj\".",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 1003,
      "question": "Które z poniższych stwierdzeń jest prawdziwe dotyczące algorytmu DFS?",
      "options": [
        {
          "key": "a",
          "text": "Algorytm DFS służy do wyznaczania minimalnego drzewa rozpinającego dla grafu skierowanego.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Algorytm DFS (Depth-First Search) może być wykorzystany do wykrywania cykli w grafie.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Algorytm DFS zawsze znajduje najkrótszą ścieżkę w grafie nieskierowanym bez wag.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Algorytm DFS wykorzystuje kolejkę FIFO jako podstawową strukturę danych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Złożoność czasowa DFS wynosi O(V^2) dla reprezentacji listowej.",
          "correct": false
        },
        {
          "key": "f",
          "text": "DFS nie pozwala na wyznaczenie czasu wejścia i wyjścia z węzła.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1004,
      "question": "Które z poniższych twierdzeń jest prawdziwe dotyczące tablic mieszających?",
      "options": [
        {
          "key": "a",
          "text": "Adresowanie otwarte to jedna ze strategii rozwiązywania kolizji w tablicach haszujących (tablicach mieszających).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Adresowanie otwarte polega na tworzeniu listy wiązanej dla każdego indeksu tablicy.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Funkcja mieszająca musi zawsze zwracać unikalną wartość dla każdego klucza (brak kolizji).",
          "correct": false
        },
        {
          "key": "d",
          "text": "Tablica mieszająca gwarantuje czas dostępu O(1) w najgorszym przypadku niezależnie od liczby kolizji.",
          "correct": false
        },
        {
          "key": "e",
          "text": "W adresowaniu otwartym współczynnik wypełnienia może być dowolnie duży.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Metoda łańcuchowa jest rodzajem adresowania otwartego.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1005,
      "question": "Które stwierdzenia dotyczące notacji asymptotycznych i sortowania są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "Sekwencyjny algorytm sortowania przez porównania elementów w tablicy nie może działać z mniejszą złożonością niż Ω(n log n).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Sortowanie przez wstawianie ma pesymistyczną złożoność O(n log n).",
          "correct": false
        },
        {
          "key": "c",
          "text": "Notacja O(f(n)) oznacza dolne ograniczenie asymptotyczne.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Każdy algorytm sortowania ma złożoność pamięciową O(1).",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jeśli f(n) = O(g(n)), to g(n) jest asymptotycznym ograniczeniem górnym dla f(n).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Algorytm o złożoności O(n^2) jest zawsze szybszy niż O(n log n) dla dużych n.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 1006,
      "question": "Zadanie o rozmiarze n realizowane algorytmem o złożoności f(n) zostało sprowadzone do dwóch pod-zadań o wielkości 1/n oraz wykonania n operacji o stałym koszcie wykonania. Złożoność f(n) wynosi",
      "options": [
        {
          "key": "a",
          "text": "O(n log n)",
          "correct": true
        },
        {
          "key": "b",
          "text": "O(n)",
          "correct": false
        },
        {
          "key": "c",
          "text": "O(n^2)",
          "correct": false
        },
        {
          "key": "d",
          "text": "O(log n)",
          "correct": false
        },
        {
          "key": "e",
          "text": "O(1)",
          "correct": false
        },
        {
          "key": "f",
          "text": "O(n!)",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1007,
      "question": "Do drzewa BST wstawiono losowy zestaw n wzajemnie różnych liczb. Która z odpowiedzi jest prawdziwa?",
      "options": [
        {
          "key": "a",
          "text": "Pesymistyczna złożoność operacji usuwania elementu w drzewie każdorazowo zależy od głębokości danego drzewa.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Średnia wysokość takiego drzewa wynosi O(n).",
          "correct": false
        },
        {
          "key": "c",
          "text": "Operacja wyszukiwania w takim drzewie zawsze zajmuje O(log n) czasu w najgorszym przypadku.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Drzewo BST po wstawieniu losowych elementów zawsze staje się drzewem AVL.",
          "correct": false
        },
        {
          "key": "e",
          "text": "In-order przechodzenie przez BST nie daje posortowanej sekwencji.",
          "correct": false
        },
        {
          "key": "f",
          "text": "BST zawsze gwarantuje logarytmiczny czas operacji.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1008,
      "question": "Uruchomiono operację budowania kopca dla tablicy dziesięciu elementów: 1,2,3,4,5,6,7,8,9,0. Czy prawdziwe są w odniesieniu do powstałego drzewa następujące stwierdzenia:",
      "options": [
        {
          "key": "a",
          "text": "Ze względu na wykorzystanie operacji rotacji przy wstawianiu elementów głębokość kopca będzie wynosić O(log n).",
          "correct": false
        },
        {
          "key": "b",
          "text": "Operacja budowania kopca (build-heap) dla n elementów ma złożoność czasową O(n).",
          "correct": true
        },
        {
          "key": "c",
          "text": "Kopiec binarny jest zawsze drzewem pełnym (wszystkie liście na tym samym poziomie).",
          "correct": false
        },
        {
          "key": "d",
          "text": "W kopcu typu max element o najmniejszej wartości zawsze znajduje się w korzeniu.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Kopiec binarny nie może być reprezentowany w tablicy.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Budowanie kopca metodą kolejnych wstawiań ma złożoność O(n).",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1009,
      "question": "Które stwierdzenia z poniższych są prawdziwe dotyczące algorytmów sortowania?",
      "options": [
        {
          "key": "a",
          "text": "Sortowanie przez zliczanie (ang. Counting Sort) ma lepszą złożoność obliczeniową niż sortowanie szybkie (ang. QuickSort) dla dowolnych danych wejściowych.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Sortowanie przez zliczanie ma złożoność O(n + k), gdzie k to zakres wartości, co może być lepsze od O(n log n) dla małych k.",
          "correct": true
        },
        {
          "key": "c",
          "text": "QuickSort jest algorytmem stabilnym.",
          "correct": false
        },
        {
          "key": "d",
          "text": "MergeSort nie wymaga dodatkowej pamięci (działa w miejscu).",
          "correct": false
        },
        {
          "key": "e",
          "text": "Sortowanie przez zliczanie jest algorytmem stabilnym.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Heapsort jest algorytmem stabilnym.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 1010,
      "question": "Wskaż odpowiedzi prawdziwe dotyczące list przeskakiwania:",
      "options": [
        {
          "key": "a",
          "text": "Lista przeskakiwania (skip list) może być rozważana jako probabilistyczna alternatywa drzewa AVL.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Operacje wyszukiwania, wstawiania i usuwania w liście przeskakiwania mają średnią złożoność O(log n).",
          "correct": true
        },
        {
          "key": "c",
          "text": "Lista przeskakiwania wymaga, aby dane były przechowywane w sposób nieposortowany.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Każdy element w liście przeskakiwania ma zawsze taką samą liczbę wskaźników do przodu.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Lista przeskakiwania gwarantuje pesymistyczny czas wyszukiwania O(log n).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Skip list nie wymaga dodatkowej pamięci na wskaźniki.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 1011,
      "question": "Zbudowano drzewo binarne zawierające liczby od 1, 2, do 15 w ten sposób, że jako korzeń drzewa wzięto 1, jako jego dzieci liczby 2 i 3 a w kolejnym rzędzie 4,5,6,7 tak, że 4 i 5 to dzieci węzła o kluczu 2 a 6, 7 to dzieci węzła z kluczem 4. Podobnie, w kolejnym rzędzie utworzono węzły od 8 do 15.",
      "options": [
        {
          "key": "a",
          "text": "15, 1, 2, 3 ,4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15",
          "correct": false
        },
        {
          "key": "b",
          "text": "15, 7, 3, 1, 2, 4, 8, 9, 5, 10, 11, 6, 12, 13, 14",
          "correct": true
        },
        {
          "key": "c",
          "text": "1, 2, 4, 8, 9, 5, 10, 11, 3, 6, 12, 13, 7, 14, 15",
          "correct": false
        },
        {
          "key": "d",
          "text": "15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1",
          "correct": false
        },
        {
          "key": "e",
          "text": "15, 7, 14, 3, 6, 12, 13, 1, 2, 4, 8, 9, 5, 10, 11",
          "correct": false
        },
        {
          "key": "f",
          "text": "1, 3, 7, 15, 14, 6, 13, 12, 2, 5, 11, 10, 4, 9, 8",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1012,
      "question": "Zbudowano drzewo binarne zawierające liczby od 1, 2, do 15 w ten sposób, że jako korzeń drzewa wzięto 1, jako jego dzieci liczby 2 i 3 a w kolejnym rzędzie 4,5,6,7 tak, że 4 i 5 to dzieci węzła o kluczu 2 a 6, 7 to dzieci węzła z kluczem 4. Podobnie, w kolejnym rzędzie utworzono węzły od 8 do 15. Określ prawdziwość następujacych stwierdzeń:",
      "options": [
        {
          "key": "a",
          "text": "15, 7, 3, 1, 14 , 6 ,1, 30, 13, 4, 5, 8, 9, 10, 11",
          "correct": false
        },
        {
          "key": "b",
          "text": "Kolejność In-order dla pełnego drzewa binarnego wypełnionego poziomami od 1 do 15 to: 8, 4, 9, 2, 10, 5, 11, 1, 12, 6, 13, 3, 14, 7, 15",
          "correct": true
        },
        {
          "key": "c",
          "text": "Węzeł 1 jest ostatnim węzłem w przejściu In-order.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Węzeł 15 jest korzeniem tego drzewa.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Przejście In-order dla tego drzewa daje liczby w kolejności rosnącej.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Węzeł 8 jest korzeniem lewego poddrzewa.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 1,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1013,
      "question": "Rachunek predykatów:",
      "options": [
        {
          "key": "a",
          "text": "nie zawiera żadnych aksjomatów dla kwantyfikatorów.",
          "correct": false
        },
        {
          "key": "b",
          "text": "zawiera reguły wnioskowania i aksjomaty dotyczące kwantyfikatorów ogólnego i egzystencjalnego.",
          "correct": true
        },
        {
          "key": "c",
          "text": "jest tożsamy z klasycznym rachunkiem zdań.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie pozwala na używanie symboli relacyjnych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "rozszerza rachunek zdań o kwantyfikatory i symbole relacyjne/funkcyjne.",
          "correct": true
        },
        {
          "key": "f",
          "text": "jest rozstrzygalny w sensie ogólnym.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": true
    },
    {
      "id": 1014,
      "question": "Prawo transpozycji (p -> q) <=> (~q -> ~p):",
      "options": [
        {
          "key": "a",
          "text": "Pozwala przyjąć, że prawdziwość zdania: \"Jeśli Kopernik nie urodził się w Krakowie, to Kepler nie urodził się w Toruniu\" pociąga prawdziwość zdania: \"jeśli Kepler urodził się w Toruniu, to Kopernik urodził się w Krakowie\".",
          "correct": true
        },
        {
          "key": "b",
          "text": "Orzeka, że z fałszywości implikacji wynika prawdziwość jej następnika.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest podstawą dowodów wprost w matematyce.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Mówi, że koniunkcja jest przemienna.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Głosi, że z p -> q wynika ~p -> ~q.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Dotyczy wyłącznie kwantyfikatorów ogólnych.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": false
    },
    {
      "id": 1015,
      "question": "Teorią w sensie logicznym w ustalonym języku L nazywamy:",
      "options": [
        {
          "key": "a",
          "text": "zbiór wszystkich konsekwencji logicznych zbioru zdań mających swój dowód w tej teorii.",
          "correct": false
        },
        {
          "key": "b",
          "text": "zbiór zdań zamknięty ze względu na operację konsekwencji.",
          "correct": true
        },
        {
          "key": "c",
          "text": "dowolny zbiór formuł otwartych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "zbiór wszystkich tautologii danego języka.",
          "correct": false
        },
        {
          "key": "e",
          "text": "zbiór aksjomatów, które nie są ze sobą spójne.",
          "correct": false
        },
        {
          "key": "f",
          "text": "dowolny zbiór słów nad alfabetem L.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": false
    },
    {
      "id": 1016,
      "question": "Model dla teorii rachunku predykatów:",
      "options": [
        {
          "key": "a",
          "text": "Musi zawierać symbole funkcyjne, interpretujące w modelu zmienne języka tej teorii.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Składa się z niepustej dziedziny oraz interpretacji symboli predykatywnych, funkcyjnych i stałych.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Jest zawsze skończony.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie zależy od języka teorii.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest zbiorem wszystkich zdań prawdziwych w danej teorii.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Może mieć pustą dziedzinę (uniwersum).",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": false
    },
    {
      "id": 1017,
      "question": "Twierdzenie o pełności dla klasycznego rachunku zdań orzeka, że:",
      "options": [
        {
          "key": "a",
          "text": "Każde zdanie klasycznego rachunku zdań jest formułą (w jego języku), lecz nie każda formuła jest zdaniem.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Każda tautologia jest dowodliwa w systemie aksjomatycznym.",
          "correct": true
        },
        {
          "key": "c",
          "text": "System logiczny jest niespójny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Każdy model jest skończony.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Każdy zbiór zdań sprzecznych posiada model.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Rachunek zdań jest niezupełny.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": false
    },
    {
      "id": 1018,
      "question": "W języku rachunku predykatów wyróżnić możemy:",
      "options": [
        {
          "key": "a",
          "text": "wyłącznie termy, bez żadnych typów formuł.",
          "correct": false
        },
        {
          "key": "b",
          "text": "termy, formuły atomowe oraz formuły złożone (z użyciem spójników i kwantyfikatorów).",
          "correct": true
        },
        {
          "key": "c",
          "text": "tylko stałe i zmienne, bez predykatów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "wyłącznie kwantyfikatory.",
          "correct": false
        },
        {
          "key": "e",
          "text": "tylko zdania, bez formuł otwartych.",
          "correct": false
        },
        {
          "key": "f",
          "text": "wyłącznie symbole relacyjne.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": false
    },
    {
      "id": 1019,
      "question": "Zdanie \"Jeśli Słowacki wielkim poetą był, to jeśli przez Kraków przepływa Nil, to Słowacki wielkim poetą był\" (schemat p -> (q -> p)) jest:",
      "options": [
        {
          "key": "a",
          "text": "nie da się ocenić bez znajomości jego modelu",
          "correct": false
        },
        {
          "key": "b",
          "text": "tautologią klasycznego rachunku zdań.",
          "correct": true
        },
        {
          "key": "c",
          "text": "zdaniem zawsze fałszywym (kontrtautologią).",
          "correct": false
        },
        {
          "key": "d",
          "text": "zdaniem spełnialnym, ale nie będącym tautologią.",
          "correct": false
        },
        {
          "key": "e",
          "text": "zdaniem przygodnym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "zdaniem fałszywym w modelu standardowym.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": false
    },
    {
      "id": 1020,
      "question": "Tautologia rachunku predykatów to:",
      "options": [
        {
          "key": "a",
          "text": "formuła prawdziwa w każdym modelu (przy każdej interpretacji).",
          "correct": true
        },
        {
          "key": "b",
          "text": "formuła prawdziwa w przynajmniej jednym modelu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "formuła, która nie zawiera kwantyfikatorów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "zdanie, które jest prawdziwe w modelu standardowym liczb naturalnych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "formuła, która posiada dowód w arytmetyce Peano.",
          "correct": false
        },
        {
          "key": "f",
          "text": "zdanie, które jest fałszywe w przynajmniej jednym modelu.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": false
    },
    {
      "id": 1021,
      "question": "Logika pierwszego rzędu to:",
      "options": [
        {
          "key": "a",
          "text": "logika bez żadnych kwantyfikatorów",
          "correct": false
        },
        {
          "key": "b",
          "text": "logika dopuszczająca kwantyfikowanie wyłącznie po zmiennych obiektowych (indywiduach).",
          "correct": true
        },
        {
          "key": "c",
          "text": "logika dopuszczająca kwantyfikowanie po zbiorach i relacjach.",
          "correct": false
        },
        {
          "key": "d",
          "text": "system logiczny, w którym nie istnieją zmienne.",
          "correct": false
        },
        {
          "key": "e",
          "text": "logika, w której nie można definiować relacji.",
          "correct": false
        },
        {
          "key": "f",
          "text": "logika, w której każdy model jest skończony.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": false
    },
    {
      "id": 1022,
      "question": "Kwantyfikatory \"istnieje takie x, że\" oraz \"dla każdego x, takiego, że\":",
      "options": [
        {
          "key": "a",
          "text": "mają swoje semantyczne interpretacje w modelach dla języka, w którym występują.",
          "correct": true
        },
        {
          "key": "b",
          "text": "są spójnikami logicznymi o argumentach zdaniowych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie mogą występować w jednej formule jednocześnie.",
          "correct": false
        },
        {
          "key": "d",
          "text": "odnoszą się wyłącznie do zbiorów skończonych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "są definiowane wyłącznie przez reguły syntaktyczne.",
          "correct": false
        },
        {
          "key": "f",
          "text": "nie podlegają negacji.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": false
    },
    {
      "id": 1023,
      "question": "Funkcja interpretacji semantycznej, określonej dla języka rachunku predykatów:",
      "options": [
        {
          "key": "a",
          "text": "interpretuje predykaty jako relacje w dziedzinie modelu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "przypisuje każdemu zdaniu wartość \"prawda\" niezależnie od modelu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "interpretuje zmienne wolne jako kwantyfikatory ogólne.",
          "correct": false
        },
        {
          "key": "d",
          "text": "służy wyłącznie do upraszczania formuł.",
          "correct": false
        },
        {
          "key": "e",
          "text": "interpretuje symbole funkcyjne jako funkcje w dziedzinie modelu.",
          "correct": true
        },
        {
          "key": "f",
          "text": "przypisuje każdemu termowi wartość logiczną.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": true
    },
    {
      "id": 1024,
      "question": "Twierdzenie o dedukcji:",
      "options": [
        {
          "key": "a",
          "text": "pozwala przenieść przesłanki do treści implikacji we wniosku (jeśli ze zbioru G i zdania A wynika B, to z G wynika A -> B).",
          "correct": true
        },
        {
          "key": "b",
          "text": "pozwala przenieść przesłanki do zbioru wniosków.",
          "correct": false
        },
        {
          "key": "c",
          "text": "mówi, że każda teoria jest rozstrzygalna.",
          "correct": false
        },
        {
          "key": "d",
          "text": "dotyczy wyłącznie rachunku predykatów z identycznością.",
          "correct": false
        },
        {
          "key": "e",
          "text": "orzeka o pełności systemu logicznego.",
          "correct": false
        },
        {
          "key": "f",
          "text": "mówi, że z A wynika B wtedy i tylko wtedy, gdy A jest fałszywe.",
          "correct": false
        }
      ],
      "topic": "logic",
      "semester": 1,
      "courseName": "Logika",
      "multipleCorrect": false
    },
    {
      "id": 1025,
      "question": "Każda permutacja zbioru skończonego:",
      "options": [
        {
          "key": "a",
          "text": "może być w sposób jednoznaczny rozłożona na niekoniecznie rozłączne transpozycje.",
          "correct": false
        },
        {
          "key": "b",
          "text": "może być rozłożona na iloczyn rozłącznych cykli w sposób jednoznaczny (z dokładnością do kolejności czynników).",
          "correct": true
        },
        {
          "key": "c",
          "text": "jest zawsze transpozycją.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie może być przedstawiona jako złożenie cykli.",
          "correct": false
        },
        {
          "key": "e",
          "text": "ma zawsze parzystą liczbę inwersji.",
          "correct": false
        },
        {
          "key": "f",
          "text": "jest cyklem o długości n.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1026,
      "question": "W grafie właściwym nieskierowanym:",
      "options": [
        {
          "key": "a",
          "text": "najniższy stopień węzła może być mniejszy od spójności krawędziowej.",
          "correct": false
        },
        {
          "key": "b",
          "text": "spójność krawędziowa jest zawsze mniejsza lub równa minimalnemu stopniowi wierzchołka (lambda(G) <= delta(G)).",
          "correct": true
        },
        {
          "key": "c",
          "text": "liczba wierzchołków o stopniu nieparzystym musi być nieparzysta.",
          "correct": false
        },
        {
          "key": "d",
          "text": "suma stopni wierzchołków jest równa liczbie krawędzi.",
          "correct": false
        },
        {
          "key": "e",
          "text": "spójność wierzchołkowa jest zawsze większa od krawędziowej.",
          "correct": false
        },
        {
          "key": "f",
          "text": "graf jest drzewem, jeśli ma n krawędzi.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1027,
      "question": "Grupa symetrii danej figury geometrycznej to grupa tych przekształceń płaszczyzny, względem których danafigura jest niezmiennicza. Działaniem grupowym jest składanie przekształceń.",
      "options": [
        {
          "key": "a",
          "text": "Grupa symetrii siedmiokąta foremnego jest siedmioelementowa.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Jest grupą dihedralną D7 i posiada 14 elementów (7 obrotów i 7 symetrii osiowych).",
          "correct": true
        },
        {
          "key": "c",
          "text": "Jest grupą cykliczną Z7.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie zawiera żadnych symetrii osiowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest grupą abelową.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Zawiera dokładnie 49 elementów.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1028,
      "question": "Grupą nie jest:",
      "options": [
        {
          "key": "a",
          "text": "(C[0,1], +) - zbiór wszystkich funkcji ciągłych o dziedzinie w [0,1] z dodawaniem funkcji po wartościach jako działanie grupowym.",
          "correct": false
        },
        {
          "key": "b",
          "text": "(N, +) - zbiór liczb naturalnych z dodawaniem.",
          "correct": true
        },
        {
          "key": "c",
          "text": "(Z, +) - zbiór liczb całkowitych z dodawaniem.",
          "correct": false
        },
        {
          "key": "d",
          "text": "(R*, *) - zbiór liczb rzeczywistych bez zera z mnożeniem.",
          "correct": false
        },
        {
          "key": "e",
          "text": "(Q, +) - zbiór liczb wymiernych z dodawaniem.",
          "correct": false
        },
        {
          "key": "f",
          "text": "(Z_n, +_n) - zbiór reszt z dzielenia przez n z dodawaniem modulo n.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1029,
      "question": "Niech X będzie zbiorem częściowo uporządkowanym.",
      "options": [
        {
          "key": "a",
          "text": "Jeśli X jest skończony, to element maksymalny jest równocześnie elementem największym.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Jeśli X ma element największy, to jest on jedynym elementem maksymalnym.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Każdy zbiór częściowo uporządkowany ma element najmniejszy.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Relacja częściowego porządku jest zwrotna, symetryczna i przechodnia.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Każdy podzbiór X ma kres górny.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Element minimalny jest zawsze elementem najmniejszym.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1030,
      "question": "Kostką Qn nazywamy graf, którego wierzchołki są zaetykietowane wszystkimi możliwymi zerojedynkowymi ciągami n−elementowymi a krawędzie łączą te wierzchołki, których etykiety różnią się dokładnie na jednym miejscu.",
      "options": [
        {
          "key": "a",
          "text": "Kostka Q3 ma 8 wierzchołków i 12 krawędzi.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Kostka Qn ma n wierzchołków.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Kostka Qn jest grafem pełnym.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Każdy wierzchołek w Qn ma stopień 2^n.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Kostka Qn jest grafem planarnym dla każdego n.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Kostka Qn nie jest grafem dwudzielnym.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1031,
      "question": "Liczba chromatyczna grafu to minimalna liczba kolorów, jakimi można pokolorować wierzchołki grafu tak, aby żadne dwa wierzchołki połączone krawędzią nie były tego samego koloru.",
      "options": [
        {
          "key": "a",
          "text": "2",
          "correct": true
        },
        {
          "key": "b",
          "text": "3",
          "correct": false
        },
        {
          "key": "c",
          "text": "4",
          "correct": false
        },
        {
          "key": "d",
          "text": "8",
          "correct": false
        },
        {
          "key": "e",
          "text": "1",
          "correct": false
        },
        {
          "key": "f",
          "text": "5",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1032,
      "question": "Każdy zbiór częściowo uporządkowany:",
      "options": [
        {
          "key": "a",
          "text": "ma element maksymalny.",
          "correct": false
        },
        {
          "key": "b",
          "text": "może nie posiadać elementów maksymalnych ani minimalnych (np. zbiór liczb całkowitych z relacją <=).",
          "correct": true
        },
        {
          "key": "c",
          "text": "jest zawsze liniowo uporządkowany.",
          "correct": false
        },
        {
          "key": "d",
          "text": "musi być skończony.",
          "correct": false
        },
        {
          "key": "e",
          "text": "ma dokładnie jeden element najmniejszy.",
          "correct": false
        },
        {
          "key": "f",
          "text": "jest gęsty.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1033,
      "question": "Wskaż zdania prawdziwe dotyczące porządków:",
      "options": [
        {
          "key": "a",
          "text": "Zbiór liczb całkowitych z relacją arytmetyczną ”mniejsze lub równe” jest dobrze uporządkowany.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Zbiór liczb naturalnych z relacją ”mniejsze lub równe” jest dobrze uporządkowany.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Każdy porządek liniowy jest dobrym porządkiem.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Relacja inkluzji podzbiorów jest zawsze porządkiem liniowym.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Relacja podzielności na liczbach naturalnych jest porządkiem liniowym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Zbiór liczb rzeczywistych z relacją <= jest dobrze uporządkowany.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1034,
      "question": "Jeśli X jest zbiorem n−elementowym i Y jest zbiorem m-elementowym, n > 0, m > 0, to",
      "options": [
        {
          "key": "a",
          "text": "liczność rodziny wszystkich podzbiorów zbioru X (zbioru potęgowego) jest równa 2^n.",
          "correct": true
        },
        {
          "key": "b",
          "text": "liczba wszystkich permutacji zbioru X wynosi n^2.",
          "correct": false
        },
        {
          "key": "c",
          "text": "liczba k-elementowych podzbiorów zbioru X wynosi n! / k!.",
          "correct": false
        },
        {
          "key": "d",
          "text": "liczba relacji zwrotnych na zbiorze X wynosi 2^n.",
          "correct": false
        },
        {
          "key": "e",
          "text": "liczba wszystkich relacji na zbiorze X wynosi n^n.",
          "correct": false
        },
        {
          "key": "f",
          "text": "liczba wszystkich funkcji ze zbioru X w X wynosi n!.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1035,
      "question": "Niech Pn oznacza zbiór permutacji n-elementowych. W P3:",
      "options": [
        {
          "key": "a",
          "text": "istnieją dokładnie 2 permutacje cykliczne o długości 3.",
          "correct": true
        },
        {
          "key": "b",
          "text": "istnieje 6 permutacji cyklicznych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "każda permutacja jest cyklem.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie istnieje permutacja identycznościowa.",
          "correct": false
        },
        {
          "key": "e",
          "text": "liczba wszystkich permutacji wynosi 9.",
          "correct": false
        },
        {
          "key": "f",
          "text": "każda permutacja jest parzysta.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1036,
      "question": "Niech X będzie zbiorem n-elementowym (n > 2) i R będzie relacją równoważności na X.",
      "options": [
        {
          "key": "a",
          "text": "Liczba klas równoważności musi być podzielnikiem liczby n.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Klasy równoważności tworzą partycję (podział) zbioru X.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Każda klasa równoważności musi mieć tyle samo elementów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Relacja równoważności nie musi być przechodnia.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Liczba relacji równoważności na X jest równa 2^n.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Suma wszystkich klas równoważności jest zbiorem pustym.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 1,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1037,
      "question": "Liczby w formacie zmiennoprzecinkowym (wg standardu IEEE 754). Dodatnie liczby rzeczywiste z zakresu od 𝑉 𝐴𝐿𝑀𝐼𝑁 = 2.2 ⋅ 10−308 do 𝑉 𝐴𝐿𝑀𝐴𝑋 = 1.8 ⋅ 10308 są zapisywane w formacie podwójnej precyzji z względnym błędem zaokrąglenia nie większym od 𝜀 = 2−52 ≈ 2.2 ⋅ 10−16 . Które zdania są prawdziwe?",
      "options": [
        {
          "key": "a",
          "text": "Wszystkie liczby wymierne, poza całkowitymi, są reprezentowane z niezerowym błędem zaokrąglenia.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Liczby wymierne, których rozwinięcie w bazie 2 jest nieskończone (np. 0.1), są reprezentowane z błędem zaokrąglenia.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Błąd względny reprezentacji jest stały dla wszystkich liczb.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Liczba 0.1 jest reprezentowana dokładnie.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Mantysa ma długość 64 bitów.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wykładnik jest zapisywany w kodzie uzupełnień do dwóch (U2).",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 1038,
      "question": "Niech 𝑎, 𝑏, 𝑐 będą liczbami różnymi od zera, zapisanymi w komputerze w formacie zmiennoprzecinkowym z dokładnością maszynową 𝜀. Liczba 𝑐 jest wynikiem operacji arytmetycznej ∘ wykonanej w komputerze i zapisanym w takim samym formacie zmiennoprzecinkowym. Niech 𝛿𝑐 oznacza błąd względny wyniku operacji 𝑐 = 𝑎 ∘ 𝑏. (dokładniej: jego wartość bezwzględną). W których przypadkach błąd wyniku 𝛿𝑐 może być wielokrotnie (kilka rzędów) większy od błędów argumentów 𝑎 i 𝑏 , czyli 𝛿𝑐 ≫ 2𝜀",
      "options": [
        {
          "key": "a",
          "text": "w przypadku dzielenia liczby różnej od zera przez liczbę różną od zera.",
          "correct": false
        },
        {
          "key": "b",
          "text": "w przypadku odejmowania dwóch liczb o bardzo zbliżonych wartościach.",
          "correct": true
        },
        {
          "key": "c",
          "text": "w przypadku mnożenia dwóch bardzo dużych liczb.",
          "correct": false
        },
        {
          "key": "d",
          "text": "w przypadku dodawania liczby bardzo małej do bardzo dużej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "w przypadku wyznaczania pierwiastka kwadratowego.",
          "correct": false
        },
        {
          "key": "f",
          "text": "w przypadku podnoszenia do kwadratu.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 1039,
      "question": "Obliczanie pierwiastków ciągłej funkcji 𝑓 jednej zmiennej rzeczywistej 𝑥 metodami iteracyjnymi. Wartości funkcji dla pierwszych dwóch wartości wyrazów ciągu iteracyjnego 𝑥0 i 𝑥1 spełniają nierówność 𝑓(𝑥0 )𝑓(𝑥1 ) < 0. Ciąg iteracyjny będzie zbieżny do miejsca zerowego dowolnej funkcji spełniającej powyższe warunki, jeżeli zastosujemy metodę",
      "options": [
        {
          "key": "a",
          "text": "siecznych",
          "correct": false
        },
        {
          "key": "b",
          "text": "bisekcji (połowienia przedziału).",
          "correct": true
        },
        {
          "key": "c",
          "text": "Newtona (stycznych).",
          "correct": false
        },
        {
          "key": "d",
          "text": "iteracji prostych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "odwrotnej interpolacji kwadratowej.",
          "correct": false
        },
        {
          "key": "f",
          "text": "żadna z powyższych.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 1040,
      "question": "Należy rozwiązać układ równań liniowych 𝐴𝑥 = 𝑏 z dowolną rzeczywistą, nieosobliwą macierzą 𝐴 𝑛×𝑛, 𝑛 ≫ 1. Złożoność obliczeniowa algorytmu obliczenia rozwiązania jest mniejsza (w stosunku do metody eliminacyjnej Gaussa), jeżeli macierz 𝐴 jest zadana w postaci: Zaznacz zdania prawdziwe.",
      "options": [
        {
          "key": "a",
          "text": "macierz A jest już rozłożona na iloczyn A = LU.",
          "correct": true
        },
        {
          "key": "b",
          "text": "macierz A jest pełna i niesymetryczna.",
          "correct": false
        },
        {
          "key": "c",
          "text": "macierz A ma wymiar 10x10.",
          "correct": false
        },
        {
          "key": "d",
          "text": "stosujemy metodę Cramera dla dużych n.",
          "correct": false
        },
        {
          "key": "e",
          "text": "macierz A jest macierzą osobliwą.",
          "correct": false
        },
        {
          "key": "f",
          "text": "macierz A jest macierzą Hilberta.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 1041,
      "question": "Rozkład według wartości szczególnych (SVD):",
      "options": [
        {
          "key": "a",
          "text": "jest możliwy tylko dla macierzy kwadratowej.",
          "correct": false
        },
        {
          "key": "b",
          "text": "jest możliwy dla dowolnej macierzy prostokątnej m x n.",
          "correct": true
        },
        {
          "key": "c",
          "text": "wymaga, aby macierz była dodatnio określona.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie pozwala na wyznaczenie rzędu macierzy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "macierze U i V w rozkładzie są macierzami trójkątnymi.",
          "correct": false
        },
        {
          "key": "f",
          "text": "wartości osobliwe są zawsze ujemne.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 1042,
      "question": "Które zdania są prawdziwe dotyczące eliminacji Gaussa?",
      "options": [
        {
          "key": "a",
          "text": "Wybór elementu głównego (pivoting) jest stosowany w celu poprawy stabilności numerycznej algorytmu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wybór elementu głównego jest realizowany n - 1 razy w algorytmie eliminacyjnym Gaussa.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Eliminacja Gaussa bez wyboru elementu głównego jest zawsze stabilna.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Złożoność czasowa eliminacji Gaussa wynosi O(n^2).",
          "correct": false
        },
        {
          "key": "e",
          "text": "Eliminacja Gaussa służy do wyznaczania wartości własnych.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Macierz po eliminacji Gaussa jest macierzą diagonalną.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 1043,
      "question": "Które zdanie jest prawdziwe dotyczące wyznaczania wartości własnych?",
      "options": [
        {
          "key": "a",
          "text": "Aby wyznaczyć n wartości własnych dowolnej macierzy kwadratowej A n×n nie stosuje się metod iteracyjnych.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Dla macierzy o stopniu n > 4 nie istnieją ogólne algorytmy skończone (algebraiczne) wyznaczające wartości własne (wynika to z twierdzenia Abla).",
          "correct": true
        },
        {
          "key": "c",
          "text": "Wartości własne macierzy trójkątnej nie leżą na jej przekątnej.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Każda macierz kwadratowa ma wyłącznie rzeczywiste wartości własne.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Metoda potęgowa znajduje wszystkie wartości własne jednocześnie.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wartości własne macierzy A i A^T są zawsze różne.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 1044,
      "question": "Które zdania są prawdziwe dotyczące rozkładu SVD (A = UΣV^T)?",
      "options": [
        {
          "key": "a",
          "text": "Rozkład SVD jest wykorzystywany w kompresji obrazów poprzez ucinanie najmniejszych wartości osobliwych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Macierz Σ jest macierzą ortogonalną.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Macierze U i V są macierzami diagonalnymi.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wartości osobliwe na przekątnej Σ mogą być ujemne.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Macierze U i V są macierzami ortogonalnymi.",
          "correct": true
        },
        {
          "key": "f",
          "text": "SVD nie pozwala na obliczenie macierzy pseudoodwrotnej.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 1045,
      "question": "Szukanie minimum funkcji wielu zmiennych. Przyjmijmy, że funkcja, której minimum należy znaleźć, jest ,,funkcją kwadratową'', a dokładniej - ma postać formy kwadratowej 𝐹 (𝑥) = 𝑥𝑇 𝐴𝑥 + 𝑏𝑇 𝑥 + 𝑐 , 𝑥 ∈ ℝ 𝑛 i macierz A jest dowolną macierzą dodatnio określoną, czyli funkcja jest wypukła,. 𝑘 - liczba iteracji koniecznych do przejścia od dowolnego punktu startowego do punktu, w którym funkcja 𝐹 ma minimum. Które zdania są prawdziwe?",
      "options": [
        {
          "key": "a",
          "text": "Dla bezgradientowej metody Neldera-Meada: k < n.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Metoda sprzężonych gradientów znajduje minimum takiej funkcji w co najwyżej n iteracjach (w arytmetyce dokładnej).",
          "correct": true
        },
        {
          "key": "c",
          "text": "Metoda najszybszego spadku zawsze zbiega w jednej iteracji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Metoda Newtona wymaga obliczania tylko pierwszej pochodnej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Minimum funkcji kwadratowej nie istnieje, jeśli A jest dodatnio określona.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Metoda Newtona dla funkcji kwadratowej zbiega w n iteracjach.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 1046,
      "question": "Przykład zadania liniowej aproksymacji metodą najmniejszych kwadratów (Linear Least Squares) Dane: 20 pomiarów położenia 𝑠 𝑖 pojazdu w ruchu prostoliniowym w chwilach 𝑡𝑖 , 𝑖 = 1, 2, … , 20. Funkcja aproksymująca zależności położenia od czasu: 𝑠(𝑡) = 𝑎0 + 𝑎1 𝑡 + 𝑎2 𝑡2 . Które zdania są prawdziwe?",
      "options": [
        {
          "key": "a",
          "text": "Podany przykład nie jest odpowiedni dla liniowego zadania najmniejszych kwadratów, bo funkcja aproksymująca jest funkcją kwadratową.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Jest to liniowe zadanie najmniejszych kwadratów, ponieważ funkcja jest liniowa względem parametrów a0, a1, a2.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Wymaga rozwiązania układu równań nieliniowych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Można ją stosować tylko dla 2 pomiarów.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Parametry a0, a1, a2 muszą być liczbami całkowitymi.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Błąd aproksymacji w każdym punkcie musi wynosić zero.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 1047,
      "question": "Metoda ilorazów różnicowych. Zależność błędu przybliżania wartości pochodnej funkcji analitycznej 𝑓 w punkcie 𝑥, 𝑥 ∈ 𝑅 metodą ilorazów różnicowych według formuły dwupunktowej od kroku ℎ można zapisać wzorem − 𝑓 ′ (𝑥)∣∣ . 𝑓(𝑥+ℎ)−𝑓(𝑥) 𝜀(ℎ) = ∣∣ ℎ",
      "options": [
        {
          "key": "a",
          "text": "W algorytmie obliczania przybliżenia wartości pochodnej metodą ilorazów z urojonym krokiem ih nie występuje odejmowanie bliskich wartości, co eliminuje błąd kasowania.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Metoda ilorazów różnicowych jest zawsze dokładniejsza od różniczkowania automatycznego.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Krok h powinien być jak największy, aby zminimalizować błąd metody.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Metoda ta wymaga znajomości drugiej pochodnej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Różniczkowanie z urojonym krokiem wymaga użycia liczb zespolonych.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Metoda ilorazów różnicowych wstecz jest zawsze rzędu O(h^2).",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 1048,
      "question": "Różniczkowanie automatyczne:",
      "options": [
        {
          "key": "a",
          "text": "Metodę różniczkowania automatycznego można stosować tylko dla funkcji jednej zmiennej.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Pozwala na obliczanie wartości pochodnych z dokładnością maszynową, wykorzystując regułę łańcuchową.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Polega na symbolicznym wyznaczaniu wzoru pochodnej.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest znacznie wolniejsze od metod ilorazów różnicowych dla funkcji wielu zmiennych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wymaga numerycznego całkowania funkcji.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Nie pozwala na obliczanie gradientów.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 1049,
      "question": "Zaznacz zdanie prawdziwe dotyczące rozkładu QR:",
      "options": [
        {
          "key": "a",
          "text": "Rozkład danej macierzy A na iloczyn QR jest jednoznaczny.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Rozkład QR jest jednoznaczny, jeśli macierz A jest pełnego rzędu kolumnowego, a elementy na przekątnej macierzy R są dodatnie.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Metoda Grama-Schmidta jest najbardziej stabilną numerycznie metodą wyznaczania rozkładu QR.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Macierz Q w rozkładzie QR jest macierzą trójkątną.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Rozkład QR nie może być stosowany do rozwiązywania zadań najmniejszych kwadratów.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Macierz R jest macierzą ortogonalną.",
          "correct": false
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": false
    },
    {
      "id": 1050,
      "question": "Pomiary masy ciała i wzrostu 100 osób są danymi dla aproksymacji zależności masy od wzrostu funkcją afiniczną 𝑚 = 𝑎0 + 𝑎1 ℎ . Warunki zgodności danych z funkcją aproksymującą zapiszemy jako",
      "options": [
        {
          "key": "a",
          "text": "Prowadzi do rozwiązania układu nadwyznaczonego (100 równań z 2 niewiadomymi) w sensie najmniejszych kwadratów.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wymaga odwrócenia macierzy 100x100.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Zawsze daje rozwiązanie przechodzące przez wszystkie punkty pomiarowe.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie można jej stosować, gdy pomiary są obarczone błędem.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Funkcja błędu jest funkcją liniową.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Rozwiązanie zawsze istnieje i jest jednoznaczne, jeśli macierz układu ma pełny rząd.",
          "correct": true
        }
      ],
      "topic": "numerical_methods",
      "semester": 3,
      "courseName": "Metody numeryczne",
      "multipleCorrect": true
    },
    {
      "id": 1051,
      "question": "Które z poniższych zdań jest jednym z aksjomatów prawdopodobieństwa Kołmogorowa dla przestrzeni probabilistycznej (Ω, , 𝑃) :",
      "options": [
        {
          "key": "a",
          "text": "P(A) >= 0 dla każdego zdarzenia A.",
          "correct": true
        },
        {
          "key": "b",
          "text": "P(A) <= 0.5 dla każdego zdarzenia A.",
          "correct": false
        },
        {
          "key": "c",
          "text": "P(Omega) = 0.",
          "correct": false
        },
        {
          "key": "d",
          "text": "P(A u B) = P(A) + P(B) dla dowolnych zdarzeń A, B.",
          "correct": false
        },
        {
          "key": "e",
          "text": "P(Omega) = 1.",
          "correct": true
        },
        {
          "key": "f",
          "text": "P(A) + P(A') = 1 (to jest wniosek, ale często mylony z aksjomatem).",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": true
    },
    {
      "id": 1052,
      "question": "W statystyce populacją nazywamy:",
      "options": [
        {
          "key": "a",
          "text": "zbiór wszystkich możliwych cech pewnego wybranego parametru.",
          "correct": false
        },
        {
          "key": "b",
          "text": "zbiór wszystkich elementów, o których chcemy wyciągnąć wnioski.",
          "correct": true
        },
        {
          "key": "c",
          "text": "podzbiór elementów wybrany do badania.",
          "correct": false
        },
        {
          "key": "d",
          "text": "średnią wartość z próby.",
          "correct": false
        },
        {
          "key": "e",
          "text": "zbiór wszystkich wyników pomiarów w próbie.",
          "correct": false
        },
        {
          "key": "f",
          "text": "wyłącznie grupę ludzi w danym regionie.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1053,
      "question": "W statystyce estymatorem nazywamy:",
      "options": [
        {
          "key": "a",
          "text": "dowolną statystykę (funkcję z próby) służącą do oszacowania nieznanego parametru populacji.",
          "correct": true
        },
        {
          "key": "b",
          "text": "błąd pomiarowy.",
          "correct": false
        },
        {
          "key": "c",
          "text": "wartość parametru w całej populacji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "liczbę elementów w próbie.",
          "correct": false
        },
        {
          "key": "e",
          "text": "hipotezę zerową.",
          "correct": false
        },
        {
          "key": "f",
          "text": "poziom istotności testu.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1054,
      "question": "W statystyce błędem pierwszego rodzaju nazywamy:",
      "options": [
        {
          "key": "a",
          "text": "przyjęcie hipotezy alternatywnej przy niskiej wielkości efektu.",
          "correct": false
        },
        {
          "key": "b",
          "text": "odrzucenie hipotezy zerowej, mimo że jest ona prawdziwa.",
          "correct": true
        },
        {
          "key": "c",
          "text": "nieodrzucenie hipotezy zerowej, mimo że jest ona fałszywa.",
          "correct": false
        },
        {
          "key": "d",
          "text": "błąd wynikający z małej liczebności próby.",
          "correct": false
        },
        {
          "key": "e",
          "text": "błąd gruby pomiaru.",
          "correct": false
        },
        {
          "key": "f",
          "text": "błąd zaokrąglenia w obliczeniach statystycznych.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1055,
      "question": "Liczbę wszystkich różnych k-elementowych ciągów (wariacji z powtórzeniami) utworzonych ze zbioru n-elementowego liczymy wzorem:",
      "options": [
        {
          "key": "a",
          "text": "n^k",
          "correct": true
        },
        {
          "key": "b",
          "text": "n! / (n-k)!",
          "correct": false
        },
        {
          "key": "c",
          "text": "symbol Newtona (n nad k)",
          "correct": false
        },
        {
          "key": "d",
          "text": "k^n",
          "correct": false
        },
        {
          "key": "e",
          "text": "n! / k!",
          "correct": false
        },
        {
          "key": "f",
          "text": "2^n",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1056,
      "question": "W rachunku prawdopodobieństwa wzór na prawdopodobieństwo całkowite:",
      "options": [
        {
          "key": "a",
          "text": "jak znaleźć wartość graniczną prawdopodobieństwa sumy przeliczalnej rodziny wstępującej zbiorów.",
          "correct": false
        },
        {
          "key": "b",
          "text": "pozwala obliczyć prawdopodobieństwo zdarzenia poprzez sumowanie prawdopodobieństw warunkowych względem zupełnego układu zdarzeń.",
          "correct": true
        },
        {
          "key": "c",
          "text": "dotyczy wyłącznie zdarzeń niezależnych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "służy do obliczania prawdopodobieństwa a posteriori (wzór Bayesa).",
          "correct": false
        },
        {
          "key": "e",
          "text": "wymaga, aby zdarzenia warunkujące miały prawdopodobieństwo 1.",
          "correct": false
        },
        {
          "key": "f",
          "text": "mówi, że P(A|B) = P(B|A).",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1057,
      "question": "W rachunku prawdopodobieństwa zdarzenia niezależne od każdego innego zdarzenia:",
      "options": [
        {
          "key": "a",
          "text": "istnieją, ale mogą być tylko zbiorem pustym, albo całą przestrzenią.",
          "correct": false
        },
        {
          "key": "b",
          "text": "to zdarzenia o prawdopodobieństwie 0 lub 1.",
          "correct": true
        },
        {
          "key": "c",
          "text": "nie istnieją w żadnej przestrzeni probabilistycznej.",
          "correct": false
        },
        {
          "key": "d",
          "text": "to wszystkie zdarzenia w przestrzeni dyskretnej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "to zdarzenia, których suma wynosi 1.",
          "correct": false
        },
        {
          "key": "f",
          "text": "to zdarzenia rozłączne.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1058,
      "question": "Sigma-ciałem zbiorów borelowskich na R nazywamy:",
      "options": [
        {
          "key": "a",
          "text": "najmniejsze sigma-ciało na R które zawiera wszystkie zbiory otwarte (lub przedziały postaci (-inf, a]).",
          "correct": true
        },
        {
          "key": "b",
          "text": "zbiór wszystkich podzbiorów R.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zbiór wszystkich liczb wymiernych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "zbiór przedziałów domkniętych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "zbiór wszystkich funkcji ciągłych.",
          "correct": false
        },
        {
          "key": "f",
          "text": "zbiór wszystkich punktów na prostej.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1059,
      "question": "Zmienną losową X : Omega -> R nazywamy funkcję, dla której:",
      "options": [
        {
          "key": "a",
          "text": "przeciwobraz dowolnego przedziału (-inf, a] dla a w R jest zdarzeniem (należy do sigma-ciała).",
          "correct": true
        },
        {
          "key": "b",
          "text": "obraz każdego zdarzenia jest liczbą dodatnią.",
          "correct": false
        },
        {
          "key": "c",
          "text": "dziedzina jest zbiorem liczb rzeczywistych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "wartości są zawsze całkowite.",
          "correct": false
        },
        {
          "key": "e",
          "text": "funkcja jest zawsze rosnąca.",
          "correct": false
        },
        {
          "key": "f",
          "text": "funkcja jest bijekcją.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1060,
      "question": "Które z podanych własności są własnościami każdej dystrybuanty FX zmiennej losowej X:",
      "options": [
        {
          "key": "a",
          "text": "FX jest ściśle rosnąca.",
          "correct": false
        },
        {
          "key": "b",
          "text": "FX jest niemalejąca i prawostronnie ciągła.",
          "correct": true
        },
        {
          "key": "c",
          "text": "FX(x) dąży do 1 gdy x dąży do minus nieskończoności.",
          "correct": false
        },
        {
          "key": "d",
          "text": "FX jest zawsze funkcją ciągłą.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Granica FX(x) przy x dążącym do plus nieskończoności wynosi 1.",
          "correct": true
        },
        {
          "key": "f",
          "text": "FX(x) może przyjmować wartości ujemne.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": true
    },
    {
      "id": 1061,
      "question": "Wariancja zmiennej losowej służy do:",
      "options": [
        {
          "key": "a",
          "text": "wyznaczania skośności dystrybucji zmiennej losowej.",
          "correct": false
        },
        {
          "key": "b",
          "text": "określenia stopnia rozproszenia wartości zmiennej losowej wokół jej wartości oczekiwanej.",
          "correct": true
        },
        {
          "key": "c",
          "text": "obliczania najbardziej prawdopodobnej wartości.",
          "correct": false
        },
        {
          "key": "d",
          "text": "wyznaczania mediany.",
          "correct": false
        },
        {
          "key": "e",
          "text": "określenia kierunku zależności między dwiema zmiennymi.",
          "correct": false
        },
        {
          "key": "f",
          "text": "obliczania wartości średniej.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1062,
      "question": "Jeżeli dwie zmienne losowe X i Y są niezależne, to:",
      "options": [
        {
          "key": "a",
          "text": "rozkład ich sumy jest sumą ich rozkładów.",
          "correct": false
        },
        {
          "key": "b",
          "text": "wariancja ich sumy jest sumą ich wariancji (Var(X+Y) = Var(X) + Var(Y)).",
          "correct": true
        },
        {
          "key": "c",
          "text": "ich korelacja wynosi 1.",
          "correct": false
        },
        {
          "key": "d",
          "text": "ich wartości oczekiwane muszą być równe 0.",
          "correct": false
        },
        {
          "key": "e",
          "text": "ich kowariancja wynosi 0.",
          "correct": true
        },
        {
          "key": "f",
          "text": "P(X|Y) = P(Y).",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": true
    },
    {
      "id": 1063,
      "question": "Dany jest graf G utworzony z n-wierzchołkowej kliki (n>5), poprzez usunięcie 3 krawędzi. Wskaż zdania prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "G jest eulerowski dla n nieparzystych.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Jeśli usunięte krawędzie tworzą cykl C3, to stopnie wszystkich wierzchołków pozostają parzyste (dla n nieparzystego), więc graf jest eulerowski.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Graf po usunięciu krawędzi zawsze przestaje być spójny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Liczba krawędzi w takim grafie wynosi n(n-1)/2.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Graf G jest zawsze planarny.",
          "correct": false
        },
        {
          "key": "f",
          "text": "G nie posiada cyklu Hamiltona.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1064,
      "question": "Czy graf cyklu C5 jest grafem dwudzielnym?",
      "options": [
        {
          "key": "a",
          "text": "Nie, ponieważ nie jest eulerowski.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Nie, ponieważ zawiera cykl o nieparzystej długości.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Tak, ponieważ każdy graf płaski jest dwudzielny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Tak, ponieważ ma 5 wierzchołków.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Tak, bo można go pokolorować 2 kolorami.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Nie, bo jego liczba chromatyczna wynosi 3.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1065,
      "question": "Dany jest graf G o sześciu wierzchołkach i stopniach: 2, 2, 3, 4, 4, 5. Czy G może być grafem planarnym?",
      "options": [
        {
          "key": "a",
          "text": "Nie.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Tak. Przykład konstrukcji: wierzchołek stopnia 5 łączymy ze wszystkimi pozostałymi, a między pozostałymi 5 wierzchołkami dodajemy krawędzie tak, by stopnie wyniosły 4,4,3,2,2 (np. resztowe stopnie 3,3,2,1,1).",
          "correct": true
        },
        {
          "key": "c",
          "text": "Nie, ponieważ zawiera wierzchołek o stopniu 5.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Tak, każdy graf o 6 wierzchołkach jest planarny.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Nie, bo zawiera podgraf izomorficzny z K3,3.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Tak, bo suma stopni jest parzysta.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1066,
      "question": "Dany jest wielościan wypukły o 11 wierzchołkach, w którym 7 ścian to trójkąty, a 4 to czworokąty. Korzystając ze wzoru Eulera (V-E+F=2), określ rodzaj ostatniej (12-stej) ściany:",
      "options": [
        {
          "key": "a",
          "text": "czworokątem.",
          "correct": false
        },
        {
          "key": "b",
          "text": "trójkątem.",
          "correct": true
        },
        {
          "key": "c",
          "text": "pięciokątem.",
          "correct": false
        },
        {
          "key": "d",
          "text": "sześciokątem.",
          "correct": false
        },
        {
          "key": "e",
          "text": "siedmiokątem.",
          "correct": false
        },
        {
          "key": "f",
          "text": "nie da się określić.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1067,
      "question": "Graf G został zbudowany z grafów Hamiltona, G1=(V1,E1) i G2=(V2,E2), w następujący sposób. Z V1 wybrano podzbiór W1 (W1 różne od V1) wierzchołków, stanowiących kolejne węzły cyklu Hamiltona w G1, oraz z V2 podzbiór W2 (W2 różne od V2) wierzchołków, stanowiących kolejne węzły cyklu Hamiltona w G2, a następnie połączono węzły W1 i W2 dodatkowymi krawędziami, tak że każdy węzeł W1 jest sąsiedni z każdym węzłem W2. Wskaż zdania prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "G jest grafem Hamiltona dla |W1| + |W2| > 3.",
          "correct": false
        },
        {
          "key": "b",
          "text": "G jest grafem Hamiltona, jeśli istnieją krawędzie łączące cykle Hamiltona w G1 i G2 pozwalające na utworzenie jednego wspólnego cyklu.",
          "correct": true
        },
        {
          "key": "c",
          "text": "G nigdy nie jest grafem Hamiltona.",
          "correct": false
        },
        {
          "key": "d",
          "text": "G jest grafem pełnym.",
          "correct": false
        },
        {
          "key": "e",
          "text": "G jest zawsze dwudzielny.",
          "correct": false
        },
        {
          "key": "f",
          "text": "G nie posiada mostów.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1068,
      "question": "Indeks chromatyczny (minimalna liczba kolorów krawędzi) drzewa o maksymalnym stopniu wierzchołka Delta wynosi:",
      "options": [
        {
          "key": "a",
          "text": "|V|",
          "correct": false
        },
        {
          "key": "b",
          "text": "Delta (maksymalny stopień wierzchołka).",
          "correct": true
        },
        {
          "key": "c",
          "text": "Delta + 1",
          "correct": false
        },
        {
          "key": "d",
          "text": "2",
          "correct": false
        },
        {
          "key": "e",
          "text": "Delta - 1",
          "correct": false
        },
        {
          "key": "f",
          "text": "3",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1069,
      "question": "Dany jest dowolny graf spójny G=(V,E), w którym każda krawędź jest mostem. Które zdania są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "G jest drzewem.",
          "correct": true
        },
        {
          "key": "b",
          "text": "G zawiera przynajmniej jeden cykl.",
          "correct": false
        },
        {
          "key": "c",
          "text": "G jest grafem pełnym.",
          "correct": false
        },
        {
          "key": "d",
          "text": "G ma więcej krawędzi niż wierzchołków.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Liczba krawędzi E = V - 1.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Graf G jest dwuspójny.",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": true
    },
    {
      "id": 1070,
      "question": "Podać najmniejszą liczbę krawędzi, jaką należy usunąć z grafu dwudzielnego pełnego K3,3, aby uzyskać graf regularny stopnia 2:",
      "options": [
        {
          "key": "a",
          "text": "3",
          "correct": true
        },
        {
          "key": "b",
          "text": "3 (usuwamy krawędzie tworzące doskonałe skojarzenie).",
          "correct": true
        },
        {
          "key": "c",
          "text": "1",
          "correct": false
        },
        {
          "key": "d",
          "text": "6",
          "correct": false
        },
        {
          "key": "e",
          "text": "0",
          "correct": false
        },
        {
          "key": "f",
          "text": "9",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": true
    },
    {
      "id": 1071,
      "question": "Dana jest klika K8. Liczba podgrafów izomorficznych z K5 (czyli liczba 5-elementowych podzbiorów wierzchołków) wynosi:",
      "options": [
        {
          "key": "a",
          "text": "56 (8 po 5).",
          "correct": true
        },
        {
          "key": "b",
          "text": "120",
          "correct": false
        },
        {
          "key": "c",
          "text": "40",
          "correct": false
        },
        {
          "key": "d",
          "text": "8! / 5!",
          "correct": false
        },
        {
          "key": "e",
          "text": "28",
          "correct": false
        },
        {
          "key": "f",
          "text": "64",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1072,
      "question": "Dana jest klika K8 o wierzchołkach v1, v2,..., v8. Liczba dróg prostych w tym grafie, prowadzących z v1 do v2 i posiadających co najwyżej 3 krawędzie, wynosi:",
      "options": [
        {
          "key": "a",
          "text": "37 (długość 1: 1, długość 2: 6, długość 3: 30).",
          "correct": true
        },
        {
          "key": "b",
          "text": "43",
          "correct": false
        },
        {
          "key": "c",
          "text": "8",
          "correct": false
        },
        {
          "key": "d",
          "text": "64",
          "correct": false
        },
        {
          "key": "e",
          "text": "120",
          "correct": false
        },
        {
          "key": "f",
          "text": "56",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1073,
      "question": "Liczba dróg prostych o długości dokładnie 1, 2 lub 3 krawędzi w klice K8 wynosi:",
      "options": [
        {
          "key": "a",
          "text": "C(8,3) + C(8,2) + C(8,1)",
          "correct": false
        },
        {
          "key": "b",
          "text": "1 + 6 + 30 = 37 (między parą wierzchołków).",
          "correct": true
        },
        {
          "key": "c",
          "text": "8! / (8-k)!",
          "correct": false
        },
        {
          "key": "d",
          "text": "n^k",
          "correct": false
        },
        {
          "key": "e",
          "text": "8*7/2",
          "correct": false
        },
        {
          "key": "f",
          "text": "37 * (8*7/2) (dla wszystkich par).",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1074,
      "question": "Dany jest graf o 21 krawędziach, 7 wierzchołkach stopnia 1, 3 stopnia 2, 7 stopnia 3 i pozostałych stopnia 4. Ile jest wierzchołków stopnia 4?",
      "options": [
        {
          "key": "a",
          "text": "Nie da się zbudować takiego grafu.",
          "correct": false
        },
        {
          "key": "b",
          "text": "2 (suma stopni 7*1 + 3*2 + 7*3 + 4*x = 34 + 4x = 42 => 4x=8 => x=2).",
          "correct": true
        },
        {
          "key": "c",
          "text": "5",
          "correct": false
        },
        {
          "key": "d",
          "text": "0",
          "correct": false
        },
        {
          "key": "e",
          "text": "3",
          "correct": false
        },
        {
          "key": "f",
          "text": "4",
          "correct": false
        }
      ],
      "topic": "math",
      "semester": 2,
      "courseName": "Matematyka (dyskretna, prawdopodobieństwo, grafy)",
      "multipleCorrect": false
    },
    {
      "id": 1075,
      "question": "Język L_ne = {<M>: L(M) != pusty} koduje problem:",
      "options": [
        {
          "key": "a",
          "text": "Czy dla danej maszyny Turinga M, język przez nią akceptowany jest niepusty?",
          "correct": true
        },
        {
          "key": "b",
          "text": "Czy maszyna Turinga M zatrzymuje się dla słowa pustego?",
          "correct": false
        },
        {
          "key": "c",
          "text": "Czy język L(M) jest skończony?",
          "correct": false
        },
        {
          "key": "d",
          "text": "Czy maszyna M jest uniwersalna?",
          "correct": false
        },
        {
          "key": "e",
          "text": "Czy M akceptuje wszystkie słowa?",
          "correct": false
        },
        {
          "key": "f",
          "text": "Czy M jest maszyną deterministyczną?",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1076,
      "question": "Język L_nr = {<M> : L(M) nie jest rekurencyjny}:",
      "options": [
        {
          "key": "a",
          "text": "Jest akceptowany przez uniwersalną MT.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Nie jest rekurencyjnie przeliczalny (ani jego dopełnienie).",
          "correct": true
        },
        {
          "key": "c",
          "text": "Jest językiem regularnym.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest rozstrzygalny.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest językiem bezkontekstowym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest rekurencyjnie przeliczalny.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1077,
      "question": "Język L_eq = {<M> <N>: L(M) = L(N)}:",
      "options": [
        {
          "key": "a",
          "text": "Nie jest rozpoznawany przez żadną maszynę Turinga (nie jest rekurencyjnie przeliczalny).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Jest rozstrzygalny dla dowolnych maszyn Turinga.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest językiem bezkontekstowym.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest akceptowany przez automat ze stosem.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest rekurencyjny.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest językiem regularnym.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1078,
      "question": "Problem decyzyjny „Czy dane maszyny Turinga M i N akceptują ten sam język?” jest:",
      "options": [
        {
          "key": "a",
          "text": "Rozstrzygalny.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Nierozstrzygalny.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Częściowo rozstrzygalny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Rozstrzygalny tylko dla automatów skończonych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Rozstrzygalny w czasie wielomianowym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "P-zupełny.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1079,
      "question": "Twierdzenie Rice'a orzeka, że każda nietrywialna własność semantyczna języków akceptowanych przez maszyny Turinga jest:",
      "options": [
        {
          "key": "a",
          "text": "Nierozstrzygalna (język L = {<M>: L(M) ma własność S} nie jest rekurencyjny).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Rekurencyjnie przeliczalna.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Regularna.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Rozstrzygalna w czasie wielomianowym.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Prawdziwa dla wszystkich maszyn Turinga.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Zależna od liczby stanów maszyny.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1080,
      "question": "Niech S będzie pewną własnością zbiorów rekurencyjnie przeliczalnych. Jeśli S nie jest monotoniczna to:",
      "options": [
        {
          "key": "a",
          "text": "S jest nieprzeliczalna lub pusta.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Język L = {<M>: L(M) należy do S} nie jest rekurencyjnie przeliczalny.",
          "correct": true
        },
        {
          "key": "c",
          "text": "S jest zawsze rozstrzygalna.",
          "correct": false
        },
        {
          "key": "d",
          "text": "S zawiera wszystkie języki regularne.",
          "correct": false
        },
        {
          "key": "e",
          "text": "S jest rekurencyjna.",
          "correct": false
        },
        {
          "key": "f",
          "text": "S jest skończona.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1081,
      "question": "Funkcję Ackermana:",
      "options": [
        {
          "key": "a",
          "text": "da się przedstawić w reprezentacji Maszyny Turinga.",
          "correct": false
        },
        {
          "key": "b",
          "text": "jest funkcją rekurencyjną, ale nie jest prymitywnie rekurencyjna.",
          "correct": true
        },
        {
          "key": "c",
          "text": "nie jest obliczalna.",
          "correct": false
        },
        {
          "key": "d",
          "text": "ma złożoność wielomianową.",
          "correct": false
        },
        {
          "key": "e",
          "text": "rośnie szybciej niż jakakolwiek funkcja prymitywnie rekurencyjna.",
          "correct": true
        },
        {
          "key": "f",
          "text": "jest funkcją liniową.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1082,
      "question": "Dany jest język L_e = {w : w = <M> => L(M) = pusty}. Koduje on problem:",
      "options": [
        {
          "key": "a",
          "text": "Czy język akceptowany przez maszynę Turinga M jest pusty?",
          "correct": true
        },
        {
          "key": "b",
          "text": "Czy dla słowa w niebędącego kodem MT, jest ono akceptowane przez pewną MT?",
          "correct": false
        },
        {
          "key": "c",
          "text": "Czy maszyna M akceptuje wszystkie słowa?",
          "correct": false
        },
        {
          "key": "d",
          "text": "Czy M jest maszyną deterministyczną?",
          "correct": false
        },
        {
          "key": "e",
          "text": "Czy M zatrzymuje się na słowie w?",
          "correct": false
        },
        {
          "key": "f",
          "text": "Czy L(M) jest skończony?",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1083,
      "question": "Język L_e = {<M> : L(M) = pusty}:",
      "options": [
        {
          "key": "a",
          "text": "Jest prymitywnie rekurencyjny.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Nie jest rekurencyjnie przeliczalny.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Jest rozstrzygalny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest językiem kontekstowym.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jego dopełnienie L_ne jest rekurencyjnie przeliczalne.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest językiem regularnym.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1084,
      "question": "Język L_ne = {<M>: L(M) != pusty}:",
      "options": [
        {
          "key": "a",
          "text": "Jest rekurencyjnie przeliczalny (ale nie rekurencyjny).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Jest rozstrzygalny.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Nie jest akceptowany przez żadną maszynę Turinga.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest językiem skończonym.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest językiem regularnym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest rekurencyjny.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1085,
      "question": "Problem decyzyjny, czy język akceptowany przez daną maszynę Turinga jest pusty, jest:",
      "options": [
        {
          "key": "a",
          "text": "Częściowo rozstrzygalny.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Nierozstrzygalny i nie jest nawet częściowo rozstrzygalny.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Rozstrzygalny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wielomianowy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Rozstrzygalny dla automatów ze stosem.",
          "correct": false
        },
        {
          "key": "f",
          "text": "P-zupełny.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1086,
      "question": "Problem decyzyjny, czy język akceptowany przez daną maszynę Turinga jest niepusty, jest:",
      "options": [
        {
          "key": "a",
          "text": "Nie jest nawet problemem częściowo rozstrzygalnym.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Częściowo rozstrzygalny (można symulować M na wszystkich słowach równolegle).",
          "correct": true
        },
        {
          "key": "c",
          "text": "Rozstrzygalny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Rekurencyjny.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Regularny.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Rozstrzygalny w czasie wykładniczym.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1087,
      "question": "Język L_r = {<M>: L(M) jest rekurencyjny} koduje problem:",
      "options": [
        {
          "key": "a",
          "text": "Czy język akceptowany przez maszynę Turinga M jest rozstrzygalny?",
          "correct": true
        },
        {
          "key": "b",
          "text": "Czy dla danej maszyny Turinga M, L(M) jest rekurencyjnie przeliczalny?",
          "correct": false
        },
        {
          "key": "c",
          "text": "Czy M zatrzymuje się dla każdego wejścia?",
          "correct": false
        },
        {
          "key": "d",
          "text": "Czy M ma skończoną liczbę stanów?",
          "correct": false
        },
        {
          "key": "e",
          "text": "Czy L(M) jest językiem regularnym?",
          "correct": false
        },
        {
          "key": "f",
          "text": "Czy M jest uniwersalna?",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1088,
      "question": "Język L_nr = {<M>: L(M) nie jest rekurencyjny} koduje problem:",
      "options": [
        {
          "key": "a",
          "text": "Czy język akceptowany przez maszynę Turinga M jest nierozstrzygalny?",
          "correct": true
        },
        {
          "key": "b",
          "text": "Czy dana maszyna Turinga M, posiada własność stopu?",
          "correct": false
        },
        {
          "key": "c",
          "text": "Czy M jest maszyną uniwersalną?",
          "correct": false
        },
        {
          "key": "d",
          "text": "Czy L(M) jest językiem regularnym?",
          "correct": false
        },
        {
          "key": "e",
          "text": "Czy M jest deterministyczna?",
          "correct": false
        },
        {
          "key": "f",
          "text": "Czy M ma nieskończoną taśmę?",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1089,
      "question": "Język L_r = {<M>: L(M) jest rekurencyjny}:",
      "options": [
        {
          "key": "a",
          "text": "Nie jest rekurencyjny (wynika z twierdzenia Rice'a).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Jest rekurencyjnie przeliczalny.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest rozstrzygalny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest regularny.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest bezkontekstowy.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Nie jest rekurencyjnie przeliczalny.",
          "correct": true
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1090,
      "question": "Jednostka arytmetyczno-logiczna ALU:",
      "options": [
        {
          "key": "a",
          "text": "musi być układem sekwencyjnym.",
          "correct": false
        },
        {
          "key": "b",
          "text": "jest podstawowym blokiem procesora wykonującym operacje obliczeniowe i logiczne.",
          "correct": true
        },
        {
          "key": "c",
          "text": "nie może zawierać sumatorów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "służy wyłącznie do przechowywania danych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "wykonuje operacje takie jak dodawanie, odejmowanie, AND, OR.",
          "correct": true
        },
        {
          "key": "f",
          "text": "zarządza przerwaniami sprzętowymi.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 1091,
      "question": "Układ sekwencyjny:",
      "options": [
        {
          "key": "a",
          "text": "jest to układ logiczny nie pamiętający stanów poprzednich.",
          "correct": false
        },
        {
          "key": "b",
          "text": "to układ, w którym stan wyjść zależy od aktualnych wejść oraz od stanu poprzedniego (posiada pamięć).",
          "correct": true
        },
        {
          "key": "c",
          "text": "to inaczej układ kombinacyjny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie wymaga sygnału zegarowego.",
          "correct": false
        },
        {
          "key": "e",
          "text": "przykładami są przerzutniki, liczniki, rejestry.",
          "correct": true
        },
        {
          "key": "f",
          "text": "nie posiada sprzężenia zwrotnego.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 1092,
      "question": "Pamięć RAM dwuportowa:",
      "options": [
        {
          "key": "a",
          "text": "pozwala na jednoczesny dostęp do dwóch różnych komórek pamięci (np. odczyt i zapis).",
          "correct": true
        },
        {
          "key": "b",
          "text": "nie może być zaimplementowana w układach FPGA.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest zawsze wolniejsza od pamięci jednoportowej.",
          "correct": false
        },
        {
          "key": "d",
          "text": "służy wyłącznie do przechowywania instrukcji procesora.",
          "correct": false
        },
        {
          "key": "e",
          "text": "wymaga dwóch oddzielnych układów scalonych.",
          "correct": false
        },
        {
          "key": "f",
          "text": "nie posiada linii adresowych.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 1093,
      "question": "Procesor w układzie FPGA:",
      "options": [
        {
          "key": "a",
          "text": "może mieć architekturę dostosowaną do specyficznych potrzeb użytkownika (tzw. soft-core).",
          "correct": true
        },
        {
          "key": "b",
          "text": "musi być zgodny z architekturą x86.",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie może posiadać własnej listy rozkazów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest zawsze szybszy od procesorów dedykowanych (ASIC).",
          "correct": false
        },
        {
          "key": "e",
          "text": "nie może być taktowany zegarem.",
          "correct": false
        },
        {
          "key": "f",
          "text": "nie posiada rejestrów.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 1094,
      "question": "Lista rozkazów procesora (ISA):",
      "options": [
        {
          "key": "a",
          "text": "w skład listy rozkazów zawsze wchodzi mnożenie.",
          "correct": false
        },
        {
          "key": "b",
          "text": "definiuje zestaw instrukcji rozumianych przez procesor oraz ich formaty.",
          "correct": true
        },
        {
          "key": "c",
          "text": "jest identyczna dla wszystkich procesorów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie zawiera instrukcji skoków.",
          "correct": false
        },
        {
          "key": "e",
          "text": "określa dostępne tryby adresowania.",
          "correct": true
        },
        {
          "key": "f",
          "text": "zależy od systemu operacyjnego.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 1095,
      "question": "Karta graficzna i FPGA:",
      "options": [
        {
          "key": "a",
          "text": "Układy FPGA mogą być wykorzystane do budowy akceleratorów graficznych i przetwarzania obrazu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "przy użyciu FPGA nie można zbudować karty graficznej ze sprzętowym wspomaganiem OpenGL.",
          "correct": false
        },
        {
          "key": "c",
          "text": "FPGA nie nadaje się do obliczeń równoległych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "karty graficzne nie używają pamięci RAM.",
          "correct": false
        },
        {
          "key": "e",
          "text": "FPGA są używane wyłącznie w telekomunikacji.",
          "correct": false
        },
        {
          "key": "f",
          "text": "GPU i FPGA to te same układy.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 1096,
      "question": "Licznik rozkazów (Program Counter):",
      "options": [
        {
          "key": "a",
          "text": "przechowuje adres następnej instrukcji do pobrania z pamięci.",
          "correct": true
        },
        {
          "key": "b",
          "text": "służy do zliczania liczby wykonanych operacji arytmetycznych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest częścią jednostki ALU.",
          "correct": false
        },
        {
          "key": "d",
          "text": "przechowuje kody błędów procesora.",
          "correct": false
        },
        {
          "key": "e",
          "text": "jest rejestrem 8-bitowym w procesorach 64-bitowych.",
          "correct": false
        },
        {
          "key": "f",
          "text": "nie może być zmieniony przez instrukcję skoku.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 1097,
      "question": "Rozkaz skoku warunkowego:",
      "options": [
        {
          "key": "a",
          "text": "zmienia kolejność wykonywania instrukcji w zależności od stanu znaczników (flag) procesora.",
          "correct": true
        },
        {
          "key": "b",
          "text": "zawsze wykonuje skok do adresu zero.",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie zależy od wyników poprzednich operacji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest instrukcją typu ALU.",
          "correct": false
        },
        {
          "key": "e",
          "text": "nie jest dostępny w architekturze RISC.",
          "correct": false
        },
        {
          "key": "f",
          "text": "zawsze czyści pamięć cache.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 1098,
      "question": "Rozkaz dodawania w procesorze:",
      "options": [
        {
          "key": "a",
          "text": "pobiera argumenty (np. z rejestrów), wykonuje sumowanie w ALU i zapisuje wynik.",
          "correct": true
        },
        {
          "key": "b",
          "text": "nie może używać adresowania bezpośredniego.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest dostępny tylko w procesorach 64-bitowych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "zawsze ustawia flagę przerwania.",
          "correct": false
        },
        {
          "key": "e",
          "text": "może ustawić flagi takie jak Zero (Z), Carry (C), Overflow (V).",
          "correct": true
        },
        {
          "key": "f",
          "text": "nie zmienia stanu rejestrów.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 1099,
      "question": "Przetwarzanie potokowe (pipelining):",
      "options": [
        {
          "key": "a",
          "text": "pozwala na jednoczesne wykonywanie różnych etapów wielu instrukcji.",
          "correct": true
        },
        {
          "key": "b",
          "text": "skraca czas wykonania pojedynczej instrukcji (latency).",
          "correct": false
        },
        {
          "key": "c",
          "text": "eliminuje potrzebę stosowania pamięci cache.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest stosowane tylko w procesorach jednoukładowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "zwiększa przepustowość (throughput) procesora.",
          "correct": true
        },
        {
          "key": "f",
          "text": "uniemożliwia wykonywanie skoków.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 1100,
      "question": "Sumator jednobitowy pełny (Full Adder):",
      "options": [
        {
          "key": "a",
          "text": "posiada trzy wejścia (dwa bity składników i przeniesienie) oraz dwa wyjścia (suma i przeniesienie).",
          "correct": true
        },
        {
          "key": "b",
          "text": "nie uwzględnia przeniesienia z poprzedniej pozycji.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest układem sekwencyjnym.",
          "correct": false
        },
        {
          "key": "d",
          "text": "służy do mnożenia liczb.",
          "correct": false
        },
        {
          "key": "e",
          "text": "składa się wyłącznie z bramek NOT.",
          "correct": false
        },
        {
          "key": "f",
          "text": "jest podstawą budowy sumatorów wielobitowych.",
          "correct": true
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": true
    },
    {
      "id": 1101,
      "question": "Rejestr rozkazów (Instruction Register):",
      "options": [
        {
          "key": "a",
          "text": "przechowuje aktualnie dekodowaną i wykonywaną instrukcję.",
          "correct": true
        },
        {
          "key": "b",
          "text": "jest dostępny bezpośrednio dla programisty.",
          "correct": false
        },
        {
          "key": "c",
          "text": "służy do przechowywania wyników operacji zmiennoprzecinkowych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest tożsamy z licznikiem rozkazów.",
          "correct": false
        },
        {
          "key": "e",
          "text": "przechowuje adresy pamięci RAM.",
          "correct": false
        },
        {
          "key": "f",
          "text": "jest częścią jednostki sterującej procesora.",
          "correct": false
        }
      ],
      "topic": "digital_systems",
      "semester": 2,
      "courseName": "Podstawy techniki cyfrowej",
      "multipleCorrect": false
    },
    {
      "id": 1102,
      "question": "Wskaż, które z poniższych stwierdzeń opisują poprawnie własności relacyjnych baz danych:",
      "options": [
        {
          "key": "a",
          "text": "Wartością atrybutu może być wyrażenie obliczalne.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Każda relacja musi posiadać klucz główny, który jednoznacznie identyfikuje krotki.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Kolejność wierszy w tabeli ma znaczenie semantyczne.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Atrybuty w relacji mogą być wielowartościowe (np. tablice).",
          "correct": false
        },
        {
          "key": "e",
          "text": "Relacja jest zbiorem krotek (brak duplikatów).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Relacyjna baza danych nie obsługuje więzów integralności.",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 1103,
      "question": "Wskaż, które z poniższych stwierdzeń dotyczących kluczy obcych w relacyjnych bazach danych są prawdziwe.",
      "options": [
        {
          "key": "a",
          "text": "Nazwa atrybutu klucza obcego musi być taka sama jak nazwa atrybutu klucza w tabeli nadrzędnej.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Klucz obcy służy do wymuszania więzów integralności referencyjnej między tabelami.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Klucz obcy nie może zawierać wartości NULL.",
          "correct": false
        },
        {
          "key": "d",
          "text": "W jednej tabeli może istnieć tylko jeden klucz obcy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Klucz obcy może odwoływać się do klucza głównego lub unikalnego w innej tabeli.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Usunięcie rekordu nadrzędnego zawsze powoduje usunięcie rekordu z kluczem obcym.",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 1104,
      "question": "Dana jest zmienna relacyjna o schemacie H={A,B,C,D} i zbiorze zależności funkcyjnych F={{A,B} -> C, {A,C} -> D}. Jedynym kluczem tej zmiennej relacyjnej jest para atrybutów {A,B}. W jakiej maksymalnie postaci normalnej jest ta zmienna relacyjna? (Zakładamy, że jest w 1NF.)",
      "options": [
        {
          "key": "a",
          "text": "BCNF",
          "correct": false
        },
        {
          "key": "b",
          "text": "2NF",
          "correct": false
        },
        {
          "key": "c",
          "text": "3NF",
          "correct": true
        },
        {
          "key": "d",
          "text": "1NF",
          "correct": false
        },
        {
          "key": "e",
          "text": "4NF",
          "correct": false
        },
        {
          "key": "f",
          "text": "5NF",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": false
    },
    {
      "id": 1105,
      "question": "Dana jest zmienna relacyjna o schemacie H={A,B,C,D} i zbiorze zależności funkcyjnych F={A -> B, C -> D}. Jedynym kluczem tej zmiennej relacyjnej jest para atrybutów {A,C}. Jak należy zdekomponować zmienną relacyjną, aby uzyskać zbiór zmiennych relacyjnych w 3NF?",
      "options": [
        {
          "key": "a",
          "text": "Dekompozycja na {A,B} oraz {C,D} oraz {A,C}.",
          "correct": true
        },
        {
          "key": "b",
          "text": "{A,B}, {C,D}",
          "correct": false
        },
        {
          "key": "c",
          "text": "{A,B,C}, {D}",
          "correct": false
        },
        {
          "key": "d",
          "text": "{A,B,D}, {C}",
          "correct": false
        },
        {
          "key": "e",
          "text": "Nie wymaga dekompozycji.",
          "correct": false
        },
        {
          "key": "f",
          "text": "{A,B,C,D}",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": false
    },
    {
      "id": 1106,
      "question": "Wskaż prawdziwe stwierdzenia dotyczące kluczy w modelu relacyjnym:",
      "options": [
        {
          "key": "a",
          "text": "Zbiór wszystkich atrybutów wchodzących w skład nagłówka zmiennej relacyjnej jest kluczem.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Klucz nadmiarowy (superklucz) to zbiór atrybutów zawierający klucz kandydujący.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Każda tabela może mieć wiele kluczy głównych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Klucz kandydujący może być pusty.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Klucz kandydujący to minimalny superklucz.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Klucz główny to jeden z wybranych kluczy kandydujących.",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 1107,
      "question": "Wskaż, które z poniższych stwierdzeń dotyczących normalizacji są prawdziwe w relacyjnym modelu danych.",
      "options": [
        {
          "key": "a",
          "text": "Dowolną zmienną relacyjną można sprowadzić do 3NF stosując dekompozycję bezstratną i zachowującą zależności funkcyjne.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Postać BCNF zawsze zachowuje wszystkie zależności funkcyjne.",
          "correct": false
        },
        {
          "key": "c",
          "text": "2NF eliminuje zależności przechodnie.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Normalizacja zawsze zwiększa wydajność odczytu danych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "1NF wymaga, aby wszystkie wartości atrybutów były atomowe.",
          "correct": true
        },
        {
          "key": "f",
          "text": "3NF eliminuje zależności wielowartościowe.",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 1108,
      "question": "Wskaż prawdziwe stwierdzenia dotyczące powiązań w relacyjnych bazach danych:",
      "options": [
        {
          "key": "a",
          "text": "Relacja wiele-do-wielu wymaga wprowadzenia tabeli pośredniczącej (asocjacyjnej).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Powiązania klucz-klucz obcy mogą być tylko typu jeden do jednego lub jeden do wielu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Klucz obcy musi zawsze wskazywać na klucz główny, nigdy na klucz unikalny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Między dwiema tabelami może istnieć tylko jedno powiązanie.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Relacja jeden-do-jednego może być zaimplementowana w jednej tabeli lub dwóch połączonych kluczami głównymi.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Relacje w SQL są zawsze symetryczne.",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 1109,
      "question": "Wskaż prawdziwe stwierdzenia dotyczące podzapytań w PostgreSQL:",
      "options": [
        {
          "key": "a",
          "text": "Wewnątrz instrukcji INSERT można stosować wyłącznie podzapytania skalarne.",
          "correct": false
        },
        {
          "key": "b",
          "text": "Podzapytania mogą być stosowane w klauzulach SELECT, FROM, WHERE oraz HAVING.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Podzapytanie w klauzuli FROM nie musi mieć nadanego aliasu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Podzapytania skorelowane są zawsze szybsze od zwykłych podzapytań.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Podzapytanie skalarne zwraca dokładnie jedną wartość (jeden wiersz i jedną kolumnę).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Podzapytania nie mogą być zagnieżdżone.",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 1110,
      "question": "Wskaż, które z poniższych stwierdzeń dotyczących typów złączeń w relacyjnych bazach danych są prawdziwe.",
      "options": [
        {
          "key": "a",
          "text": "LEFT JOIN zwraca wszystkie wiersze z lewej tabeli i dopasowane wiersze z prawej tabeli (lub NULL).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Złączenie wewnętrzne (INNER JOIN) zawiera wszystkie rekordy z lewej tabeli, nawet jeśli nie ma dopasowania.",
          "correct": false
        },
        {
          "key": "c",
          "text": "FULL JOIN zwraca tylko rekordy, które mają dopasowanie w obu tabelach.",
          "correct": false
        },
        {
          "key": "d",
          "text": "CROSS JOIN wymaga podania warunku ON.",
          "correct": false
        },
        {
          "key": "e",
          "text": "RIGHT JOIN jest symetryczny do LEFT JOIN (zwraca wszystko z prawej tabeli).",
          "correct": true
        },
        {
          "key": "f",
          "text": "NATURAL JOIN łączy tabele po wszystkich kolumnach o tych samych nazwach.",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 1111,
      "question": "Wskaż, które z własności przetwarzania transakcyjnego oznacza skrót ACID.",
      "options": [
        {
          "key": "a",
          "text": "Atomiczność, Spójność (Consistency), Izolacja, Trwałość (Durability).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Agregacja, Całkowitość, Identyfikacja, Dostępność.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Asynchroniczność, Ciągłość, Interakcja, Decentralizacja.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Automatyzacja, Certyfikacja, Integracja, Dokumentacja.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Akceptacja, Cyliczność, Indeksacja, Definicja.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Autoryzacja, Ciągłość, Izolacja, Dostępność.",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": false
    },
    {
      "id": 1112,
      "question": "Wskaż prawdziwe stwierdzenia dotyczące funkcji agregujących w PostgreSQL:",
      "options": [
        {
          "key": "a",
          "text": "Funkcje agregujące (np. SUM, AVG) nie mogą być używane bezpośrednio w klauzuli WHERE.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Klauzula HAVING służy do filtrowania wyników przed agregacją.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Funkcja COUNT() pomija wartości NULL.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Funkcje agregujące można stosować tylko w zapytaniach z GROUP BY.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Funkcja COUNT(*) zlicza wszystkie wiersze, w tym te z wartościami NULL.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Funkcja MAX() działa tylko na typach numerycznych.",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 1113,
      "question": "Wskaż, które z poniższych stwierdzeń dotyczących związku relacyjnych baz danych z matematyczną teorią relacji są prawdziwe.",
      "options": [
        {
          "key": "a",
          "text": "Relacja w sensie matematycznym to podzbiór iloczynu kartezjańskiego zbiorów (dziedzin).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Tabele relacyjnych baz danych w których istnieją klucze są relacjami.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Każda tabela w SQL jest matematyczną relacją (nawet jeśli dopuszcza duplikaty).",
          "correct": false
        },
        {
          "key": "d",
          "text": "Model relacyjny nie opiera się na teorii zbiorów.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Atrybuty relacji odpowiadają kolumnom tabeli, a krotki odpowiadają wierszom.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Relacja matematyczna dopuszcza nieskończoną liczbę krotek w bazie danych.",
          "correct": false
        }
      ],
      "topic": "databases",
      "semester": 3,
      "courseName": "Bazy danych",
      "multipleCorrect": true
    },
    {
      "id": 1114,
      "question": "Gramatyka formalna jest wieloznaczna, jeżeli:",
      "options": [
        {
          "key": "a",
          "text": "istnieje przynajmniej jedno słowo w języku tej gramatyki, które posiada więcej niż jedno drzewo wyprowadzenia (syntaktyczne).",
          "correct": true
        },
        {
          "key": "b",
          "text": "posiada symbole nieterminalne o wielu produkcjach.",
          "correct": false
        },
        {
          "key": "c",
          "text": "generuje język nieskończony.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie można jej sprowadzić do postaci normalnej Chomsky'ego.",
          "correct": false
        },
        {
          "key": "e",
          "text": "posiada słowo, dla którego istnieje więcej niż jedno wyprowadzenie lewostronne.",
          "correct": true
        },
        {
          "key": "f",
          "text": "generuje słowa o różnej długości.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1115,
      "question": "W kontekście języków formalnych, (oznaczenie: ^ to symbol potęgowania, którego argumenty mogą być w nawiasach klamrowych., następujące stwierdzenia są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "Język L = {a^n b^n : n > 0} nie jest regularny, ale jest bezkontekstowy.",
          "correct": true
        },
        {
          "key": "b",
          "text": "L1 = {f^{2^{n}}: n > 0} jest regularny.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Każdy język bezkontekstowy jest regularny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Języki regularne nie są zamknięte ze względu na dopełnienie.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Klasa języków regularnych jest właściwym podzbiorem klasy języków bezkontekstowych.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Każdy język akceptowany przez automat skończony jest bezkontekstowy.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1116,
      "question": "Mamy gramatykę (duże litery to symbole nieterminalne, małe to symbole terminalne, S to symbol startowy) zawierającą produkcje: S -> AB, A -> Aa | bB, B -> a | Sb oraz formę zdaniową: baaABb. Które stwierdzenie jest prawdziwe",
      "options": [
        {
          "key": "a",
          "text": "nie jest wyprowadzana.",
          "correct": false
        },
        {
          "key": "b",
          "text": "jest formą zdaniową, jeśli można ją uzyskać w dowolnej liczbie kroków z symbolu startowego S.",
          "correct": true
        },
        {
          "key": "c",
          "text": "zawiera wyłącznie symbole terminalne.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest słowem języka.",
          "correct": false
        },
        {
          "key": "e",
          "text": "jest symbolem startowym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "nie może zawierać nieterminali.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1117,
      "question": "W odniesieniu do wyrażeń regularnych i generowanych łańcuchów, które stwierdzenia są prawdziwe Wyrażenie regularne: (x+y)*y(a+ab)*",
      "options": [
        {
          "key": "a",
          "text": "Generuje słowa kończące się sekwencją 'y' po której następuje 'a' lub 'ab'.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Zawiera dokładnie 7 łańcuchów o długości mniejszej niż 4.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Nie generuje słowa 'y'.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Generuje słowo 'xa'.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Generuje słowo 'yya'.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Generuje słowo 'xyab'.",
          "correct": true
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1118,
      "question": "Lemat o pompowaniu dla języków regularnych:",
      "options": [
        {
          "key": "a",
          "text": "Służy do dowodzenia, że dany język nie jest regularny.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Długość pompowania dla łańcucha o długości x jest równa x+1.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Każdy język spełniający warunki lematu o pompowaniu jest regularny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Dotyczy wyłącznie języków skończonych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Mówi, że każde słowo języka regularnego można dowolnie skracać.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Pozwala na konstrukcję automatu minimalnego.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1119,
      "question": "Rozważmy gramatykę S ---> PQ | SQ | PS P ---> x Q--> yKtóre stwierdzenia są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "W gramatyce w postaci normalnej Chomsky'ego liczba kroków wyprowadzenia słowa o długości n wynosi dokładnie 2n-1.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Liczba użytych produkcji musi być równa n.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Nie da się wyprowadzić słów o długości większej niż 2.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Gramatyka ta jest regularna.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wymaga n^2 kroków.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Liczba kroków jest zawsze parzysta.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1120,
      "question": "W odniesieniu do języków regularnych:",
      "options": [
        {
          "key": "a",
          "text": "Języki regularne są zamknięte ze względu na sumę, iloczyn i dopełnienie.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Jeśli L1 jest regularny a L1-L2 jest regularny, to L2 musi być regularny.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Każdy język podzbiór języka regularnego jest regularny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Automaty niedeterministyczne akceptują szerszą klasę języków niż deterministyczne.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Każdy język regularny jest akceptowany przez pewien deterministyczny automat skończony.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Języki regularne nie są zamknięte ze względu na gwiazdkę Kleene'ego.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1121,
      "question": "Mamy gramatykę z następującymi produkcjami: S -> XY X -> aX|a Y -> aYb|\\epsilon",
      "options": [
        {
          "key": "a",
          "text": "Generuje język {a^m b^n : m > n >= 0}.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Generuje język {a^n b^n : n >= 0}.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest gramatyką regularną.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie generuje słowa 'a'.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Generuje słowo 'ab'.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Generuje język {a^n b^m : n > m}.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": false
    },
    {
      "id": 1122,
      "question": "Które z poniższych zdań odnośnie gramatyk formalnych są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "Z każdej gramatyki bezkontekstowej można usunąć epsilon-produkcje (chyba że język zawiera słowo puste).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Gramatyki bezkontekstowe są zamknięte ze względu na przekrój (intersekcję).",
          "correct": false
        },
        {
          "key": "c",
          "text": "Każdy język regularny jest generowany przez gramatykę typu 0.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Gramatyki kontekstowe nie mogą mieć produkcji skracających.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Każdy język regularny jest bezkontekstowy.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Gramatyki typu 3 generują języki kontekstowe.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1123,
      "question": "Odnośnie twierdzenia Myhill-Nerode'a następujące zdania są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "Podaje warunek konieczny i dostateczny na to, by język był regularny.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Służy do minimalizacji automatów deterministycznych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Twierdzenie ma znaczenie w kontekście konwersji NAS na DAS.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Dotyczy wyłącznie języków bezkontekstowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Relacja Myhill-Nerode'a ma skończony indeks wtedy i tylko wtedy, gdy język jest regularny.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Pozwala na rozstrzygnięcie problemu stopu.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1124,
      "question": "W kontekście języków formalnych następujące stwierdzenia są prawdziwe",
      "options": [
        {
          "key": "a",
          "text": "Są akceptowane przez liniowo ograniczone automaty Turinga (LBA).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Język kontekstowy jest akceptowany przez NAS (automat skończony).",
          "correct": false
        },
        {
          "key": "c",
          "text": "Są podzbiorem języków regularnych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Ich gramatyki mogą zawierać produkcję A -> BC.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Gramatyki kontekstowe (typ 1) mają produkcje postaci alpha A beta -> alpha gamma beta, gdzie gamma != epsilon.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Każdy język kontekstowy jest bezkontekstowy.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1125,
      "question": "W odniesieniu do języków formalnych następujące zdania są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "Akceptuje klasę języków bezkontekstowych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Może akceptować napis wejściowy poprzez stan końcowy lub pusty stos.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest równoważny automatowi skończonemu z dwoma stosami.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Zawsze musi być deterministyczny.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Niedeterministyczne automaty ze stosem są silniejsze od deterministycznych (akceptują szerszą klasę języków).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Nie może mieć więcej niż jeden stan.",
          "correct": false
        }
      ],
      "topic": "formal_languages",
      "semester": 3,
      "courseName": "Lingwistyka formalna i automaty",
      "multipleCorrect": true
    },
    {
      "id": 1126,
      "question": "Jeżeli kolor punktu zapisany jest na 16 bitach (High Color), to może on przyjąć:",
      "options": [
        {
          "key": "a",
          "text": "65536 różnych barw.",
          "correct": true
        },
        {
          "key": "b",
          "text": "16,7 miliona barw.",
          "correct": false
        },
        {
          "key": "c",
          "text": "256 barw.",
          "correct": false
        },
        {
          "key": "d",
          "text": "1024 barwy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "32768 barw.",
          "correct": false
        },
        {
          "key": "f",
          "text": "2^24 barw.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1127,
      "question": "W modelu oświetlenia Phonga, odbicie zwierciadlane (specular):",
      "options": [
        {
          "key": "a",
          "text": "Zależy od kąta między wektorem kierunku obserwacji a wektorem kierunku odbicia światła.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Jest niezależne od kąta pomiędzy wektorem normalnym powierzchni a wektorem w kierunku źródła światła.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Nie zależy od właściwości materiału.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest identyczne dla każdego punktu powierzchni.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Odpowiada za kolor cienia obiektu.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest modelowane za pomocą funkcji sinus.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1128,
      "question": "W Ray-tracingu rekurencyjnym promienie wtórne to:",
      "options": [
        {
          "key": "a",
          "text": "Promienie odbite, załamane (transmitowane) oraz promienie cienia.",
          "correct": true
        },
        {
          "key": "b",
          "text": "wektory normalne do wszystkich powierzchni.",
          "correct": false
        },
        {
          "key": "c",
          "text": "promienie biegnące bezpośrednio z oka do rzutni.",
          "correct": false
        },
        {
          "key": "d",
          "text": "promienie generowane przez źródła światła rozproszonego.",
          "correct": false
        },
        {
          "key": "e",
          "text": "promienie pierwotne.",
          "correct": false
        },
        {
          "key": "f",
          "text": "tylko promienie załamane.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1129,
      "question": "Metoda bilansu energetycznego (Radiosity):",
      "options": [
        {
          "key": "a",
          "text": "Bazuje na zasadzie zachowania energii i modeluje wymianę światła między powierzchniami rozpraszającymi.",
          "correct": true
        },
        {
          "key": "b",
          "text": "dobrze symuluje odbicia zwierciadlane.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest metodą niezależną od widoku (view-independent).",
          "correct": true
        },
        {
          "key": "d",
          "text": "nie wymaga podziału powierzchni na patche.",
          "correct": false
        },
        {
          "key": "e",
          "text": "jest szybsza od ray-tracingu dla scen z wieloma lustrami.",
          "correct": false
        },
        {
          "key": "f",
          "text": "oblicza oświetlenie tylko dla punktów widocznych z kamery.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": true
    },
    {
      "id": 1130,
      "question": "Modele kolorów subtraktywne to:",
      "options": [
        {
          "key": "a",
          "text": "CMYK.",
          "correct": true
        },
        {
          "key": "b",
          "text": "RGB.",
          "correct": false
        },
        {
          "key": "c",
          "text": "HSV.",
          "correct": false
        },
        {
          "key": "d",
          "text": "YUV.",
          "correct": false
        },
        {
          "key": "e",
          "text": "HSL.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Lab.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1131,
      "question": "Przeplot obrazu (Interlacing):",
      "options": [
        {
          "key": "a",
          "text": "Polega na wyświetlaniu najpierw linii parzystych, a następnie nieparzystych (lub odwrotnie).",
          "correct": true
        },
        {
          "key": "b",
          "text": "algorytm renderingu bazujący na skalowaniu obrazu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "technika antyaliasingu przestrzennego.",
          "correct": false
        },
        {
          "key": "d",
          "text": "metoda kompresji bezstratnej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "służy do zwiększenia rozdzielczości pionowej.",
          "correct": false
        },
        {
          "key": "f",
          "text": "jest stosowany w nowoczesnych monitorach LCD.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1132,
      "question": "Skrót RLE (Run-Length Encoding) oznacza:",
      "options": [
        {
          "key": "a",
          "text": "Metodę bezstratnej kompresji danych polegającą na zliczaniu powtórzeń tych samych wartości.",
          "correct": true
        },
        {
          "key": "b",
          "text": "wspieraną sprzętowo bibliotekę do grafiki 3D.",
          "correct": false
        },
        {
          "key": "c",
          "text": "algorytm rasteryzacji linii.",
          "correct": false
        },
        {
          "key": "d",
          "text": "format zapisu tekstur 3D.",
          "correct": false
        },
        {
          "key": "e",
          "text": "metodę kompresji stratnej dźwięku.",
          "correct": false
        },
        {
          "key": "f",
          "text": "protokół przesyłania obrazu w sieci.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1133,
      "question": "Podstawowe transformacje geometryczne w grafice 3D to:",
      "options": [
        {
          "key": "a",
          "text": "Translacja (przesunięcie), Rotacja (obrót) i Skalowanie.",
          "correct": true
        },
        {
          "key": "b",
          "text": "przenikanie, zasłanianie, teksturowanie.",
          "correct": false
        },
        {
          "key": "c",
          "text": "cieniowanie, oświetlanie, rzutowanie.",
          "correct": false
        },
        {
          "key": "d",
          "text": "teselacja, kliping, rasteryzacja.",
          "correct": false
        },
        {
          "key": "e",
          "text": "transformacja barwna.",
          "correct": false
        },
        {
          "key": "f",
          "text": "filtracja splotowa.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1134,
      "question": "W grafice 3D, Ray-Tracing:",
      "options": [
        {
          "key": "a",
          "text": "Pozwala na łatwe uzyskanie efektów takich jak cienie, odbicia zwierciadlane i załamania światła.",
          "correct": true
        },
        {
          "key": "b",
          "text": "technika renderingu bazująca na koncepcji modelu oświetlenia lokalnego.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest zawsze szybszy od rasteryzacji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie obsługuje przezroczystości.",
          "correct": false
        },
        {
          "key": "e",
          "text": "polega na rzutowaniu wierzchołków na ekran.",
          "correct": false
        },
        {
          "key": "f",
          "text": "nie wymaga obliczania przecięć promienia z obiektami.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1135,
      "question": "Bufor Z (Z-buffer):",
      "options": [
        {
          "key": "a",
          "text": "Służy do rozstrzygania widoczności powierzchni poprzez przechowywanie głębokości pikseli.",
          "correct": true
        },
        {
          "key": "b",
          "text": "metoda nakładania tekstury na obiekt.",
          "correct": false
        },
        {
          "key": "c",
          "text": "służy do przechowywania składowej alfa koloru.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest wykorzystywany tylko w ray-tracingu.",
          "correct": false
        },
        {
          "key": "e",
          "text": "przechowuje współrzędne XY piksela.",
          "correct": false
        },
        {
          "key": "f",
          "text": "zwiększa zużycie pamięci karty graficznej.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1136,
      "question": "W grafice komputerowej 3D teselacja:",
      "options": [
        {
          "key": "a",
          "text": "Polega na podziale skomplikowanych prymitywów geometrycznych na prostsze.",
          "correct": true
        },
        {
          "key": "b",
          "text": "służy do wygładzania krawędzi (antyaliasing).",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest procesem zamiany obrazu wektorowego na rastrowy.",
          "correct": false
        },
        {
          "key": "d",
          "text": "polega na usuwaniu niewidocznych krawędzi.",
          "correct": false
        },
        {
          "key": "e",
          "text": "jest wykonywana wyłącznie na procesorze (CPU).",
          "correct": false
        },
        {
          "key": "f",
          "text": "służy do kompresji siatek wielokątów.",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1137,
      "question": "Cieniowanie Phonga (Phong Shading):",
      "options": [
        {
          "key": "a",
          "text": "Polega na interpolacji wektorów normalnych wewnątrz wielokąta i obliczaniu modelu oświetlenia dla każdego piksela.",
          "correct": true
        },
        {
          "key": "b",
          "text": "technika cieniowania polegająca na obliczeniu jasności dla jednego z wierzchołków fasety.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest identyczne z cieniowaniem Gourauda.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie pozwala na uzyskanie odblasków zwierciadlanych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "jest mniej kosztowne obliczeniowo niż cieniowanie Gourauda.",
          "correct": false
        },
        {
          "key": "f",
          "text": "daje gorsze efekty wizualne niż cieniowanie płaskie (flat).",
          "correct": false
        }
      ],
      "topic": "computer_graphics",
      "semester": 5,
      "courseName": "Grafika komputerowa",
      "multipleCorrect": false
    },
    {
      "id": 1138,
      "question": "Algorytm bankiera (Dijkstra) służy do:",
      "options": [
        {
          "key": "a",
          "text": "unikania zakleszczenia (deadlock avoidance) poprzez sprawdzanie stanu bezpiecznego.",
          "correct": true
        },
        {
          "key": "b",
          "text": "wykrywania cykli w grafie zasobów.",
          "correct": false
        },
        {
          "key": "c",
          "text": "szeregowania procesów w systemie czasu rzeczywistego.",
          "correct": false
        },
        {
          "key": "d",
          "text": "zarządzania pamięcią wirtualną.",
          "correct": false
        },
        {
          "key": "e",
          "text": "znajdowania najkrótszej ścieżki w sieci komputerowej.",
          "correct": false
        },
        {
          "key": "f",
          "text": "optymalizacji zużycia energii przez procesor.",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 1139,
      "question": "Buforowanie plików (File Buffering):",
      "options": [
        {
          "key": "a",
          "text": "Zwiększa wydajność poprzez redukcję liczby fizycznych operacji wejścia/wyjścia na dysku.",
          "correct": true
        },
        {
          "key": "b",
          "text": "służy wyłącznie do zabezpieczenia danych przed usunięciem.",
          "correct": false
        },
        {
          "key": "c",
          "text": "uniemożliwia jednoczesny dostęp wielu procesów do pliku.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest realizowane tylko w systemach 64-bitowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "polega na szyfrowaniu zawartości pliku.",
          "correct": false
        },
        {
          "key": "f",
          "text": "jest zawsze zarządzane przez użytkownika, a nie system operacyjny.",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 1140,
      "question": "Centralny Procesor, po otrzymaniu informacji o przerwaniu z urządzenia wejścia/wyjścia:",
      "options": [
        {
          "key": "a",
          "text": "Procesor kończy bieżącą instrukcję, zapisuje stan i przekazuje sterowanie do ISR.",
          "correct": true
        },
        {
          "key": "b",
          "text": "procesor natychmiast przerywa wykonywanie bieżącej instrukcji w jej połowie.",
          "correct": false
        },
        {
          "key": "c",
          "text": "przerwania są ignorowane w trybie użytkownika.",
          "correct": false
        },
        {
          "key": "d",
          "text": "tylko system operacyjny może generować przerwania.",
          "correct": false
        },
        {
          "key": "e",
          "text": "przerwania mogą być maskowalne lub niemaskowalne (NMI).",
          "correct": true
        },
        {
          "key": "f",
          "text": "po obsłudze przerwania procesor zawsze restartuje system.",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 1141,
      "question": "Inicjalna wartość semafora binarnego implementującego sekcję krytyczną (mutex) wynosi:",
      "options": [
        {
          "key": "a",
          "text": "1",
          "correct": true
        },
        {
          "key": "b",
          "text": "0",
          "correct": false
        },
        {
          "key": "c",
          "text": "-1",
          "correct": false
        },
        {
          "key": "d",
          "text": "n (liczba procesów)",
          "correct": false
        },
        {
          "key": "e",
          "text": "nieskończoność",
          "correct": false
        },
        {
          "key": "f",
          "text": "2",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 1142,
      "question": "Algorytm szeregowania z wywłaszczaniem (preemptive scheduling):",
      "options": [
        {
          "key": "a",
          "text": "Pozwala na przerwanie bieżącego procesu i przekazanie procesora innemu procesowi.",
          "correct": true
        },
        {
          "key": "b",
          "text": "szeregowanie bez wywłaszczenia.",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie pozwala na zmianę procesu przed jego zakończeniem.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest stosowany tylko w systemach wsadowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "przykładem jest algorytm Round Robin (karuzelowy).",
          "correct": true
        },
        {
          "key": "f",
          "text": "minimalizuje liczbę przełączeń kontekstu.",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 1143,
      "question": "Aby system operacyjny mógł wykonywać wielozadaniowość (multitasking):",
      "options": [
        {
          "key": "a",
          "text": "Wymaga wsparcia sprzętowego (np. przerwania zegarowe, ochrona pamięci).",
          "correct": true
        },
        {
          "key": "b",
          "text": "musi posiadać przynajmniej 2 procesory fizyczne.",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie może używać pamięci wirtualnej.",
          "correct": false
        },
        {
          "key": "d",
          "text": "wymaga, aby wszystkie programy były napisane w tym samym języku.",
          "correct": false
        },
        {
          "key": "e",
          "text": "musi implementować mechanizm przełączania kontekstu (context switching).",
          "correct": true
        },
        {
          "key": "f",
          "text": "nie może obsługiwać sieci.",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 1144,
      "question": "Jeżeli wirtualny adres w programie jest 16 bitowy i rozmiar strony jest 0,5 K to możemy maksymalnie zaadresować następującą liczbę stron:",
      "options": [
        {
          "key": "a",
          "text": "128.",
          "correct": true
        },
        {
          "key": "b",
          "text": "64.",
          "correct": false
        },
        {
          "key": "c",
          "text": "256.",
          "correct": false
        },
        {
          "key": "d",
          "text": "1024.",
          "correct": false
        },
        {
          "key": "e",
          "text": "512.",
          "correct": false
        },
        {
          "key": "f",
          "text": "32.",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 1145,
      "question": "Pamięć asocjacyjna (TLB - Translation Lookaside Buffer):",
      "options": [
        {
          "key": "a",
          "text": "Przechowuje ostatnio używane mapowania adresów wirtualnych na fizyczne.",
          "correct": true
        },
        {
          "key": "b",
          "text": "jest konieczna dla efektywnej realizacji stronicowania.",
          "correct": false
        },
        {
          "key": "c",
          "text": "służy do przechowywania danych na dysku.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest wolniejsza od pamięci RAM.",
          "correct": false
        },
        {
          "key": "e",
          "text": "jest rodzajem pamięci cache dla tablicy stron.",
          "correct": true
        },
        {
          "key": "f",
          "text": "przechowuje kody instrukcji procesora.",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 1146,
      "question": "Maksymalna liczba procesów wewnątrz sekcji krytycznej (dla zapewnienia wzajemnego wykluczania):",
      "options": [
        {
          "key": "a",
          "text": "1",
          "correct": true
        },
        {
          "key": "b",
          "text": "2",
          "correct": false
        },
        {
          "key": "c",
          "text": "Dowolna liczba.",
          "correct": false
        },
        {
          "key": "d",
          "text": "0",
          "correct": false
        },
        {
          "key": "e",
          "text": "n-1",
          "correct": false
        },
        {
          "key": "f",
          "text": "n",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 1147,
      "question": "Problem producent-konsument może być rozwiązany przy pomocy:",
      "options": [
        {
          "key": "a",
          "text": "Semafory, monitory, kolejki komunikatów.",
          "correct": true
        },
        {
          "key": "b",
          "text": "tylko Monitorów.",
          "correct": false
        },
        {
          "key": "c",
          "text": "wyłącznie zmiennych globalnych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "tylko w systemach jednoprocesorowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "algorytmu Dijkstry znajdowania najkrótszej ścieżki.",
          "correct": false
        },
        {
          "key": "f",
          "text": "instrukcji skoku bezwarunkowego.",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": false
    },
    {
      "id": 1148,
      "question": "Stan uprzywilejowany (Kernel Mode):",
      "options": [
        {
          "key": "a",
          "text": "Pozwala na wykonywanie wszystkich instrukcji procesora, w tym instrukcji sterujących sprzętem.",
          "correct": true
        },
        {
          "key": "b",
          "text": "umożliwia wykonywanie instrukcji systemu operacyjnego.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest dostępny dla każdej aplikacji użytkownika.",
          "correct": false
        },
        {
          "key": "d",
          "text": "służy do przyspieszania obliczeń matematycznych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "przejście do tego stanu następuje m.in. podczas wywołania systemowego (system call).",
          "correct": true
        },
        {
          "key": "f",
          "text": "wyklucza dostęp do pamięci RAM.",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 1149,
      "question": "Komunikacja synchroniczna między procesami:",
      "options": [
        {
          "key": "a",
          "text": "Powoduje zawieszenie procesu wysyłającego do momentu odebrania komunikatu przez odbiorcę.",
          "correct": true
        },
        {
          "key": "b",
          "text": "umożliwia procesom synchronizację ich aktywności.",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie wymaga potwierdzenia odbioru.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest zawsze szybsza od komunikacji asynchronicznej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "jest realizowana np. przez mechanizm rendezvous.",
          "correct": true
        },
        {
          "key": "f",
          "text": "nie może być stosowana w systemach rozproszonych.",
          "correct": false
        }
      ],
      "topic": "operating_systems",
      "semester": 3,
      "courseName": "Systemy operacyjne",
      "multipleCorrect": true
    },
    {
      "id": 1150,
      "question": "Parser LR:",
      "options": [
        {
          "key": "a",
          "text": "Jest parserem typu bottom-up (od dołu do góry).",
          "correct": true
        },
        {
          "key": "b",
          "text": "odczytuje symbole wejściowe od lewej strony do prawej.",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie obsługuje gramatyk z lewostronną rekurencją.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest wolniejszy od parsera LL.",
          "correct": false
        },
        {
          "key": "e",
          "text": "buduje wyprowadzenie prawostronne w odwrotnej kolejności.",
          "correct": true
        },
        {
          "key": "f",
          "text": "jest stosowany tylko dla języków regularnych.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": true
    },
    {
      "id": 1151,
      "question": "Rozstrzygalność przynależności gramatyki bezkontekstowej do klasy LL(k):",
      "options": [
        {
          "key": "a",
          "text": "Jest rozstrzygalna dla dowolnego ustalonego k.",
          "correct": true
        },
        {
          "key": "b",
          "text": "jest rozstrzygalne tylko jeśli gramatyka zawiera lewostronną rekurencję.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest nierozstrzygalna dla k > 1.",
          "correct": false
        },
        {
          "key": "d",
          "text": "zależy od liczby symboli terminalnych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "jest nierozstrzygalna dla gramatyk wieloznacznych.",
          "correct": false
        },
        {
          "key": "f",
          "text": "wymaga sprowadzenia do postaci normalnej Chomsky'ego.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": false
    },
    {
      "id": 1152,
      "question": "Porównanie gramatyk LL i LR:",
      "options": [
        {
          "key": "a",
          "text": "Klasa gramatyk LL(k) jest właściwym podzbiorem klasy gramatyk LR(k).",
          "correct": true
        },
        {
          "key": "b",
          "text": "gramatyki LL oraz LR opisują częściowo rozłączne klasy gramatyk.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Każda gramatyka LR jest gramatyką LL.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Gramatyki LL są potężniejsze od LR.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Gramatyki LR radzą sobie z lewostronną rekurencją, której LL nie obsługuje bezpośrednio.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Gramatyki LL(1) są równoważne gramatykom LR(1).",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": true
    },
    {
      "id": 1153,
      "question": "Złożoność analizatorów LL(k) oraz LR(k) dla słowa o długości n wynosi:",
      "options": [
        {
          "key": "a",
          "text": "Czasowa O(n) i pamięciowa O(n).",
          "correct": true
        },
        {
          "key": "b",
          "text": "czasową Theta(n) i pamięciową Theta(n).",
          "correct": false
        },
        {
          "key": "c",
          "text": "Czasowa O(n^2).",
          "correct": false
        },
        {
          "key": "d",
          "text": "Czasowa O(2^n).",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pamięciowa O(1).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Czasowa O(log n).",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": false
    },
    {
      "id": 1154,
      "question": "Dla gramatyki bezkontekstowej z produkcjami: E→E+E E→E*E E → id następujące wyprowadzenia są prawostronne:",
      "options": [
        {
          "key": "a",
          "text": "E => E+E => E+EE => E+Eid => E+idid => id+idid.",
          "correct": true
        },
        {
          "key": "b",
          "text": "E => E+E => id+E => id+EE => id+idE => id+idid.",
          "correct": false
        },
        {
          "key": "c",
          "text": "E => id.",
          "correct": false
        },
        {
          "key": "d",
          "text": "E => EE => idid.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest niemożliwe dla tej gramatyki.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Zawsze kończy się symbolem E.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": false
    },
    {
      "id": 1155,
      "question": "Które stwierdzenie jest prawdziwe dotyczące gramatyk LR?",
      "options": [
        {
          "key": "a",
          "text": "Nie każda gramatyka bezkontekstowa jest klasy LR(k) (np. gramatyki wieloznaczne nie są LR).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Każda gramatyka bezkontekstowa jest klasy LR(k) dla pewnego k > 0.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Gramatyki LR(0) mogą opisywać wszystkie języki bezkontekstowe.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Analiza LR wymaga gramatyki w postaci normalnej Greibach.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Gramatyki LR(1) są wystarczające do opisu większości języków programowania.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Gramatyki LR nie mogą być generowane automatycznie.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": true
    },
    {
      "id": 1156,
      "question": "Dla gramatyki bezkontekstowej z produkcjami: E' → E E→E+T | T T→T*F|F F → (E) | id domknięcie (closure) zbioru sytuacji I= {E' →•E} zawiera sytuacje:",
      "options": [
        {
          "key": "a",
          "text": "E' -> .E, E -> .E+T, E -> .T, T -> .TF, T -> .F, F -> .(E), F -> .id.",
          "correct": true
        },
        {
          "key": "b",
          "text": "E' -> E.",
          "correct": false
        },
        {
          "key": "c",
          "text": "E -> E.+T.",
          "correct": false
        },
        {
          "key": "d",
          "text": "F -> id.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Tylko E' -> .E.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wszystkie produkcje z kropką na końcu.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": false
    },
    {
      "id": 1157,
      "question": "Dana jest gramatyka (wzbogacona) z produkcjami: E' → E E→E+T | T T→T*F|F F → (E) | id Które z podanych symboli należą do zbioru FOLLOW(F):",
      "options": [
        {
          "key": "a",
          "text": "+, *, ), $ (koniec napisu).",
          "correct": true
        },
        {
          "key": "b",
          "text": "id.",
          "correct": false
        },
        {
          "key": "c",
          "text": "E, T.",
          "correct": false
        },
        {
          "key": "d",
          "text": "(, id.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Tylko $.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wszystkie nieterminale.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": false
    },
    {
      "id": 1158,
      "question": "Gramatyka operatorowa:",
      "options": [
        {
          "key": "a",
          "text": "To gramatyka bezkontekstowa, w której żadna produkcja nie ma po prawej stronie dwóch sąsiednich nieterminali ani epsilona.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Gramatyka operatorowa jest gramatyką bezkontekstową.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Służy wyłącznie do opisu języków regularnych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie może zawierać symboli terminalnych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwala na łatwą implementację parserów wyrażeń matematycznych.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest zawsze wieloznaczna.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": true
    },
    {
      "id": 1159,
      "question": "Analiza leksykalna (skaner) obejmuje:",
      "options": [
        {
          "key": "a",
          "text": "Grupowanie znaków wejściowych w leksemy i generowanie odpowiadających im tokenów.",
          "correct": true
        },
        {
          "key": "b",
          "text": "usunięcie tokenów a znalezienie leksemów.",
          "correct": false
        },
        {
          "key": "c",
          "text": "budowanie drzewa składniowego.",
          "correct": false
        },
        {
          "key": "d",
          "text": "sprawdzanie zgodności typów.",
          "correct": false
        },
        {
          "key": "e",
          "text": "usuwanie komentarzy i białych znaków z kodu źródłowego.",
          "correct": true
        },
        {
          "key": "f",
          "text": "generowanie kodu pośredniego.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": true
    },
    {
      "id": 1160,
      "question": "Analizatory LL oraz LR:",
      "options": [
        {
          "key": "a",
          "text": "Oba są analizatorami kierunkowymi (przetwarzają wejście od lewej do prawej).",
          "correct": true
        },
        {
          "key": "b",
          "text": "LL nie jest analizatorem kierunkowym.",
          "correct": false
        },
        {
          "key": "c",
          "text": "LR przetwarza wejście od prawej do lewej.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Żaden z nich nie używa stosu.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wykorzystują wiedzę o symbolach już przetworzonych oraz podglądają symbole w przód (lookahead).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Są stosowane tylko w kompilatorach języka C.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": true
    },
    {
      "id": 1161,
      "question": "Parametr k w analizatorach LL(k) oznacza:",
      "options": [
        {
          "key": "a",
          "text": "Liczbę symboli podglądanych (lookahead) w przód na wejściu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "parametr k oznacza liczbę błędów, po których analizator przerywa działanie.",
          "correct": false
        },
        {
          "key": "c",
          "text": "liczbę kroków wyprowadzenia.",
          "correct": false
        },
        {
          "key": "d",
          "text": "maksymalną głębokość stosu.",
          "correct": false
        },
        {
          "key": "e",
          "text": "liczbę nieterminali w gramatyce.",
          "correct": false
        },
        {
          "key": "f",
          "text": "liczbę stanów automatu.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": false
    },
    {
      "id": 1162,
      "question": "Która z poniższych opcji najlepiej opisuje klasyfikację Chomsky'ego dotyczącą gramatyk formalnych?",
      "options": [
        {
          "key": "a",
          "text": "Cztery poziomy gramatyk: typ 0, typ 1, typ 2, typ 3.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Klasyfikacja Chomsky'ego obejmuje pięć poziomów gramatyk.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Tylko języki programowania.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wyłącznie gramatyki skończone.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Typ 2 to gramatyki bezkontekstowe, a typ 3 to gramatyki regularne.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Typ 0 to gramatyki liniowe.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": true
    },
    {
      "id": 1163,
      "question": "Które z poniższych stwierdzeń najlepiej opisuje rolę metajęzyka w kontekście antynomii semantycznych?",
      "options": [
        {
          "key": "a",
          "text": "Metajęzyk służy do opisu i analizy innego języka (przedmiotowego).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Metajęzyk jest językiem, który jest bardziej złożony niż język przedmiotowy.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Metajęzyk nie może zawierać nazw.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Metajęzyk jest zawsze językiem naturalnym.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Rozróżnienie języka przedmiotowego od metajęzyka pozwala na definiowanie prawdy bez popadania w paradoksy.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Metajęzyk służy wyłącznie do tłumaczenia tekstów.",
          "correct": false
        }
      ],
      "topic": "compilation",
      "semester": 4,
      "courseName": "Teoria kompilacji i kompilatory",
      "multipleCorrect": true
    },
    {
      "id": 1164,
      "question": "Które z poniższych stwierdzeń najlepiej opisuje różnicę między wybranymi paradygmatami języków programowania?",
      "options": [
        {
          "key": "a",
          "text": "Paradygmat imperatywny opisuje \"jak\", deklaratywny opisuje \"co\".",
          "correct": true
        },
        {
          "key": "b",
          "text": "Paradygmat imperatywny jest stosowany wyłącznie w językach niskiego poziomu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Języki funkcyjne są zawsze imperatywne.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Programowanie obiektowe wyklucza paradygmat deklaratywny.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Programowanie obiektowe skupia się na łączeniu danych i zachowań w obiekty.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Paradygmat logiczny jest podzbiorem paradygmatu imperatywnego.",
          "correct": false
        }
      ],
      "topic": "programming_basics",
      "semester": 1,
      "courseName": "Podstawy programowania",
      "multipleCorrect": true
    },
    {
      "id": 1165,
      "question": "W kontekście paradygmatów języków programowania, które z poniższych stwierdzeń najlepiej charakteryzują ich własności",
      "options": [
        {
          "key": "a",
          "text": "Paradygmat funkcyjny opiera się na ewaluacji funkcji matematycznych, logiczny na wnioskowaniu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Paradygmat funkcyjny skupia się na niezmiennych danych i funkcjach jako podstawowych jednostkach obliczeń.",
          "correct": false
        },
        {
          "key": "c",
          "text": "W paradygmacie logicznym nie istnieją zmienne.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Oba paradygmaty są odmianami programowania proceduralnego.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Oba paradygmaty należą do szerszej grupy paradygmatów deklaratywnych.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Język Prolog jest przykładem języka funkcyjnego.",
          "correct": false
        }
      ],
      "topic": "programming_basics",
      "semester": 1,
      "courseName": "Podstawy programowania",
      "multipleCorrect": true
    },
    {
      "id": 1166,
      "question": "Które z poniższych stwierdzeń najlepiej opisują różnicę między pewnymi pewnymi typami algorytmów:",
      "options": [
        {
          "key": "a",
          "text": "Algorytm deterministyczny dla tych samych danych zawsze przechodzi przez tę samą ścieżkę obliczeń.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Algorytm deterministyczny zawsze daje różne wyniki dla tych samych danych wejściowych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Algorytm niedeterministyczny nie może być zaimplementowany na komputerze.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Złożoność P dotyczy algorytmów niedeterministycznych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Algorytm niedeterministyczny może być postrzegany jako posiadający zdolność \"zgadywania\" poprawnej ścieżki.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Każdy algorytm niedeterministyczny ma złożoność wykładniczą.",
          "correct": false
        }
      ],
      "topic": "programming_basics",
      "semester": 1,
      "courseName": "Podstawy programowania",
      "multipleCorrect": true
    },
    {
      "id": 1167,
      "question": "Które stwierdzenia dotyczące entropii Shannona są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "Określa średnią ilość informacji przypadającą na jeden symbol źródła.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wartość entropii zawsze jest dodatnia (lub zero).",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest maksymalna, gdy wszystkie symbole mają różne prawdopodobieństwa.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie zależy od prawdopodobieństwa wystąpienia symboli.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Entropia jest maksymalna dla rozkładu jednostajnego (wszystkie symbole równie prawdopodobne).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jednostką entropii jest zawsze bajt.",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": true
    },
    {
      "id": 1168,
      "question": "Które z podanych stwierdzeń w odniesieniu do kodu Hamminga są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "Pozwala na wykrywanie i korekcję błędów pojedynczego bitu (SEC) oraz wykrywanie błędów dwóch bitów (DED).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Kod Hamminga pozwala korygować błędy polegające na przekłamaniu dwóch bitów.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest kodem o zmiennej długości słowa.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie używa bitów parzystości.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Odległość Hamminga dla kodu korygującego pojedyncze błędy musi wynosić co najmniej 3.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Kod Hamminga jest kodem stratnym.",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": true
    },
    {
      "id": 1169,
      "question": "Kodowanie Shannona-Fano i Huffmana:",
      "options": [
        {
          "key": "a",
          "text": "Tworzą kody prefiksowe.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Kodowanie Shannona-Fano tworzy kod postfiksowy.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Są metodami kompresji stratnej.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Huffmana daje zawsze gorsze wyniki niż Shannona-Fano.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Kodowanie Huffmana jest optymalnym kodowaniem prefiksowym dla danych prawdopodobieństw symboli.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Oba kody wymagają przesyłania słownika razem z danymi.",
          "correct": false
        }
      ],
      "topic": "number_representation",
      "semester": 1,
      "courseName": "Wstęp do informatyki",
      "multipleCorrect": true
    },
    {
      "id": 1170,
      "question": "Które stwierdzenia dotyczące kompresji JPEG są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "Wykorzystuje stratną kompresję opartą na dyskretnej transformacie kosinusowej (DCT).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Typowo w procesie kompresji wykorzystuje transformatę Fouriera.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest optymalna do kompresji tekstu i grafiki o ostrych krawędziach.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie pozwala na regulację stopnia kompresji.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wykorzystuje kwantyzację w celu usunięcia informacji mniej istotnych dla ludzkiego oka.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest formatem wyłącznie bezstratnym.",
          "correct": false
        }
      ],
      "topic": "image_processing",
      "semester": 6,
      "courseName": "Przetwarzanie obrazów cyfrowych",
      "multipleCorrect": true
    },
    {
      "id": 1171,
      "question": "Pracując w powłoce bash pod kontrolą systemu operacyjnego Linux lub UNIX uruchomienie polecenia: rm / && echo ok",
      "options": [
        {
          "key": "a",
          "text": "Zazwyczaj zakończy się błędem, a \"ok\" nie zostanie wypisane.",
          "correct": true
        },
        {
          "key": "b",
          "text": "spowoduje wypisanie na standardowym wyjściu komunikatu o niemożności usunięcia katalogu /",
          "correct": false
        },
        {
          "key": "c",
          "text": "usunie wszystkie pliki w systemie.",
          "correct": false
        },
        {
          "key": "d",
          "text": "wypisze \"ok\" niezależnie od wyniku rm.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Operator && wykonuje drugie polecenie tylko wtedy, gdy pierwsze zakończyło się sukcesem (kod wyjścia 0).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Polecenie rm / bez opcji -r usunie katalog główny.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 1172,
      "question": "Pracując w powłoce bash systemu operacyjnego Linux lub UNIX użycie wzorca nazwy pliku data.{txt,sql,iq} będzie pasować do pliku o nazwie:",
      "options": [
        {
          "key": "a",
          "text": "data.txt, data.sql lub data.iq.",
          "correct": true
        },
        {
          "key": "b",
          "text": "data.",
          "correct": false
        },
        {
          "key": "c",
          "text": "dowolnego pliku zaczynającego się od data.",
          "correct": false
        },
        {
          "key": "d",
          "text": "tylko pliku o nazwie data.{txt,sql,iq}.",
          "correct": false
        },
        {
          "key": "e",
          "text": "plików o nazwach data.txtsql i data.txtiq.",
          "correct": false
        },
        {
          "key": "f",
          "text": "wzorzec ten nie jest obsługiwany przez bash.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": false
    },
    {
      "id": 1173,
      "question": "Uprawnienia w systemie Linux/UNIX:",
      "options": [
        {
          "key": "a",
          "text": "System opiera się na uprawnieniach dla właściciela, grupy i innych (rwx).",
          "correct": true
        },
        {
          "key": "b",
          "text": "każdy użytkownik ma dostęp do wszystkich plików zarządzanych przez system operacyjny.",
          "correct": false
        },
        {
          "key": "c",
          "text": "tylko administrator (root) może czytać pliki.",
          "correct": false
        },
        {
          "key": "d",
          "text": "uprawnienia nie dotyczą katalogów.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Uprawnienie 'x' dla katalogu pozwala na wejście do niego (cd).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Uprawnienia są zapisywane w treści pliku.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 1174,
      "question": "Posługując się nazwami plików, pracując w powłoce bash systemu operacyjnego Linux lub UNIX, ? (pytajnik) oznacza:",
      "options": [
        {
          "key": "a",
          "text": "dokładnie jeden dowolny znak.",
          "correct": true
        },
        {
          "key": "b",
          "text": "dowolny ciąg znaków (w tym pusty).",
          "correct": false
        },
        {
          "key": "c",
          "text": "zero lub jeden znak.",
          "correct": false
        },
        {
          "key": "d",
          "text": "znak zapytania.",
          "correct": false
        },
        {
          "key": "e",
          "text": "dowolną cyfrę.",
          "correct": false
        },
        {
          "key": "f",
          "text": "dowolną literę.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": false
    },
    {
      "id": 1175,
      "question": "System Linux/UNIX:",
      "options": [
        {
          "key": "a",
          "text": "Jest systemem wielozadaniowym i wieloużytkownikowym.",
          "correct": true
        },
        {
          "key": "b",
          "text": "obsługuje wielu użytkowników.",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie posiada systemu plików.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest systemem czasu rzeczywistego z natury.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jądro (kernel) zarządza zasobami sprzętowymi i udostępnia je aplikacjom.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest systemem wyłącznie tekstowym.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 1176,
      "question": "Zmienna $? w powłoce bash dla systemu operacyjnego Linux lub UNIX przechowuje wartość:",
      "options": [
        {
          "key": "a",
          "text": "kod wyjścia (exit status) ostatnio wykonanego polecenia.",
          "correct": true
        },
        {
          "key": "b",
          "text": "nie ma takiej zmiennej.",
          "correct": false
        },
        {
          "key": "c",
          "text": "identyfikator procesu powłoki.",
          "correct": false
        },
        {
          "key": "d",
          "text": "ostatni argument poprzedniego polecenia.",
          "correct": false
        },
        {
          "key": "e",
          "text": "liczbę argumentów przekazanych do skryptu.",
          "correct": false
        },
        {
          "key": "f",
          "text": "nazwę bieżącego użytkownika.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": false
    },
    {
      "id": 1177,
      "question": "Uruchomienie, w powłoce bash systemu operacyjnego Linux lub UNIX, polecenia: ls | less powoduje:",
      "options": [
        {
          "key": "a",
          "text": "przekazanie standardowego wyjścia ls na standardowe wejście less.",
          "correct": true
        },
        {
          "key": "b",
          "text": "przekazanie standardowego wyjścia less na standardowe wejście ls.",
          "correct": false
        },
        {
          "key": "c",
          "text": "równoległe wykonanie obu poleceń bez powiązania.",
          "correct": false
        },
        {
          "key": "d",
          "text": "zapisanie wyniku ls do pliku o nazwie less.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Umożliwia wygodne przeglądanie długiej listy plików generowanej przez ls.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Wyświetla tylko błędy polecenia ls.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 1178,
      "question": "Korzystając z systemu operacyjnego Linux lub UNIX, ustawienie praw dostępu 700 na pliku oznacza:",
      "options": [
        {
          "key": "a",
          "text": "Pełne prawa (rwx) dla właściciela i brak jakichkolwiek praw dla grupy i innych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "brak praw dla innych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "prawo tylko do odczytu dla wszystkich.",
          "correct": false
        },
        {
          "key": "d",
          "text": "prawo do wykonywania dla grupy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "prawo do zapisu dla wszystkich.",
          "correct": false
        },
        {
          "key": "f",
          "text": "plik jest ukryty.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": false
    },
    {
      "id": 1179,
      "question": "Pracując w powłoce bash systemu operacyjnego Linux lub UNIX użycie skrótu klawiszowego Control-c powoduje:",
      "options": [
        {
          "key": "a",
          "text": "Wysyła sygnał SIGINT do bieżącego procesu na pierwszym planie.",
          "correct": true
        },
        {
          "key": "b",
          "text": "nic.",
          "correct": false
        },
        {
          "key": "c",
          "text": "kopiuje zaznaczony tekst.",
          "correct": false
        },
        {
          "key": "d",
          "text": "wylogowuje użytkownika.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Powoduje zazwyczaj natychmiastowe przerwanie działania programu.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Zamyka wszystkie okna terminala.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 1180,
      "question": "Pracując w powłoce bash systemu operacyjnego Linux lub UNIX, użycie skrótu klawiszowego Control-z powoduje:",
      "options": [
        {
          "key": "a",
          "text": "Wysyła sygnał SIGTSTP, wstrzymując działanie procesu i przenosząc go w tło.",
          "correct": true
        },
        {
          "key": "b",
          "text": "wstrzymanie działania aktualnie obsługiwanego procesu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zamyka terminal.",
          "correct": false
        },
        {
          "key": "d",
          "text": "cofa ostatnią operację w edytorze.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Proces wstrzymany można przywrócić poleceniem 'fg' lub 'bg'.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Usuwa bieżącą linię poleceń.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 1181,
      "question": "Posługując się nazwami plików, pracując w powłoce bash systemu operacyjnego Linux lub UNIX, * (gwiazdka) oznacza:",
      "options": [
        {
          "key": "a",
          "text": "dowolny ciąg znaków (również pusty).",
          "correct": true
        },
        {
          "key": "b",
          "text": "pojedynczy znak.",
          "correct": false
        },
        {
          "key": "c",
          "text": "tylko litery.",
          "correct": false
        },
        {
          "key": "d",
          "text": "tylko cyfry.",
          "correct": false
        },
        {
          "key": "e",
          "text": "dowolny znak poza kropką na początku nazwy.",
          "correct": false
        },
        {
          "key": "f",
          "text": "tylko rozszerzenia plików.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": false
    },
    {
      "id": 1182,
      "question": "Pliki, których nazwa zaczyna się od kropki (np. .bashrc):",
      "options": [
        {
          "key": "a",
          "text": "Są traktowane jako pliki ukryte.",
          "correct": true
        },
        {
          "key": "b",
          "text": "nie mogą być używane.",
          "correct": false
        },
        {
          "key": "c",
          "text": "są plikami systemowymi tylko do odczytu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "muszą mieć rozszerzenie .dot.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Można je wyświetlić za pomocą polecenia 'ls -a'.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Są automatycznie usuwane przy wylogowaniu.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": true
    },
    {
      "id": 1183,
      "question": "Pracując w powłoce bash systemu operacyjnego Linux lub UNIX użycie wzorca nazwy pliku [123]data będzie pasować do:",
      "options": [
        {
          "key": "a",
          "text": "1data, 2data lub 3data.",
          "correct": true
        },
        {
          "key": "b",
          "text": "data.",
          "correct": false
        },
        {
          "key": "c",
          "text": "123data.",
          "correct": false
        },
        {
          "key": "d",
          "text": "dowolnego pliku kończącego się na data.",
          "correct": false
        },
        {
          "key": "e",
          "text": "plików o nazwach [1]data, [2]data, [3]data.",
          "correct": false
        },
        {
          "key": "f",
          "text": "tylko pliku o nazwie [123]data.",
          "correct": false
        }
      ],
      "topic": "unix_admin",
      "semester": 3,
      "courseName": "Systemy uniksowe",
      "multipleCorrect": false
    },
    {
      "id": 1184,
      "question": "Relacja rozszerzenia (<<extend>>) w diagramach przypadków użycia UML:",
      "options": [
        {
          "key": "a",
          "text": "Wskazuje opcjonalne zachowanie, które może zostać dołączone do przypadku użycia.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Używana jest do pokazania, że przypadek użycia jest podzbiorem innego przypadku użycia.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest obowiązkowa dla każdego przypadku użycia.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Służy do modelowania dziedziczenia między aktorami.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Strzałka relacji <<extend>> jest skierowana od przypadku użycia rozszerzającego do bazowego.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Zawsze wykonuje się razem z przypadkiem bazowym.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1185,
      "question": "Relacja „zawiera” (<<include>>) w diagramach przypadków użycia UML:",
      "options": [
        {
          "key": "a",
          "text": "Wskazuje, że jeden przypadek użycia obowiązkowo wykorzystuje funkcjonalność innego.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Określa, że jeden przypadek użycia jest w całości zależny od funkcjonalności innego przypadku użycia.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest używana do modelowania opcjonalnych funkcji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Łączy aktora z przypadkiem użycia.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwala na wydzielenie wspólnej funkcjonalności do oddzielnego przypadku użycia.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Strzałka jest skierowana od przypadku dołączanego do bazowego.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1186,
      "question": "Jakie są kluczowe cechy podejścia strukturalnego Yourdona do analizy systemów?",
      "options": [
        {
          "key": "a",
          "text": "Opiera się na dekompozycji funkcjonalnej systemu i wykorzystuje diagramy przepływu danych (DFD).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Modelowanie zachowań systemu z użyciem złożonych diagramów stanów dla każdej funkcji.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest tożsame z podejściem obiektowym.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie uwzględnia modelowania danych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wykorzystuje słownik danych oraz specyfikacje procesów.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest nowoczesną alternatywą dla Agile.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1187,
      "question": "Model spiralny cyklu życia oprogramowania:",
      "options": [
        {
          "key": "a",
          "text": "Jest modelem iteracyjnym, w którym kluczowym elementem jest analiza ryzyka.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Główny nacisk kładziony jest na szybkie wytwarzanie oprogramowania bez fazy testowania.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wyklucza możliwość powrotu do poprzednich faz.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest przeznaczony tylko dla bardzo małych projektów.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Każdy obrót spirali obejmuje planowanie, analizę ryzyka, inżynierię i ocenę.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest modelem liniowym (kaskadowym).",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1188,
      "question": "Cele metodyki Scrum:",
      "options": [
        {
          "key": "a",
          "text": "Dostarczanie wartości biznesowej w krótkich iteracjach (Sprintach).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Zwiększenie przewidywalności i jakości dostaw poprzez regularne iteracje i stałe przeglądy.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wyeliminowanie potrzeby dokumentacji technicznej.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Sztywne planowanie całego projektu na samym początku.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wspieranie samoorganizacji zespołu i ciągłego doskonalenia procesu.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Zastąpienie programistów przez Scrum Masterów.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1189,
      "question": "Poziomy dojrzałości w modelu CMM (Capability Maturity Model):",
      "options": [
        {
          "key": "a",
          "text": "Początkowy, Powtarzalny, Zdefiniowany, Zarządzany, Optymalizujący.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Analiza, Projektowanie, Wdrożenie, Ocena.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Niski, Średni, Wysoki, Ekspercki.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Planowanie, Realizacja, Testowanie, Utrzymanie.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Poziom 0, Poziom 1, Poziom 2, Poziom 3, Poziom 4.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Brak, Podstawowy, Zaawansowany, Profesjonalny.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 1190,
      "question": "Zdolność do pielęgnacji (Maintainability) oprogramowania:",
      "options": [
        {
          "key": "a",
          "text": "Łatwość, z jaką można modyfikować oprogramowanie w celu naprawy błędów lub dostosowania.",
          "correct": true
        },
        {
          "key": "b",
          "text": "zawartość pełnej dokumentacji technicznej kodu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "odporność systemu na ataki hakerskie.",
          "correct": false
        },
        {
          "key": "d",
          "text": "szybkość działania aplikacji na starym sprzęcie.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Obejmuje takie aspekty jak czytelność kodu, modularność i testowalność.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Gwarantuje, że oprogramowanie nigdy nie będzie wymagało zmian.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1191,
      "question": "Niezawodność (Reliability) oprogramowania:",
      "options": [
        {
          "key": "a",
          "text": "Zdolność systemu do poprawnego działania w określonych warunkach przez określony czas.",
          "correct": true
        },
        {
          "key": "b",
          "text": "w miarę możliwości najkrótszy okres bezczynności po awarii.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zgodność z wymaganiami estetycznymi użytkownika.",
          "correct": false
        },
        {
          "key": "d",
          "text": "brak konieczności aktualizacji systemu.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest mierzona m.in. przez MTBF (Mean Time Between Failures).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Oznacza, że system jest w 100% wolny od błędów.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1192,
      "question": "Proces inżynierii wymagań:",
      "options": [
        {
          "key": "a",
          "text": "Obejmuje pozyskiwanie, analizę, specyfikację, weryfikację i zarządzanie wymaganiami.",
          "correct": true
        },
        {
          "key": "b",
          "text": "wynajdowania, dokumentowania, wdrażania.",
          "correct": false
        },
        {
          "key": "c",
          "text": "dotyczy tylko wymagań niefunkcjonalnych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "kończy się przed rozpoczęciem projektowania.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Ma na celu zrozumienie i udokumentowanie potrzeb interesariuszy.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest wykonywany wyłącznie przez programistów.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1193,
      "question": "Wymagania niefunkcjonalne (systemowe):",
      "options": [
        {
          "key": "a",
          "text": "Określają jakościowe aspekty systemu, takie jak wydajność, bezpieczeństwo, dostępność.",
          "correct": true
        },
        {
          "key": "b",
          "text": "opisują właściwości i ograniczenia systemu np. niezawodność, czas odpowiedzi.",
          "correct": false
        },
        {
          "key": "c",
          "text": "opisują konkretne funkcje, które system musi realizować.",
          "correct": false
        },
        {
          "key": "d",
          "text": "są mniej ważne od wymagań funkcjonalnych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Często nazywane są \"atrybutami jakościowymi\" systemu.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Nie mogą być testowane.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1194,
      "question": "Testy jednostkowe (Unit Tests):",
      "options": [
        {
          "key": "a",
          "text": "Sprawdzają poprawność działania najmniejszych testowalnych części kodu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "zawsze wykonywane są w pełnej izolacji od innych komponentów systemu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "są wykonywane przez użytkownika końcowego.",
          "correct": false
        },
        {
          "key": "d",
          "text": "służą do testowania wydajności całego systemu.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Automatyzacja testów jednostkowych ułatwia refaktoryzację kodu.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Powinny być pisane dopiero po zakończeniu całego projektu.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1195,
      "question": "Aby ograniczyć zakres zmian w systemie (zasada niskiego sprzężenia):",
      "options": [
        {
          "key": "a",
          "text": "Należy stosować hermetyzację, interfejsy oraz modularność.",
          "correct": true
        },
        {
          "key": "b",
          "text": "podejście komponentowe.",
          "correct": false
        },
        {
          "key": "c",
          "text": "należy pisać cały kod w jednym pliku.",
          "correct": false
        },
        {
          "key": "d",
          "text": "należy unikać stosowania wzorców projektowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Komponenty powinny zależeć od abstrakcji, a nie od konkretnych implementacji.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Należy stosować jak najwięcej zmiennych globalnych.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1196,
      "question": "Podejście modelowe (Model-Driven Development):",
      "options": [
        {
          "key": "a",
          "text": "Modele są głównym artefaktem procesu, z których może być generowany kod źródłowy.",
          "correct": true
        },
        {
          "key": "b",
          "text": "jednym z zadań analizy jest budowa modeli, opisujących działanie systemu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "modele UML są jedynym sposobem modelowania.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie jest prawdą że modele mogą służyć do dokumentacji.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwala na podniesienie poziomu abstrakcji w procesie tworzenia oprogramowania.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Wyklucza udział programistów w procesie.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1197,
      "question": "Przykład aktywności DevOps:",
      "options": [
        {
          "key": "a",
          "text": "Ciągła integracja i ciągłe wdrażanie (CI/CD) oraz automatyzacja infrastruktury.",
          "correct": true
        },
        {
          "key": "b",
          "text": "automatyczne monitorowanie parametrów uruchomionej aplikacji.",
          "correct": false
        },
        {
          "key": "c",
          "text": "oddzielenie zespołu programistów od zespołu administratorów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "ręczne testowanie aplikacji przed każdym wydaniem.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Współpraca między zespołami rozwoju (Dev) i operacji (Ops) w całym cyklu życia.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Pisanie dokumentacji w formacie PDF.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1198,
      "question": "Diagramy sekwencji UML:",
      "options": [
        {
          "key": "a",
          "text": "Przedstawiają interakcje między obiektami w układzie chronologicznym.",
          "correct": true
        },
        {
          "key": "b",
          "text": "linia życia reprezentuje życie obiektu w czasie trwania interakcji.",
          "correct": false
        },
        {
          "key": "c",
          "text": "służą do modelowania statycznej struktury klas.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie pokazują komunikatów asynchronicznych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Skupiają się na kolejności przesyłanych komunikatów.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Są odmianą diagramów wdrożenia.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1199,
      "question": "Diagramy stanów UML:",
      "options": [
        {
          "key": "a",
          "text": "Modelują zachowanie obiektu poprzez opis stanów i zdarzeń.",
          "correct": true
        },
        {
          "key": "b",
          "text": "stan historii automatycznie aktualizuje stan obiektu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "są używane wyłącznie do modelowania baz danych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie pozwalają na definiowanie stanów zagnieżdżonych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Są szczególnie przydatne do modelowania systemów sterowania i protokołów.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Pokazują strukturę folderów w projekcie.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1200,
      "question": "Diagramy aktywności UML:",
      "options": [
        {
          "key": "a",
          "text": "Służą do modelowania przepływów sterowania i danych w procesach biznesowych lub algorytmach.",
          "correct": true
        },
        {
          "key": "b",
          "text": "użycie \"tokenu\" w różnych ścieżkach przepływu reprezentuje przypadek użycia.",
          "correct": false
        },
        {
          "key": "c",
          "text": "są identyczne z diagramami klas.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie obsługują współbieżności (fork/join).",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwalają na wizualizację równoległych ścieżek wykonania.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Służą do projektowania baz danych NoSQL.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1201,
      "question": "Diagramy wdrożenia (Deployment Diagrams) UML:",
      "options": [
        {
          "key": "a",
          "text": "Przedstawiają fizyczną architekturę systemu, w tym węzły sprzętowe i artefakty.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Pokazują interfejsy użytkownika i ich interakcje.",
          "correct": false
        },
        {
          "key": "c",
          "text": "służą do projektowania algorytmów sortowania.",
          "correct": false
        },
        {
          "key": "d",
          "text": "modelują relacje między tabelami w bazie danych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Węzły mogą reprezentować serwery, stacje robocze lub urządzenia wbudowane.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Służą do modelowania logiki biznesowej.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1202,
      "question": "Komunikaty na diagramach sekwencji:",
      "options": [
        {
          "key": "a",
          "text": "Reprezentują wywołania metod lub przesyłanie sygnałów między obiektami.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Komunikatów na diagramach reprezentują komunikaty poziome i pionowe.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zawsze muszą być synchroniczne.",
          "correct": false
        },
        {
          "key": "d",
          "text": "są rysowane jako linie pionowe.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Komunikat zwrotny (reply) jest zazwyczaj rysowany linią przerywaną.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Nie mogą posiadać argumentów.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1203,
      "question": "Zagnieżdżone stany w diagramach stanów UML:",
      "options": [
        {
          "key": "a",
          "text": "Pozwalają na hierarchiczną strukturę stanów, gdzie stan złożony zawiera w sobie podstany.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Zagnieżdżone stany umożliwiają definiowanie jednorazowych działań.",
          "correct": false
        },
        {
          "key": "c",
          "text": "służą do modelowania pętli w programie.",
          "correct": false
        },
        {
          "key": "d",
          "text": "są zabronione w standardzie UML 2.0.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwalają na współdzielenie przejść przez wszystkie podstany.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Służą do modelowania dziedziczenia klas.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": true
    },
    {
      "id": 1204,
      "question": "W odniesieniu i kontekście języka UML (Unified Modeling Language) można powiedzieć, że",
      "options": [
        {
          "key": "a",
          "text": "To proces generowania kodu źródłowego na podstawie modeli (diagramów).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Forward engineering to technika używana do optymalizacji kodu źródłowego.",
          "correct": false
        },
        {
          "key": "c",
          "text": "polega na tworzeniu dokumentacji z kodu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "dotyczy tylko testowania oprogramowania.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest procesem ręcznego przepisywania diagramów na język naturalny.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Służy do usuwania błędów z bazy danych.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 1205,
      "question": "W odniesieniu i kontekście języka UMLUML (Unified Modeling Language) można powiedzieć, że",
      "options": [
        {
          "key": "a",
          "text": "To proces tworzenia modeli (diagramów) na podstawie analizy istniejącego kodu źródłowego.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Backward engineering polega na analizie istniejącego systemu i tworzeniu diagramów UML.",
          "correct": false
        },
        {
          "key": "c",
          "text": "służy do automatycznego naprawiania błędów w kodzie.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest niemożliwy dla języków obiektowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwala na zrozumienie architektury starego systemu (legacy code).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Służy do szyfrowania kodu źródłowego.",
          "correct": false
        }
      ],
      "topic": "software_engineering",
      "semester": 4,
      "courseName": "Inżynieria oprogramowania",
      "multipleCorrect": false
    },
    {
      "id": 1206,
      "question": "Po wykonaniu fragmentu kodu napisanego w języku C: int a,b=1; a=b++ + b;",
      "options": [
        {
          "key": "a",
          "text": "Wynik jest niezdefiniowany (undefined behavior).",
          "correct": true
        },
        {
          "key": "b",
          "text": "operator + nie ma w standardzie C określonej kolejności obliczenia operandów.",
          "correct": false
        },
        {
          "key": "c",
          "text": "a zawsze wyniesie 3.",
          "correct": false
        },
        {
          "key": "d",
          "text": "a zawsze wyniesie 2.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wynik zależy od wersji kompilatora i poziomu optymalizacji.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Kod ten nie skompiluje się w standardzie C11.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 1207,
      "question": "Typ double w języku C:",
      "options": [
        {
          "key": "a",
          "text": "Służy do przechowywania liczb zmiennoprzecinkowych podwójnej precyzji.",
          "correct": true
        },
        {
          "key": "b",
          "text": "w zmiennej tego typu możemy zapisać między innymi dowolną liczbę, którą można zapisać w typie char.",
          "correct": false
        },
        {
          "key": "c",
          "text": "ma mniejszy zakres niż typ float.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie może przechowywać wartości ujemnych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Typowo zajmuje 8 bajtów w pamięci.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest typem całkowitym o dużej precyzji.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1208,
      "question": "Przyjmijmy, że zmienne wskaźnikowe t oraz s są typu char, dodatkowo s wskazuje na niepusty łańcuch tekstowy, a t na adres pamięci rozpoczynający obszar przydzielony naszemu procesowi. Po wykonaniu fragmentu kodu napisanego w języku C: while(*t++=*s++);",
      "options": [
        {
          "key": "a",
          "text": "Kopiuje łańcuch znaków z s do t, włącznie ze znakiem końcowym '\\0'.",
          "correct": true
        },
        {
          "key": "b",
          "text": "wskaźniki s oraz t zwiększą swoją wartość o tyle bajtów ile znaków znajduje się w łańcuchu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "pętla będzie trwać w nieskończoność.",
          "correct": false
        },
        {
          "key": "d",
          "text": "kopiuje tylko pierwszy znak.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest to idiomatyczny sposób kopiowania stringów w C.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Wymaga, aby t było większe od s.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1209,
      "question": "Po wykonaniu fragmentu kodu oznaczającego deklarację w języku C: int tab[10], *ws=tab;",
      "options": [
        {
          "key": "a",
          "text": "ws wskazuje na pierwszy element tablicy (tab[0]).",
          "correct": true
        },
        {
          "key": "b",
          "text": "nazwa tablicy tab jest wskaźnikiem na pierwszy element tablicy.",
          "correct": false
        },
        {
          "key": "c",
          "text": "ws przechowuje kopię całej tablicy.",
          "correct": false
        },
        {
          "key": "d",
          "text": "tab i ws to dwa różne typy, których nie można przypisać.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wyrażenie *(ws + 1) jest równoważne tab[1].",
          "correct": true
        },
        {
          "key": "f",
          "text": "Rozmiar tablicy tab można zmienić za pomocą realloc.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1210,
      "question": "Fragmentu kodu w języku C: double (*fun1)(double, double);",
      "options": [
        {
          "key": "a",
          "text": "fun1 jest wskaźnikiem do funkcji przyjmującej dwa parametry typu double i zwracającej double.",
          "correct": true
        },
        {
          "key": "b",
          "text": "ogólnie nazwa funkcji jest jednocześnie wskaźnikiem do funkcji.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest to wywołanie funkcji o nazwie fun1.",
          "correct": false
        },
        {
          "key": "d",
          "text": "deklaruje tablicę wskaźników.",
          "correct": false
        },
        {
          "key": "e",
          "text": "fun1 jest funkcją zwracającą wskaźnik do double.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Deklaracja ta jest błędna bez słowa kluczowego typedef.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 1211,
      "question": "Fragmentu kodu w języku C: int fib(int n){ if(n<3) return n; return fib(n-1) + fib(n-2); }",
      "options": [
        {
          "key": "a",
          "text": "Jest nieefektywna (złożoność wykładnicza) i przy każdym wywołaniu tworzy nową ramkę stosu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "przy każdym rekurencyjnym wywołaniu funkcji tworzona jest kopia argumentu n.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zawsze zwraca wynik w czasie O(n).",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie może być zaimplementowana w C.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Może prowadzić do przepełnienia stosu (stack overflow) dla dużych n.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest przykładem programowania dynamicznego.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1212,
      "question": "Algorytm minimax:",
      "options": [
        {
          "key": "a",
          "text": "Służy do wyboru optymalnego ruchu w grach dwuosobowych o sumie zerowej.",
          "correct": true
        },
        {
          "key": "b",
          "text": "nawet w tak prostej grze jak kółko i krzyżyk nie da się przejrzeć całego drzewa ruchów.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest algorytmem losowym.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie wymaga funkcji oceny stanu gry.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Może być zoptymalizowany za pomocą odcięć alfa-beta (alpha-beta pruning).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest stosowany wyłącznie w grach karcianych.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1213,
      "question": "Wyszukiwanie w posortowanej tablicy n elementów:",
      "options": [
        {
          "key": "a",
          "text": "Można zastosować wyszukiwanie binarne o złożoności O(log n).",
          "correct": true
        },
        {
          "key": "b",
          "text": "w celu wyszukania elementu o zadanej wartości musimy wykonać dokładnie n kroków.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zawsze wymaga O(n^2) operacji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie jest możliwe bez dodatkowego indeksu.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wyszukiwanie liniowe jest zawsze szybsze dla n < 1000.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wymaga, aby tablica była posortowana malejąco.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 1214,
      "question": "Wyszukiwanie w posortowanej liście jednokierunkowej n elementów:",
      "options": [
        {
          "key": "a",
          "text": "Wymaga przejścia sekwencyjnego, co daje złożoność pesymistyczną O(n).",
          "correct": true
        },
        {
          "key": "b",
          "text": "wyszukanie elementu o zadanej wartości ma logarytmiczną złożoność czasową.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest szybsze niż w tablicy.",
          "correct": false
        },
        {
          "key": "d",
          "text": "pozwala na dostęp swobodny do elementów.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Można zastosować wyszukiwanie binarne w czasie O(log n).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wymaga stałej ilości pamięci dodatkowej.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 1215,
      "question": "Gdy mamy strukturę dynamiczną danych typu lista jednokierunkowa, to:",
      "options": [
        {
          "key": "a",
          "text": "Pozwala na wstawienie elementu w dowolnym miejscu, jeśli mamy wskaźnik do elementu poprzedzającego.",
          "correct": true
        },
        {
          "key": "b",
          "text": "nie można wstawić nowego elementu w dowolnym miejscu w liście.",
          "correct": false
        },
        {
          "key": "c",
          "text": "nie posiada wskaźnika na następny element.",
          "correct": false
        },
        {
          "key": "d",
          "text": "jest strukturą o stałym rozmiarze.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Każdy węzeł przechowuje dane oraz wskaźnik na kolejny element.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Pozwala na szybkie (O(1)) pobranie poprzedniego elementu.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1216,
      "question": "Struktura typu drzewo:",
      "options": [
        {
          "key": "a",
          "text": "Aby odwiedzić wszystkie n węzłów, należy zastosować algorytm przejścia o złożoności O(n).",
          "correct": true
        },
        {
          "key": "b",
          "text": "w celu wypisania wszystkich elementów drzewa musimy przejść przez wszystkie elementy drzewa.",
          "correct": false
        },
        {
          "key": "c",
          "text": "każdy węzeł może mieć tylko jednego potomka.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie może być pusta.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Drzewo binarne to drzewo, w którym każdy węzeł ma co najwyżej dwóch potomków.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Drzewo jest grafem spójnym zawierającym cykle.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1217,
      "question": "Gdy mamy strukturę dynamiczną typu drzewo wyszukiwań binarnych (BST), gdzie jest to drzewo spełniające własność, że dla każdego węzła zawierającego wartość x mającego lewego potomka zawierającego wartość l oraz prawego zawierającego wartość p, zachodzi: l<=x oraz x<=p, to:",
      "options": [
        {
          "key": "a",
          "text": "Średnia złożoność wyszukiwania wynosi O(log n), ale pesymistyczna to O(n).",
          "correct": true
        },
        {
          "key": "b",
          "text": "w dowolnym drzewie tego typu znalezienie węzła ma logarytmiczną złożoność czasową.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zawsze jest zrównoważone.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie pozwala na przechowywanie duplikatów.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Dla każdego węzła, wartości w lewym poddrzewie są mniejsze, a w prawym większe od wartości węzła.",
          "correct": true
        },
        {
          "key": "f",
          "text": "BST jest zawsze drzewem pełnym.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 2,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1218,
      "question": "Przeanalizuj fragmenty kodu w języku C++, w którym pojawiają się zmienne, wskaźniki i referencje. Które z nich mają poprawną składnię?",
      "options": [
        {
          "key": "a",
          "text": "int x; int &r = x; (referencja musi być zainicjalizowana i nie może być null).",
          "correct": true
        },
        {
          "key": "b",
          "text": "int x; int&r=null; r=x;",
          "correct": false
        },
        {
          "key": "c",
          "text": "int &r; r = 10;",
          "correct": false
        },
        {
          "key": "d",
          "text": "int &r = null;",
          "correct": false
        },
        {
          "key": "e",
          "text": "Referencja może zostać przełączona na inny obiekt w trakcie działania programu.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Referencja zajmuje tyle samo pamięci co wskaźnik.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 1219,
      "question": "Które stwierdzenia odnoszące się ograniczeń narzucanych przez składnię języka C++ w odniesieniu do konstruktorów i destruktorów są prawdziwe?",
      "options": [
        {
          "key": "a",
          "text": "Klasa może mieć wiele konstruktorów, ale tylko jeden destruktor.",
          "correct": true
        },
        {
          "key": "b",
          "text": "W klasie można zdefiniować dowolną liczbę konstruktorów i co najwyżej jeden destruktor.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Destruktor może zwracać wartość int.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Konstruktor musi być zawsze publiczny.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Destruktor jest wywoływany automatycznie, gdy obiekt wychodzi poza zakres.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Konstruktor kopiujący nie może być prywatny.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1220,
      "question": "Które stwierdzenia odnoszące się do metod klas w języku C++ są prawdziwe?",
      "options": [
        {
          "key": "a",
          "text": "Metody statyczne nie posiadają wskaźnika this.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wskaźnik this nie jest dostępny w metodach statycznych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Metody wirtualne nie mogą być prywatne.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Każda metoda musi być wirtualna.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Metody stałe (const) nie mogą modyfikować pól klasy (poza polami mutable).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Metody statyczne mogą wywoływać metody niestatyczne bez obiektu.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1221,
      "question": "Zadeklarowano dwie klasy języka C++ class A{ int value; public: A(int _v):value(_v){} int getValue(){return value;} const char*getName(){return \"AAA\";} }; oraz class B:public A { public: // konstruktor const char*getName(){return \"B\";} }; Utworzono obiekt klasy B za pomocą następującej instrukcji: A*pa=new B(); Która implementacja konstruktora klasy B jest poprawna?",
      "options": [
        {
          "key": "a",
          "text": "Konstruktor klasy pochodnej musi wywołać konstruktor klasy bazowej w liście inicjalizacyjnej.",
          "correct": true
        },
        {
          "key": "b",
          "text": "B::B(){super(0);}",
          "correct": false
        },
        {
          "key": "c",
          "text": "B::B(){A(0);}",
          "correct": false
        },
        {
          "key": "d",
          "text": "B::B(){this->A(0);}",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jeśli klasa bazowa nie ma konstruktora domyślnego, jawne wywołanie jest wymagane.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Klasa B automatycznie dziedziczy wszystkie pola prywatne klasy A jako publiczne.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1222,
      "question": "Zadeklarowano cztery klasy języka C++ class A{ public: A(){std::cout<<\"A\";} }; class B{ public: B(){std::cout<<\"B\";} }; class C{ A a; public: C(){std::cout<<\"C\";} }; class D : public C{ public: B b; D(){std::cout<<\"D\";} }; Jaka jest kolejność wywołania konstruktorów przy tworzeniu obiektu klasy D?",
      "options": [
        {
          "key": "a",
          "text": "Najpierw baza (C), potem pola (B), potem ciało konstruktora (D). Wewnątrz C: pole (A), potem ciało (C). Zatem: A, C, B, D.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Konstruktor B zostanie wywołany przed konstruktorem klasy C.",
          "correct": false
        },
        {
          "key": "c",
          "text": "B, A, C, D.",
          "correct": false
        },
        {
          "key": "d",
          "text": "D, B, C, A.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Kolejność zależy od kolejności deklaracji w pliku nagłówkowym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wszystkie konstruktory are wywoływane równolegle.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": false
    },
    {
      "id": 1223,
      "question": "Zadeklarowano trzy klasy języka C++. class A { public: virtual ~A(){f();} virtual void f(){std::cout<<\"A\";} }; class B:public A { public: ~B(){f();} }; class C:public B { public: ~C(){f();} void f(){std::cout<<\"C\";} }; Zaimplementowano następującą funkcję main() int main(){ A* ptr = new C(); delete ptr; return 0; } Przy usuwaniu obiektu wołany jest jego destruktor. Które stwierdzenia dotyczące uruchamianych destruktorów są prawdziwe?",
      "options": [
        {
          "key": "a",
          "text": "Jeśli klasa bazowa ma wirtualny destruktor, destruktory wywołają się od najbardziej pochodnej do bazy.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wpierw zostanie uruchomiony destruktor A, potem B, potem C.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wywoła się tylko destruktor klasy A.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Destruktory wywołują się w kolejności alfabetycznej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Brak wirtualnego destruktora w klasie bazowej przy usuwaniu przez wskaźnik na bazę prowadzi do UB.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Destruktor wirtualny jest wymagany tylko w klasach abstrakcyjnych.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1224,
      "question": "Które stwierdzenia odnoszące się do przeciążania operatorów w języku C++ są prawdziwe:",
      "options": [
        {
          "key": "a",
          "text": "Niektóre operatory (np. <<, >>) są zazwyczaj przeciążane jako funkcje zaprzyjaźnione (friend).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wszystkie operatory muszą być zaimplementowane jako metody klasy.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Nie można przeciążać operatora +.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Operatory logiczne nie podlegają przeciążaniu.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Operatory takie jak =, [], (), -> muszą być zaimplementowane jako metody klasy.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Można tworzyć nowe operatory, np. **.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1225,
      "question": "Wybierz poprawne stwierdzenia odnoszące się do obiektów funkcyjnych w języku C++",
      "options": [
        {
          "key": "a",
          "text": "To obiekty klas, które mają przeciążony operator nawiasów operator().",
          "correct": true
        },
        {
          "key": "b",
          "text": "Obiekty funkcyjne to obiekty klasy, która implementuje operator wywołania funkcji.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Są to wskaźniki do funkcji statycznych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Można je tworzyć tylko za pomocą słowa kluczowego function.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Funktory mogą przechowywać stan między wywołaniami.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Są wolniejsze od zwykłych wskaźników do funkcji.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1226,
      "question": "Które stwierdzenia odnoszące się do mechanizmu wyjątków w języku C++ są prawdziwe?",
      "options": [
        {
          "key": "a",
          "text": "Podczas \"odwijania stosu\" niszczone są obiekty lokalne poprzez wywołanie ich destruktorów.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Podczas obsługi wyjątków zwalniana jest pamięć stosu oraz wołane są destruktory obiektów.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wyjątki nie mogą być rzucane w konstruktorach.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Każdy wyjątek musi dziedziczyć po klasie std::exception.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Rzucenie wyjątku w destruktorze podczas odwijania stosu powoduje wywołanie std::terminate.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Blok catch(...) łapie tylko wyjątki typu int.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1227,
      "question": "Wybierz poprawne stwierdzenia odnoszące się do kontenerów języka C++",
      "options": [
        {
          "key": "a",
          "text": "std::list to lista dwukierunkowa, zapewnia stały czas O(1) wstawiania na obu końcach.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Szablon std::list umożliwia dodawanie elementów na początku i końcu listy.",
          "correct": false
        },
        {
          "key": "c",
          "text": "std::vector zapewnia stały czas wstawiania w dowolnym miejscu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "std::map przechowuje elementy w sposób nieposortowany.",
          "correct": false
        },
        {
          "key": "e",
          "text": "std::vector zapewnia stały czas dostępu O(1) do dowolnego elementu.",
          "correct": true
        },
        {
          "key": "f",
          "text": "std::deque nie pozwala na wstawianie na początku.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1228,
      "question": "Załóżmy, że A jest klasą języka C++. Jakie warunki muszą być spełnione, aby móc przechowywać obiekty tej klasy w kontenerze std::set lub używać ich jako klucze w std::map?",
      "options": [
        {
          "key": "a",
          "text": "Wymagają, aby klucze posiadały zdefiniowaną relację ścisłego słabego porządku.",
          "correct": true
        },
        {
          "key": "b",
          "text": "muszą być zdefiniowane operatory boolowskie < , == oraz >.",
          "correct": false
        },
        {
          "key": "c",
          "text": "klucze muszą być typu całkowitego.",
          "correct": false
        },
        {
          "key": "d",
          "text": "obiekty muszą dziedziczyć po klasie Comparable.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Są zazwyczaj implementowane jako drzewa czerwono-czarne.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Zapewniają średni czas wyszukiwania O(1).",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1229,
      "question": "Które stwierdzenia odnoszące się do iteratorów w C++ są prawdziwe",
      "options": [
        {
          "key": "a",
          "text": "std::vector i std::deque posiadają iteratory swobodnego dostępu, a std::list tylko dwukierunkowe.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Iterator kontenera std::list umożliwia dostęp swobodny.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Iteratory nie mogą być porównywane.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Każdy iterator można przesunąć o n pozycji w czasie O(1).",
          "correct": false
        },
        {
          "key": "e",
          "text": "Iteratory kontenerów asocjacyjnych (np. std::set) nie są iteratorami swobodnego dostępu.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Iterator end() wskazuje na ostatni element kontenera.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1230,
      "question": "Które stwierdzenia odnoszące się do wyrażeń lambda w języku C++ są prawdziwe",
      "options": [
        {
          "key": "a",
          "text": "Każde wyrażenie lambda ma unikalny, nienazwany typ generowany przez kompilator.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wynikiem kompilacji identycznych wyrażeń lambda jest jeden współdzielony obiekt funkcyjny.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Lambdy nie mogą przechwytywać zmiennych przez referencję.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Lambdy są dostępne od standardu C++98.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Składnia [=] oznacza przechwycenie wszystkich zmiennych lokalnych przez kopię.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Lambdy nie mogą być używane jako argumenty funkcji STL.",
          "correct": false
        }
      ],
      "topic": "c_cpp",
      "semester": 3,
      "courseName": "Programowanie zaawansowane (C/C++)",
      "multipleCorrect": true
    },
    {
      "id": 1231,
      "question": "Znaczniki semantyczne w HTML5:",
      "options": [
        {
          "key": "a",
          "text": "<article>, <section>, <nav>, <header>, <footer>.",
          "correct": true
        },
        {
          "key": "b",
          "text": "div",
          "correct": false
        },
        {
          "key": "c",
          "text": "span",
          "correct": false
        },
        {
          "key": "d",
          "text": "table",
          "correct": false
        },
        {
          "key": "e",
          "text": "<main>, <aside>, <figure>.",
          "correct": false
        },
        {
          "key": "f",
          "text": "<font>, <center>, <bold>.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": false
    },
    {
      "id": 1232,
      "question": "Jakich znaczników HTML5 użyjesz do wyświetlenia zawartości pliku video?",
      "options": [
        {
          "key": "a",
          "text": "<video>",
          "correct": true
        },
        {
          "key": "b",
          "text": "file",
          "correct": false
        },
        {
          "key": "c",
          "text": "media",
          "correct": false
        },
        {
          "key": "d",
          "text": "object",
          "correct": false
        },
        {
          "key": "e",
          "text": "<embed>",
          "correct": false
        },
        {
          "key": "f",
          "text": "<source> (używany wewnątrz <video>).",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": false
    },
    {
      "id": 1233,
      "question": "Który element może być użyty w HTML5 do specyfikacji linku nawigacyjnego?",
      "options": [
        {
          "key": "a",
          "text": "<nav> (kontener dla linków) oraz <a> (sam link).",
          "correct": true
        },
        {
          "key": "b",
          "text": "navigation",
          "correct": false
        },
        {
          "key": "c",
          "text": "link",
          "correct": false
        },
        {
          "key": "d",
          "text": "anchor",
          "correct": false
        },
        {
          "key": "e",
          "text": "<menu>",
          "correct": false
        },
        {
          "key": "f",
          "text": "<href>",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": false
    },
    {
      "id": 1234,
      "question": "Atrybut for w znaczniku <label>:",
      "options": [
        {
          "key": "a",
          "text": "Służy do powiązania etykiety z konkretnym elementem formularza (poprzez jego id).",
          "correct": true
        },
        {
          "key": "b",
          "text": "aby etykieta była aktywna.",
          "correct": false
        },
        {
          "key": "c",
          "text": "określa czas wyświetlania etykiety.",
          "correct": false
        },
        {
          "key": "d",
          "text": "służy do stylowania w CSS.",
          "correct": false
        },
        {
          "key": "e",
          "text": "pozwala na kliknięcie w etykietę w celu aktywacji pola.",
          "correct": false
        },
        {
          "key": "f",
          "text": "jest wymagany dla każdego znacznika <p>.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": false
    },
    {
      "id": 1235,
      "question": "Aplikacje Single Page Application (SPA):",
      "options": [
        {
          "key": "a",
          "text": "Cała logika i renderowanie widoków odbywa się głównie po stronie klienta.",
          "correct": true
        },
        {
          "key": "b",
          "text": "zarządzanie stanem aplikacji realizowane jest po stronie frontendu.",
          "correct": false
        },
        {
          "key": "c",
          "text": "wymagają przeładowania całej strony przy każdej nawigacji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie mogą korzystać z API.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Przykładowe frameworki to React, Angular, Vue.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Są zawsze indeksowane przez wyszukiwarki lepiej niż strony statyczne.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1236,
      "question": "Jakich operacji HTTP możesz użyć do aktualizacji części danych istniejącego już użytkownika?",
      "options": [
        {
          "key": "a",
          "text": "PATCH (częściowa aktualizacja), PUT (pełna zamiana).",
          "correct": true
        },
        {
          "key": "b",
          "text": "PATCH",
          "correct": false
        },
        {
          "key": "c",
          "text": "POST",
          "correct": false
        },
        {
          "key": "d",
          "text": "UPDATE",
          "correct": false
        },
        {
          "key": "e",
          "text": "DELETE",
          "correct": false
        },
        {
          "key": "f",
          "text": "OPTIONS",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": false
    },
    {
      "id": 1237,
      "question": "Który z poniższych adresów API ( według konwencji REST API) powinien być użyty do zwrócenia informacji o wszystkich samochodach użytkownika posiadającego id równe 4?",
      "options": [
        {
          "key": "a",
          "text": "/users/4/cars",
          "correct": true
        },
        {
          "key": "b",
          "text": "/users?id=4/cars/all",
          "correct": false
        },
        {
          "key": "c",
          "text": "/get_all_cars_for_user_4",
          "correct": false
        },
        {
          "key": "d",
          "text": "/cars/user/4",
          "correct": false
        },
        {
          "key": "e",
          "text": "/users/4/actions/get-cars",
          "correct": false
        },
        {
          "key": "f",
          "text": "/api/v1/users/4/cars",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": false
    },
    {
      "id": 1238,
      "question": "Poprawny format JSON:",
      "options": [
        {
          "key": "a",
          "text": "{ \"user\": \"Jan Kowalski\", \"age\": 100 }",
          "correct": true
        },
        {
          "key": "b",
          "text": "{ \"user\" : Jan Kowalski, \"age\": 100 }",
          "correct": false
        },
        {
          "key": "c",
          "text": "{ user: \"Jan Kowalski\", age: 100 }",
          "correct": false
        },
        {
          "key": "d",
          "text": "[ \"user\": \"Jan Kowalski\" ]",
          "correct": false
        },
        {
          "key": "e",
          "text": "{ 'user': 'Jan Kowalski' }",
          "correct": false
        },
        {
          "key": "f",
          "text": "{ \"user\": \"Jan\", \"data\": [1, 2, 3] }",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": false
    },
    {
      "id": 1239,
      "question": "Responsywność (Responsive Web Design):",
      "options": [
        {
          "key": "a",
          "text": "Technika projektowania stron tak, aby ich wygląd dostosowywał się do rozmiaru ekranu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "zapewnia dostosowanie wyglądu aplikacji w kontekście potrzeb użytkownika.",
          "correct": false
        },
        {
          "key": "c",
          "text": "oznacza szybkie reagowanie serwera na zapytania.",
          "correct": false
        },
        {
          "key": "d",
          "text": "dotyczy tylko aplikacji mobilnych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wykorzystuje elastyczne siatki (grid), elastyczne obrazy oraz Media Queries.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Wymaga tworzenia oddzielnej strony pod adresem m.domena.pl.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1240,
      "question": "Nowoczesne frameworki JavaScript (JavaScript frameworks) takie jak Angular, React czy Vue",
      "options": [
        {
          "key": "a",
          "text": "Wykorzystują komponentowe podejście do budowy interfejsu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "wykorzystują wiązania dwukierunkowe do synchronizacji.",
          "correct": false
        },
        {
          "key": "c",
          "text": "służą wyłącznie do stylowania stron.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie pozwalają na używanie zewnętrznych bibliotek.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwalają na deklaratywne definiowanie interfejsu użytkownika.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Wymaga znajomości języka Java.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1241,
      "question": "Node.js:",
      "options": [
        {
          "key": "a",
          "text": "Jest środowiskiem uruchomieniowym JavaScript opartym na silniku V8.",
          "correct": true
        },
        {
          "key": "b",
          "text": "implementuje tylko operacje asynchroniczne.",
          "correct": false
        },
        {
          "key": "c",
          "text": "jest frameworkiem CSS.",
          "correct": false
        },
        {
          "key": "d",
          "text": "służy do tworzenia wyłącznie aplikacji desktopowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wykorzystuje model Event Loop do obsługi wielu połączeń jednocześnie.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest językiem programowania kompilowanym do kodu maszynowego.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1242,
      "question": "Zapisano następujący kod źródłowy w języku Java: Class C { public static void main(String[] args) { int[]a1[]=new int[3][3]; //3 int a2[4]={3,4,5,6}; //4 int a2[5]; //5 }} Jaki jest wynik kompilacji i wykonania programu (w komentarzach podane są numery linii)?",
      "options": [
        {
          "key": "a",
          "text": "int[] a = new int[5]; (poprawna deklaracja).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Błąd kompilacji w liniach 3,4,5.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wszystkie linie są poprawne.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Tablice w Javie mają dynamiczny rozmiar.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Rozmiar tablicy jest ustalany w momencie tworzenia (new) i nie może być zmieniony.",
          "correct": true
        },
        {
          "key": "f",
          "text": "tablica.length() zwraca liczbę elementów.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": true
    },
    {
      "id": 1243,
      "question": "Zapisano następujący kod źródłowy w języku Java: public class A extends Thread { public int i; public void run() { i = 1; } public static void main(String[] args) throws Exception { A a = new A();",
      "options": [
        {
          "key": "a",
          "text": "Aby uruchomić wątek, należy wywołać metodę start(), która wywoła run().",
          "correct": true
        },
        {
          "key": "b",
          "text": "start(); System.out.print(a.i); Thread.sleep(1000); System.out.print(a.i);",
          "correct": false
        },
        {
          "key": "c",
          "text": "Nie wypisze nic.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wypisze \"11\".",
          "correct": false
        },
        {
          "key": "e",
          "text": "Można implementować interfejs Runnable lub dziedziczyć po klasie Thread.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Metoda run() uruchamia nowy wątek w systemie operacyjnym.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": true
    },
    {
      "id": 1244,
      "question": "Zapisano następujący kod źródłowy w języku Java: class C{ public static void main(String[] args) { try { try { try {} catch(RuntimeException e){} } catch(Exception e) {} } catch(NullPointerException e) {} finally { System.out.println(\"finally\"); } }} Jaki jest rezultat kompilacji i wykonania programu?",
      "options": [
        {
          "key": "a",
          "text": "Blok finally wykonuje się zawsze, niezależnie od tego, czy wystąpił wyjątek.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Runtime Exception",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wypisze \"finally\".",
          "correct": false
        },
        {
          "key": "d",
          "text": "Błąd kompilacji.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Blok finally jest często używany do zwalniania zasobów.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Blok catch musi zawsze występować po bloku finally.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": true
    },
    {
      "id": 1245,
      "question": "Zapisano następujący kod źródłowy w języku Java: public class C { public static void main ( String a[]) { Thread t = Thread.currentThread ( ) ; t.setPriority(-1); System.out.println(\"Done!\"); } } Jaki będzie rezultat kompilacji i wykonania programu?",
      "options": [
        {
          "key": "a",
          "text": "Priorytet musi mieścić się w zakresie od Thread.MIN_PRIORITY (1) do Thread.MAX_PRIORITY (10).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Runtime Exception",
          "correct": false
        },
        {
          "key": "c",
          "text": "Done!",
          "correct": false
        },
        {
          "key": "d",
          "text": "Błąd kompilacji.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wartość priorytetu 0 jest dozwolona.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wyższy priorytet gwarantuje, że wątek zakończy się szybciej.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 1246,
      "question": "Zapisano następujący kod źródłowy w języku Java: interface I{ void f1(); // 1 public void f2(); // 2 protected void f3(); // 3 private void f4(); // 4 } Które linie generują błędy kompilacji? (w komentarzach podany numery linii)",
      "options": [
        {
          "key": "a",
          "text": "W klasycznych interfejsach metody są domyślnie public abstract.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Błąd kompilacji w liniach 1,2,3,4.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Tylko linia 3 i 4 generują błędy.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Interfejsy nie mogą mieć metod.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Od Javy 8 interfejsy mogą posiadać metody domyślne (default) i statyczne.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Metody w interfejsach mogą być final.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": true
    },
    {
      "id": 1247,
      "question": "Zapisano następujący kod źródłowy w języku Java: class C { static int s; public static void main(String a[]){ C obj=new C(); obj.m1(); System.out.println(s); } void m1() { int x=1; m2(x); System.out.println(x+\"\"); } void m2(int x){ x=x*2; s=x; } } Jaki jest rezultat kompilacji i wykonania programu?",
      "options": [
        {
          "key": "a",
          "text": "Java zawsze przekazuje argumenty przez wartość.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wypisze: \"2,0\"",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wypisze: \"1 2\".",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wypisze: \"2 2\".",
          "correct": false
        },
        {
          "key": "e",
          "text": "Dla obiektów przekazywana jest wartość referencji (kopia wskaźnika).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Słowo kluczowe 'ref' pozwala na przekazywanie przez referencję.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": true
    },
    {
      "id": 1248,
      "question": "Zapisano następujący kod źródłowy w języku Java: class C { public static void main(String[] args) { int i1=1; switch(i1){ case 1: System.out.println(\"one \"); case 2: System.out.println(\"two \"); case 3: System.out.println(\"three \"); }}} Jaki jest rezultat kompilacji i wykonania programu?",
      "options": [
        {
          "key": "a",
          "text": "Po dopasowaniu case, wykonają się wszystkie kolejne instrukcje (fall-through).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wypisze: \"one \"",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wypisze: \"one two three \"",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wypisze: \"one \" i zakończy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Switch obsługuje tylko typy całkowite (int, long).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Od Javy 7 switch obsługuje typ String.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 1249,
      "question": "Zapisano następujący kod źródłowy w języku Java: class C1 { static interface I { static class C2 {} } public static void main(String a[]) { C1.I.C2 ob1=new C1.I.C2(); System.out.println(\"obj created\"); } } Jaki jest rezultat kompilacji i wykonania programu?",
      "options": [
        {
          "key": "a",
          "text": "Interfejsy mogą zawierać klasy statyczne.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Błąd kompilacji",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wypisze: \"obj created\"",
          "correct": false
        },
        {
          "key": "d",
          "text": "Interfejsy nie mogą mieć metod main.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Klasy wewnętrzne nie mogą być statyczne.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Klasa wewnętrzna ma dostęp do prywatnych pól klasy zewnętrznej.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 1250,
      "question": "Zapisano następujący kod źródłowy w języku Java: class C1 { static class C2 { static int i1; } public static void main(String a[]) { System.out.println(C1.C2.i1); } } Jaki jest rezultat kompilacji i wykonania programu?",
      "options": [
        {
          "key": "a",
          "text": "Pola statyczne są inicjalizowane wartościami domyślnymi (0 dla int).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wypisze: \"0\"",
          "correct": false
        },
        {
          "key": "c",
          "text": "Błąd kompilacji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Runtime Exception.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Klasa statyczna wymaga obiektu klasy zewnętrznej do utworzenia instancji.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Klasa statyczna wewnętrzna może dziedziczyć po klasie zewnętrznej.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 1251,
      "question": "Ile obiektów (instancji klasy StringBuffer) zostanie utworzonych w wyniku wykonania poniższego kodu w języku Java: StringBuffer s1 = new StringBuffer(\"abc\"); StringBuffer s2 = s1; StringBuffer s3 = new StringBuffer(\"abc\");",
      "options": [
        {
          "key": "a",
          "text": "2 (s1 tworzy nowy obiekt, s3 tworzy drugi nowy obiekt).",
          "correct": true
        },
        {
          "key": "b",
          "text": "1",
          "correct": false
        },
        {
          "key": "c",
          "text": "3",
          "correct": false
        },
        {
          "key": "d",
          "text": "0",
          "correct": false
        },
        {
          "key": "e",
          "text": "4",
          "correct": false
        },
        {
          "key": "f",
          "text": "StringBuffer nie jest klasą w Javie.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 1252,
      "question": "Która z poniższych metod jest statyczną metodą w klasie Thread dostępnej w standardowym API dla języka Java?",
      "options": [
        {
          "key": "a",
          "text": "sleep, yield, currentThread, interrupted.",
          "correct": true
        },
        {
          "key": "b",
          "text": "join",
          "correct": false
        },
        {
          "key": "c",
          "text": "start",
          "correct": false
        },
        {
          "key": "d",
          "text": "run",
          "correct": false
        },
        {
          "key": "e",
          "text": "wait",
          "correct": false
        },
        {
          "key": "f",
          "text": "notify",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 1253,
      "question": "Zapisano poniższy kod źródłowy w języku Java: class c1 { public void m1() { System.out.println(\"m1 w klasie C1\"); } } class c2 { public c1 m1() { return new c1(){ public void m1() { System.out.println(\"m1 w klasie anonimowej\"); } } } public static void main(String a[]) { c1 ob1 =new c2().m1(); ob1.m1(); }} Jaki będzie wynik kompilacji i wykonania tego kodu jako programu?",
      "options": [
        {
          "key": "a",
          "text": "Klasa anonimowa nadpisuje metodę, więc zostanie wywołana wersja z klasy anonimowej.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Program wypisze łańcuch: \"m1 w klasie anonimowej\"",
          "correct": false
        },
        {
          "key": "c",
          "text": "Program wypisze: \"m1 w klasie C1\"",
          "correct": false
        },
        {
          "key": "d",
          "text": "Błąd kompilacji.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Klasy anonimowe nie mogą implementować interfejsów.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Klasa anonimowa może mieć własny konstruktor.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 1254,
      "question": "Zapisano poniższy kod źródłowy w języku Java:class C{ int i; public static void main (String[] args) { int i; //1 private int a = 1; //2 protected int b = 1; //3 public int c = 1; //4 System.out.println(a+b+c); //5 }} Jaki jest wynik próby kompilacji i wykonania powyższego programu (w komentarzach zaznaczony numery lini)?",
      "options": [
        {
          "key": "a",
          "text": "Zmienne lokalne nie mogą mieć modyfikatorów public, private, protected.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wykonanie kodu spowoduje wyprowadzenie wyniku: \"3\"",
          "correct": false
        },
        {
          "key": "c",
          "text": "Błąd kompilacji w liniach 2, 3, 4.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wypisze \"1\".",
          "correct": false
        },
        {
          "key": "e",
          "text": "Zmienne lokalne mogą być oznaczone jako final.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Zmienne lokalne są widoczne w całej klasie.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 1255,
      "question": "Zapisano poniższy kod źródłowy w języku Java: public class Command { public static void main (String[] a1) { System.out.print(a1[1] + a1[2] + a1[3]); }} Jaki jest wynik próby kompilacji i wykonania powyższego programu przy pomocy poniższego polecenia? polecenie: java Command A B C",
      "options": [
        {
          "key": "a",
          "text": "Indeksowanie zaczyna się od 0.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Runtime Exception",
          "correct": false
        },
        {
          "key": "c",
          "text": "ABC",
          "correct": false
        },
        {
          "key": "d",
          "text": "Błąd kompilacji.",
          "correct": false
        },
        {
          "key": "e",
          "text": "args[0] zawsze przechowuje nazwę uruchomionego programu.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Tablica args może być pusta (length == 0).",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 1256,
      "question": "Zapisano poniższy kod źródłowy w języku Java: class C{ static String m(int i) {return \"int\";} static String m(float i) {return \"float\";} public static void main (String[] args) { long a1 = 1; double b1 = 2; System.out.print(m(a1)+\",\"+ m(b1)); }} Jaki będzie rezultat kompilacji i wykonania programu?",
      "options": [
        {
          "key": "a",
          "text": "long może być niejawnie konwertowany na float, ale double nie pasuje do float bez rzutowania.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Kompilacja tego kodu zakończy się błędem.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wypisze: \"int,float\".",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wypisze: \"float,float\".",
          "correct": false
        },
        {
          "key": "e",
          "text": "Java nie obsługuje przeciążania metod.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Typ byte jest automatycznie promowany do char.",
          "correct": false
        }
      ],
      "topic": "java",
      "semester": 4,
      "courseName": "Programowanie zaawansowane (Java)",
      "multipleCorrect": false
    },
    {
      "id": 1257,
      "question": "Wzorzec architektury Model-View-Controller (MVC) w technologii ASP .NET Core MVC obejmuje:",
      "options": [
        {
          "key": "a",
          "text": "Modele (dane), Widoki (interfejs), Kontrolery (logika).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Warstwę modeli - warstwa definiująca strukturę danych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Kontrolery służą do stylowania stron.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Widoki odpowiadają za dostęp do bazy danych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Kontroler wybiera odpowiedni widok i przekazuje mu dane z modelu.",
          "correct": true
        },
        {
          "key": "f",
          "text": "MVC jest wzorcem wyłącznie dla aplikacji desktopowych.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1258,
      "question": "Aby przechowywać stan aplikacji webowej (dane ulotne, których nie chcemy utrwalać w bazie danych) w ASP.NET CORE MVC można użyć:",
      "options": [
        {
          "key": "a",
          "text": "Session, Cookies, TempData, QueryString.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Stanu sesji (HttpContext.Session)",
          "correct": false
        },
        {
          "key": "c",
          "text": "Tylko w bazie danych SQL Server.",
          "correct": false
        },
        {
          "key": "d",
          "text": "W plikach tekstowych na serwerze.",
          "correct": false
        },
        {
          "key": "e",
          "text": "View State nie jest używany w ASP.NET Core.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Protokół HTTP jest stanowy z natury.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1259,
      "question": "Przekazywanie przez referencję w C#:",
      "options": [
        {
          "key": "a",
          "text": "Słowa kluczowe ref oraz out pozwalają na przekazywanie typów wartościowych przez referencję.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Przekazać do metody zmienną przez referencję przy pomocy słowa kluczowego ref.",
          "correct": false
        },
        {
          "key": "c",
          "text": "C# nie obsługuje referencji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wszystkie obiekty są zawsze przekazywane przez kopię.",
          "correct": false
        },
        {
          "key": "e",
          "text": "'out' wymaga, aby zmienna została zainicjalizowana wewnątrz metody.",
          "correct": true
        },
        {
          "key": "f",
          "text": "'ref' nie wymaga inicjalizacji zmiennej przed przekazaniem.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1260,
      "question": "Czy w języku C# można tworzyć klasy zagnieżdżone (deklarować klasę wewnątrz deklaracji innej klasy)?",
      "options": [
        {
          "key": "a",
          "text": "Klasy zagnieżdżone mogą mieć dowolny modyfikator dostępu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Można deklarować, ale tylko klasy prywatne.",
          "correct": false
        },
        {
          "key": "c",
          "text": "C# nie pozwala na klasy zagnieżdżone.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Klasy zagnieżdżone muszą być statyczne.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Klasa zagnieżdżona ma dostęp do prywatnych pól klasy nadrzędnej.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Klasa nadrzędna ma dostęp do prywatnych pól klasy zagnieżdżonej.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": false
    },
    {
      "id": 1261,
      "question": "Które z poniższych konwersji typów (rzutowań typów) w języku C# są dozwolone?",
      "options": [
        {
          "key": "a",
          "text": "Każda klasa dziedziczy po System.Object, więc upcasting jest zawsze bezpieczny.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Rzutowanie referencji do obiektu dowolnej klasy na referencję do klasy \"Object\"",
          "correct": false
        },
        {
          "key": "c",
          "text": "Można rzutować string na int bezpośrednio.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Rzutowanie w dół (downcasting) nigdy nie wymaga operatora rzutowania.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Operator 'as' zwraca null, jeśli rzutowanie się nie powiedzie.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Operator 'is' służy do konwersji typów.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1262,
      "question": "LINQ (Language Integrated Query):",
      "options": [
        {
          "key": "a",
          "text": "Składnia zintegrowana z językiem pozwalająca na operacje na kolekcjach.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Language INtegrated Query - zestaw konstrukcji programistycznych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Biblioteka do obsługi grafiki 3D.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Protokół komunikacji sieciowej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwala na zapytania do różnych źródeł danych.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Wymaga użycia słowa kluczowego 'foreach' do każdego zapytania.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1263,
      "question": "Deklaracja Polecenia najwyższego poziomu (Top-level statements) w języku C# podlega pewnym zasadom. Wśród nich są:",
      "options": [
        {
          "key": "a",
          "text": "Pozwalają na pisanie kodu bezpośrednio w pliku bez jawnej definicji klasy i Main.",
          "correct": true
        },
        {
          "key": "b",
          "text": "dyrektywa \"using\" musi znajdいる na początku pliku.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Można mieć wiele plików z Top-level statements w jednym projekcie.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie można w nich definiować metod.",
          "correct": false
        },
        {
          "key": "e",
          "text": "W projekcie może istnieć tylko jeden plik z Top-level statements.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Są dostępne od wersji C# 1.0.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1264,
      "question": "Synchronizacja wątków w C#:",
      "options": [
        {
          "key": "a",
          "text": "lock, Monitor, Mutex, Semaphore, AutoResetEvent.",
          "correct": true
        },
        {
          "key": "b",
          "text": "semaforów (\"Semaphore\")",
          "correct": false
        },
        {
          "key": "c",
          "text": "tylko za pomocą instrukcji if.",
          "correct": false
        },
        {
          "key": "d",
          "text": "nie jest możliwa w .NET Core.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Instrukcja lock jest cukrem składniowym dla Monitor.Enter i Monitor.Exit.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Mutex działa tylko w obrębie jednego procesu.",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": true
    },
    {
      "id": 1265,
      "question": "Do definiowania wyrażeń lambda (lambda expression) w C# używa się operatora:",
      "options": [
        {
          "key": "a",
          "text": "=> (tzw. goes to).",
          "correct": true
        },
        {
          "key": "b",
          "text": "->",
          "correct": false
        },
        {
          "key": "c",
          "text": "::",
          "correct": false
        },
        {
          "key": "d",
          "text": "lambda",
          "correct": false
        },
        {
          "key": "e",
          "text": ":=",
          "correct": false
        },
        {
          "key": "f",
          "text": ".",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": false
    },
    {
      "id": 1266,
      "question": "Zarejestrowanie zdarzenia (metody, która będzie wywołana w celu obsługi zdarzenia) w języku C# odbywa się za pomocą operatora:",
      "options": [
        {
          "key": "a",
          "text": "Używa się operatora += do dodania delegata.",
          "correct": true
        },
        {
          "key": "b",
          "text": "+=",
          "correct": false
        },
        {
          "key": "c",
          "text": "=",
          "correct": false
        },
        {
          "key": "d",
          "text": "subscribe",
          "correct": false
        },
        {
          "key": "e",
          "text": "add",
          "correct": false
        },
        {
          "key": "f",
          "text": "register",
          "correct": false
        }
      ],
      "topic": "web_programming",
      "semester": 5,
      "courseName": "Programowanie aplikacji webowych",
      "multipleCorrect": false
    },
    {
      "id": 1267,
      "question": "Pula adresów IPv4 przewidziana dla grup IP Multicast (Klasa D adresów IPv4), to:",
      "options": [
        {
          "key": "a",
          "text": "Zakres od 224.0.0.0 do 239.255.255.255.",
          "correct": true
        },
        {
          "key": "b",
          "text": "239.0.0.0 – 255.255.255.255",
          "correct": false
        },
        {
          "key": "c",
          "text": "192.168.0.0 – 192.168.255.255",
          "correct": false
        },
        {
          "key": "d",
          "text": "10.0.0.0 – 10.255.255.255",
          "correct": false
        },
        {
          "key": "e",
          "text": "127.0.0.0 – 127.255.255.255",
          "correct": false
        },
        {
          "key": "f",
          "text": "172.16.0.0 – 172.31.255.255",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 1268,
      "question": "Przykłady polskich nazw warstw w stosowanym w sieciach komputerowych modelu ISO OSI RM (ISO Open Systems Interconnection Reference Model), to:",
      "options": [
        {
          "key": "a",
          "text": "Fizyczna, Łącza danych, Sieciowa, Transportowa, Sesji, Prezentacji, Aplikacji.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Warstwa sesji",
          "correct": false
        },
        {
          "key": "c",
          "text": "Warstwa sprzętowa",
          "correct": false
        },
        {
          "key": "d",
          "text": "Warstwa internetowa",
          "correct": false
        },
        {
          "key": "e",
          "text": "Warstwa 3 to warstwa sieciowa (np. protokół IP).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Model ISO/OSI ma 4 warstwy.",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 1269,
      "question": "Protokół automatycznie eliminujący możliwość zapętlenia transmisji ramki typu broadcast w sieci Ethernet (powstania tzw. broadcast storm), to:",
      "options": [
        {
          "key": "a",
          "text": "Blokuje redundantne ścieżki w sieci Ethernet, tworząc strukturę drzewa bez pętli.",
          "correct": true
        },
        {
          "key": "b",
          "text": "STP (Spanning Tree Protocol)",
          "correct": false
        },
        {
          "key": "c",
          "text": "DHCP",
          "correct": false
        },
        {
          "key": "d",
          "text": "BGP",
          "correct": false
        },
        {
          "key": "e",
          "text": "Służy do automatycznej konfiguracji adresów IP.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Działa w warstwie 3 modelu OSI.",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 1270,
      "question": "Sieć 210.210.210.192/26:",
      "options": [
        {
          "key": "a",
          "text": "Zakres adresów użytkowych: 210.210.210.193 - 210.210.210.254.",
          "correct": true
        },
        {
          "key": "b",
          "text": "210.210.210.210",
          "correct": false
        },
        {
          "key": "c",
          "text": "210.210.210.190",
          "correct": false
        },
        {
          "key": "d",
          "text": "210.210.210.255",
          "correct": false
        },
        {
          "key": "e",
          "text": "Adres rozgłoszeniowy to 210.210.210.255.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Maska podsieci to 255.255.255.0.",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 1271,
      "question": "Jakiej techniki przesyłania ruchu sieciowego poprzez ruter IP użyjesz, gdy w sieciach IP organizacji, w której pracujesz, zabrakło adresów IPv4 dla urządzeń, a dodatkowo urządzenia te nie powinny być bezpośrednio dostępne i adresowalne z Internetu?",
      "options": [
        {
          "key": "a",
          "text": "NAT (Network Address Translation).",
          "correct": true
        },
        {
          "key": "b",
          "text": "RPF (Reverse Path Forwarding)",
          "correct": false
        },
        {
          "key": "c",
          "text": "DNS",
          "correct": false
        },
        {
          "key": "d",
          "text": "ICMP",
          "correct": false
        },
        {
          "key": "e",
          "text": "ARP",
          "correct": false
        },
        {
          "key": "f",
          "text": "OSPF",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 1272,
      "question": "Tak zwana sól (ang. salt), czyli dane losowe dodawane do hasła podczas obliczania funkcji skrótu przechowywanej w systemach informatycznych, ma na celu:",
      "options": [
        {
          "key": "a",
          "text": "Unikalny ciąg znaków dodawany do hasła przed haszowaniem.",
          "correct": true
        },
        {
          "key": "b",
          "text": "utrudnienie sortowania haseł przez użytkowników.",
          "correct": false
        },
        {
          "key": "c",
          "text": "skrócenie czasu obliczania funkcji skrótu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "umożliwienie odzyskania hasła w postaci jawnej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Chroni przed atakami z użyciem Rainbow Tables.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest przechowywana w bezpiecznym module sprzętowym (HSM).",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 1273,
      "question": "Standard definiujący schemat dla certyfikatów służących do budowania struktury hierarchicznej infrastruktury klucza publicznego, stosowany na przykład w zabezpieczonych technologiach webowych, to:",
      "options": [
        {
          "key": "a",
          "text": "X.509",
          "correct": true
        },
        {
          "key": "b",
          "text": "H.323",
          "correct": false
        },
        {
          "key": "c",
          "text": "PKI-Standard",
          "correct": false
        },
        {
          "key": "d",
          "text": "SSL-Cert",
          "correct": false
        },
        {
          "key": "e",
          "text": "AES-256",
          "correct": false
        },
        {
          "key": "f",
          "text": "RSA-4096",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 1274,
      "question": "Protokół UDP:",
      "options": [
        {
          "key": "a",
          "text": "Jest bezpołączeniowy, nie gwarantuje dostarczenia pakietów.",
          "correct": true
        },
        {
          "key": "b",
          "text": "definiuje 16-to bitową adresację gniazd.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zapewnia retransmisję zgubionych danych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "wymaga nawiązania połączenia.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Ma mniejszy narzut nagłówka niż TCP.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest stosowany w protokole HTTP/1.1.",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 1275,
      "question": "Zapisana liczbowo wartość maski podsieci IPv4 dla adresu sieci: 5.5.5.0/30, to",
      "options": [
        {
          "key": "a",
          "text": "255.255.255.252",
          "correct": true
        },
        {
          "key": "b",
          "text": "255.255.255.0",
          "correct": false
        },
        {
          "key": "c",
          "text": "255.255.255.248",
          "correct": false
        },
        {
          "key": "d",
          "text": "255.255.255.192",
          "correct": false
        },
        {
          "key": "e",
          "text": "255.255.255.254",
          "correct": false
        },
        {
          "key": "f",
          "text": "255.255.255.128",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 1276,
      "question": "Czy protokół TCP, stosowany w komunikacji w sieciach komputerowych, wymusza swoimi uwarunkowaniami technicznymi limit długości transmisji danych, przypadających na jedno połączenie?",
      "options": [
        {
          "key": "a",
          "text": "TCP traktuje dane jako strumień bajtów bez narzuconego limitu całkowitej długości.",
          "correct": true
        },
        {
          "key": "b",
          "text": "tak, jest to zawsze 4GB.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zależy od wersji systemu operacyjnego.",
          "correct": false
        },
        {
          "key": "d",
          "text": "wynosi 64 KB na segment.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wynosi 2^64 bajtów.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest ograniczony rozmiarem okna (window size).",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 1277,
      "question": "Długość unikatowego adresu MAC (Media Access Control), stosowanego w interfejsach NIC (Network Interface Card) warstwy 2 ISO OSI (na przykład w Ethernet), to:",
      "options": [
        {
          "key": "a",
          "text": "48 bitów (6 bajtów).",
          "correct": true
        },
        {
          "key": "b",
          "text": "32 bity",
          "correct": false
        },
        {
          "key": "c",
          "text": "64 bity",
          "correct": false
        },
        {
          "key": "d",
          "text": "128 bitów",
          "correct": false
        },
        {
          "key": "e",
          "text": "24 bity",
          "correct": false
        },
        {
          "key": "f",
          "text": "16 bitów",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 1278,
      "question": "Światłowód, w którym wiązka światła o danej (takiej samej) długości fali może przemieszczać się tylko jedną drogą i nie można przesłać kilku wiązek o takiej samej długości fali przez ten światłowód jednocześnie, oznaczamy określeniem:",
      "options": [
        {
          "key": "a",
          "text": "Posiada bardzo cienki rdzeń, co pozwala na przesyłanie tylko jednego modu światła.",
          "correct": true
        },
        {
          "key": "b",
          "text": "jednomodowy",
          "correct": false
        },
        {
          "key": "c",
          "text": "wielomodowy",
          "correct": false
        },
        {
          "key": "d",
          "text": "gradientowy",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwala na transmisję na znacznie większe odległości niż wielomodowy.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest tańszy w instalacji niż skrętka miedziana.",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": true
    },
    {
      "id": 1279,
      "question": "Przykłady wykorzystywanych obecnie szeregowych magistral cyfrowych, to:",
      "options": [
        {
          "key": "a",
          "text": "SPI, I2C, UART, USB, CAN.",
          "correct": true
        },
        {
          "key": "b",
          "text": "SPI, I2C",
          "correct": false
        },
        {
          "key": "c",
          "text": "PCI Express",
          "correct": false
        },
        {
          "key": "d",
          "text": "ATA",
          "correct": false
        },
        {
          "key": "e",
          "text": "SCSI",
          "correct": false
        },
        {
          "key": "f",
          "text": "ISA",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 1280,
      "question": "Przykłady specyfikacji protokołów komunikacyjnych dla sieci bezprzewodowych lub systemów komunikacji bezprzewodowej to:",
      "options": [
        {
          "key": "a",
          "text": "Wi-Fi (802.11), Bluetooth, ZigBee, LoRaWAN, 5G.",
          "correct": true
        },
        {
          "key": "b",
          "text": "LoRaWAN",
          "correct": false
        },
        {
          "key": "c",
          "text": "Ethernet",
          "correct": false
        },
        {
          "key": "d",
          "text": "RS-232",
          "correct": false
        },
        {
          "key": "e",
          "text": "Token Ring",
          "correct": false
        },
        {
          "key": "f",
          "text": "Frame Relay",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 1281,
      "question": "Adres IPv6 w sieci 5::0/64:",
      "options": [
        {
          "key": "a",
          "text": "5::1, 5::abcd, itp.",
          "correct": true
        },
        {
          "key": "b",
          "text": "1::1",
          "correct": false
        },
        {
          "key": "c",
          "text": "5:0:0:0:0:0:0:1",
          "correct": false
        },
        {
          "key": "d",
          "text": "::5",
          "correct": false
        },
        {
          "key": "e",
          "text": "5::g123",
          "correct": false
        },
        {
          "key": "f",
          "text": "5::1:2:3:4:5",
          "correct": false
        }
      ],
      "topic": "networks",
      "semester": 4,
      "courseName": "Sieci komputerowe",
      "multipleCorrect": false
    },
    {
      "id": 1282,
      "question": "Algorytm węgierski:",
      "options": [
        {
          "key": "a",
          "text": "Służy do rozwiązywania zagadnienia przydziału w czasie wielomianowym O(n^3).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Ma niewielomianową złożoność obliczeniową.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Dotyczy tylko grafów niespójnych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Służy do znajdowania najkrótszej ścieżki.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest algorytmem zachłannym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wymaga macierzy o wagach ujemnych.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1283,
      "question": "Liczbę rozwiązań optymalnych w programowaniu liniowym:",
      "options": [
        {
          "key": "a",
          "text": "Może wynosić zero, jedno lub nieskończenie wiele.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Zero.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Zawsze dokładnie jedno.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Zawsze skończona liczba.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Zawsze co najmniej dwa.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Zależy od liczby procesorów.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1284,
      "question": "Metoda podziału i ograniczeń (ang. branch and bound) opiera się na porównywaniu dwóch wartości: dolnego ograniczenia funkcji celu (ang. lower bound) górnego ograniczenia funkcji celu (ang. upper bound) Czym są te wartości?",
      "options": [
        {
          "key": "a",
          "text": "LB to najlepszy możliwy wynik w poddrzewie, UB to wartość najlepszego dotychczas znalezionego rozwiązania.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Górne ograniczenie liczy się dla konkretnego węzła w drzewie przeszukiwania.",
          "correct": false
        },
        {
          "key": "c",
          "text": "LB i UB są zawsze równe.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Służy tylko do problemów bez ograniczeń.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwala na przeszukiwanie tylko obiecujących gałęzi drzewa rozwiązań.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest stosowana wyłącznie w sortowaniu.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 1285,
      "question": "Metoda ścieżki krytycznej (CPM):",
      "options": [
        {
          "key": "a",
          "text": "Pozwala wyznaczyć najdłuższy ciąg zadań zależnych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Do określenia, które zadania mają szczególny wpływ na czas realizacji.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Służy do optymalizacji kosztów transportu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wyznacza zadania o największym zapasie czasu.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Zadania na ścieżce krytycznej mają zerowy zapas czasu (slack).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest metodą probabilistyczną (jak PERT).",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 1286,
      "question": "Metoda wielkich M (ang. big-M method) pozwala na znalezienie pierwszego rozwiązania dla algorytmu symplex. Zaznacz prawdziwe zdania o tej metodzie:",
      "options": [
        {
          "key": "a",
          "text": "Polega na wprowadzeniu sztucznych zmiennych z bardzo dużym kosztem M.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wymaga dodania dodatkowych ograniczeń na istniejące zmienne.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Służy do rozwiązywania problemów nieliniowych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Eliminuje potrzebę stosowania zmiennych swobodnych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "M jest zawsze równe 1,000,000.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest stosowana tylko w problemach transportowych.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1287,
      "question": "Metody rozwiązywania zagadnienia przydziału:",
      "options": [
        {
          "key": "a",
          "text": "Algorytm węgierski, algorytmy przepływowe, programowanie całkowitoliczbowe.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Dowolny algorytm rozwiązujący problemy programowania całkowitoliczbowego.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Tylko metoda bisekcji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Algorytm Dijkstry.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Metoda najmniejszych kwadratów.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Algorytm Newtona.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1288,
      "question": "Postać kanoniczna (równościowa) zadania programowania liniowego:",
      "options": [
        {
          "key": "a",
          "text": "Wszystkie ograniczenia są równościami, a wszystkie zmienne są nieujemne.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Funkcja celu musi być maksymalizowana.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Liczba zmiennych musi być równa liczbie ograniczeń.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Macierz ograniczeń musi być kwadratowa.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Nie dopuszcza zmiennych swobodnych.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest jedyną postacią akceptowaną przez metodę graficzną.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1289,
      "question": "Dualność w programowaniu liniowym:",
      "options": [
        {
          "key": "a",
          "text": "Każdemu problemowi pierwotnemu odpowiada problem dualny.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wartość w optimum programu dualnego jest taka sama jak w pierwotnym.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Problem dualny ma zawsze więcej zmiennych niż pierwotny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jeśli problem pierwotny jest nieograniczony, to dualny ma rozwiązanie optymalne.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Liczba zmiennych w problemie dualnym jest równa liczbie ograniczeń w problemie pierwotnym.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Dualność nie zachodzi dla problemów minimalizacji.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 1290,
      "question": "Relaksacja liniowa w metodzie podziału i ograniczeń:",
      "options": [
        {
          "key": "a",
          "text": "Polega na odrzuceniu wymogu całkowitoliczbowości zmiennych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Drzewo przeszukiwania w tym algorytmie jest drzewem binarnym.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Zawsze daje rozwiązanie całkowitoliczbowe.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest stosowana tylko w problemach transportowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Rozwiązanie relaksacji daje ograniczenie dla problemu oryginalnego.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Relaksacja liniowa jest problemem NP-trudnym.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 1291,
      "question": "Relaksacja problemu w badaniach operacyjnych:",
      "options": [
        {
          "key": "a",
          "text": "To uproszczenie problemu, którego rozwiązanie daje oszacowanie wyniku problemu oryginalnego.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Relaksacja ma na celu stworzenie nowego problemu, który jest prostszą wersją.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Relaksacja zawsze prowadzi do tego samego rozwiązania co problem oryginalny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Polega na losowym wyborze zmiennych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Zawsze zwiększa liczbę ograniczeń.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest stosowana tylko w programowaniu nieliniowym.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1292,
      "question": "Algorytm dwufazowy sympleks:",
      "options": [
        {
          "key": "a",
          "text": "Faza I znajduje rozwiązanie bazowe dopuszczalne, Faza II znajduje rozwiązanie optymalne.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Pracuje dwufazowo, czyli rozwiązuje dwa modele.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest stosowany tylko dla funkcji kwadratowych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie wymaga macierzy jednostkowej w bazie.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Faza I zawsze kończy się sukcesem.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Faza II jest opcjonalna.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": false
    },
    {
      "id": 1293,
      "question": "Zaznacz prawdziwe (udowodnione) zdania o złożoności obliczeniowej decyzyjnej wersji problemu plecakowego:",
      "options": [
        {
          "key": "a",
          "text": "Jest problemem NP-zupełnym.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Należy do klasy NP.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Jest rozstrzygalny w czasie logarytmicznym.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Należy do klasy P.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest problemem nierozstrzygalnym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Może być rozwiązany w czasie wielomianowym za pomocą programowania dynamicznego.",
          "correct": false
        }
      ],
      "topic": "algorithms",
      "semester": 4,
      "courseName": "Algorytmy i struktury danych",
      "multipleCorrect": true
    },
    {
      "id": 1294,
      "question": "Kodowanie 1 z n (One-Hot Encoding):",
      "options": [
        {
          "key": "a",
          "text": "Reprezentacja zmiennych kategorycznych jako wektorów binarnych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "rodzaj zbioru danych, w którym tylko jedna kolumna ma istotne znaczenie.",
          "correct": false
        },
        {
          "key": "c",
          "text": "metoda kompresji obrazów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "algorytm sortowania danych tekstowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Służy do zamiany liczb zmiennoprzecinkowych na całkowite.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest stosowane w sieciach neuronowych do reprezentacji klas.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1295,
      "question": "Które z poniższych poleceń są poprawne, zakładając że df jest obiektem DataFrame biblioteki Pandas?",
      "options": [
        {
          "key": "a",
          "text": "Pozwala na stosowanie różnych funkcji agregujących do wybranych kolumn DataFrame.",
          "correct": true
        },
        {
          "key": "b",
          "text": "df.agg({'one': 'mean', 'four': 'sum'})",
          "correct": true
        },
        {
          "key": "c",
          "text": "Służy do usuwania duplikatów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie przyjmuje słowników jako argumentów.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest tożsama z metodą apply().",
          "correct": false
        },
        {
          "key": "f",
          "text": "Działa tylko na obiektach typu Series.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1296,
      "question": "Które z poniższych stwierdzeń są prawdziwe w odniesieniu do biblioteki Pandas?",
      "options": [
        {
          "key": "a",
          "text": "Realizuje operacje złączenia dwóch obiektów DataFrame na podstawie wspólnych kolumn.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Polecenie merge pozwala złączyć dwa obiekty DataFrame poprzez porównanie wartości.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Zawsze modyfikuje oryginalne obiekty w miejscu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Służy do pionowego łączenia tabel.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Obsługuje typy złączeń: inner, left, right, outer.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Wymaga, aby obie tabele miały identyczne indeksy.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1297,
      "question": "Zakładając że s jest obiektem Series biblioteki Pandas, polecenie s.map(x) spowoduje:",
      "options": [
        {
          "key": "a",
          "text": "Służy do mapowania wartości w Series na inne wartości.",
          "correct": true
        },
        {
          "key": "b",
          "text": "jeżeli x jest ciągiem znaków, odfiltrowanie tylko tych wartości.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Zmienia nazwy kolumn w DataFrame.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Oblicza średnią kroczącą.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Mapuje wartości tylko typu tekstowego.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest wolniejsza od pętli for w Pythonie.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1298,
      "question": "Sferyczne układy odniesienia (ang. spatial reference systems, coordinate reference systems), takie jak np. WGS-84:",
      "options": [
        {
          "key": "a",
          "text": "Modelują Ziemię jako elipsoidę lub sferę, używając szerokości i długości geograficznej.",
          "correct": true
        },
        {
          "key": "b",
          "text": "korzystają ze współrzędnych podanych w stopniach.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Pozwalają na łatwe obliczanie powierzchni w metrach kwadratowych bez rzutowania.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Są układami płaskimi.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Są używane w systemie GPS.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Nie uwzględniają spłaszczenia Ziemi na biegunach.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1299,
      "question": "Płaskie (izometryczne, rzutowane) układy odniesienia (ang. spatial reference systems, coordinate reference systems), takie jak np. PUWG 2000:",
      "options": [
        {
          "key": "a",
          "text": "Powstają poprzez rzutowanie powierzchni elipsoidy na płaszczyznę.",
          "correct": true
        },
        {
          "key": "b",
          "text": "pozwalają na obliczenie odległości przy pomocy samego twierdzenia Pitagorasa.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Nie wprowadzają żadnych zniekształceń odległości.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Są używane wyłącznie w nawigacji morskiej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Używają współrzędnych kartezjańskich (X, Y) wyrażonych w metrach.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Są identyczne na całym świecie.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1300,
      "question": "Optymalizacja czasu przetwarzania danych:",
      "options": [
        {
          "key": "a",
          "text": "Należy zoptymalizować algorytmy, użyć indeksowania, zrównoleglić obliczenia.",
          "correct": true
        },
        {
          "key": "b",
          "text": "zwiększyć pamięć wirtualną.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zawsze kupić szybszy procesor.",
          "correct": false
        },
        {
          "key": "d",
          "text": "zmniejszyć liczbę kolorów w interfejsie.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wykorzystać wektoryzację operacji (np. w NumPy).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Przenieść wszystkie dane do plików tekstowych.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1301,
      "question": "Jeżeli dane, przy ich analizie, nie mieszczą się w dostępnej pamięci RAM należy do ich przetwarzania:",
      "options": [
        {
          "key": "a",
          "text": "Należy stosować przetwarzanie strumieniowe (chunking), bazy danych lub systemy Out-of-Core.",
          "correct": true
        },
        {
          "key": "b",
          "text": "użyć bazy danych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "zrezygnować z analizy części danych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "wyłączyć system operacyjny.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Zwiększyć rozmiar pliku wymiany (swap) do 1 TB.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Użyć biblioteki Dask lub Apache Spark.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1302,
      "question": "Zakładając, że df jest obiektem typu DataFrame biblioteki Pandas, polecenie df.apply(moja_funkcja)spowoduje:",
      "options": [
        {
          "key": "a",
          "text": "Wywołuje funkcję moja_funkcja dla każdej kolumny lub każdego wiersza.",
          "correct": true
        },
        {
          "key": "b",
          "text": "uruchomienie raz funkcji moja_funkcja.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Służy do filtrowania danych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Działa tylko na liczbach całkowitych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Zawsze zwraca obiekt typu Series.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest najbardziej wydajnym sposobem przetwarzania danych w Pandas.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1303,
      "question": "Zakładając, że df jest obiektem typu DataFrame biblioteki Pandas, polecenie df.apply(moja_funkcja, axis=1)spowoduje:",
      "options": [
        {
          "key": "a",
          "text": "Wywołuje funkcję moja_funkcja dla każdego wiersza (row-wise).",
          "correct": true
        },
        {
          "key": "b",
          "text": "wywoływanie funkcji moja_funkcja za każdym razem gdy obiekt df zostanie zmodyfikowany.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wywołuje funkcję tylko dla pierwszej kolumny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Służy do transpozycji macierzy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest szybsze niż axis=0.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Pozwala na dostęp do wielu kolumn jednocześnie wewnątrz funkcji.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1304,
      "question": "Które z poniższych sposobów przechowywania danych pozwalają na jawne określenie, czy dana wartość jest liczbą całkowitą, liczbą zmiennoprzecinkową czy tekstem?",
      "options": [
        {
          "key": "a",
          "text": "Formaty takie jak Parquet, Avro czy bazy danych SQL przechowują informacje o typach.",
          "correct": true
        },
        {
          "key": "b",
          "text": "plik JSON",
          "correct": false
        },
        {
          "key": "c",
          "text": "plik CSV",
          "correct": false
        },
        {
          "key": "d",
          "text": "plik tekstowy .txt",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pliki binarne zawsze wymagają jawnego schematu.",
          "correct": false
        },
        {
          "key": "f",
          "text": "HDF5 obsługuje jawne typowanie.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1305,
      "question": "Obiekt GeoDataFrame w GeoPandas:",
      "options": [
        {
          "key": "a",
          "text": "Rozszerza DataFrame o kolumnę 'geometry', która przechowuje obiekty przestrzenne.",
          "correct": true
        },
        {
          "key": "b",
          "text": "zawiera dane geometryczne, a nie dane tekstowe ani numeryczne.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Może zawierać zarówno dane atrybutowe, jak i przestrzenne.",
          "correct": true
        },
        {
          "key": "d",
          "text": "Nie obsługuje operacji złączeń.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wymaga zainstalowanej biblioteki Shapely.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Każdy wiersz musi mieć geometrię tego samego typu.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1306,
      "question": "Jakie są standardowe metody używane do oceny modeli w nadzorowanym uczeniu maszynowym?",
      "options": [
        {
          "key": "a",
          "text": "Accuracy, Precision, Recall, F1-score, Macierz pomyłek, AUC-ROC.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Macierz pomyłek.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Średnia arytmetyczna wag neuronów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Liczba warstw w sieci.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Czas trenowania modelu.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Rozmiar pliku z modelem.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1307,
      "question": "Metoda Leave-One-Out (LOOCV):",
      "options": [
        {
          "key": "a",
          "text": "To wariant walidacji krzyżowej, gdzie testujemy model na jednym przykładzie, a trenujemy na n-1.",
          "correct": true
        },
        {
          "key": "b",
          "text": "To metoda doboru parametrów tylko w sieciach neuronowych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Służy do usuwania duplikatów ze zbioru.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest bardzo szybka dla dużych zbiorów danych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Minimalizuje obciążenie (bias) estymatora błędu.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Wymaga n-krotnego trenowania modelu.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1308,
      "question": "Funkcja aktywacji w sieciach neuronowych:",
      "options": [
        {
          "key": "a",
          "text": "Wprowadza nieliniowość do modelu.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Funkcja, zgodnie z którą obliczane są wyjścia neuronów.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Służy do inicjalizacji wag.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest używana tylko w warstwie wejściowej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "ReLU (Rectified Linear Unit) jest popularną funkcją aktywacji.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Funkcja liniowa jest najczęściej stosowana w warstwach ukrytych.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1309,
      "question": "Niezbilansowany zbiór danych (Imbalanced Data):",
      "options": [
        {
          "key": "a",
          "text": "Sytuacja, w której jedna klasa jest znacznie liczniejsza od innych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Do walidacji powinniśmy zastosować metrykę F1.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Należy zawsze usunąć nadmiarowe dane z klasy liczniejszej.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie ma wpływu na proces uczenia.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Można stosować techniki takie jak SMOTE (oversampling) lub undersampling.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Accuracy jest najlepszą metryką w tym przypadku.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1310,
      "question": "Etykietowanie danych (Labeling):",
      "options": [
        {
          "key": "a",
          "text": "Proces przypisywania poprawnych odpowiedzi do danych wejściowych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Zawsze wykonywany jest automatycznie.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Może być wykonywany ręcznie przez ekspertów.",
          "correct": true
        },
        {
          "key": "d",
          "text": "Dotyczy tylko danych numerycznych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest kluczowym etapem w uczeniu nienadzorowanym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Błędne etykiety (noise) obniżają jakość modelu.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1311,
      "question": "Epoka (Epoch) w uczeniu maszynowym:",
      "options": [
        {
          "key": "a",
          "text": "Jedno pełne przejście algorytmu przez cały zbiór treningowy.",
          "correct": true
        },
        {
          "key": "b",
          "text": "jednego cyklu, w którym pokazujemy sieci neuronowej wszystkie dane ze zbioru testowego.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Czas potrzebny na wytrenowanie jednego neuronu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Liczba warstw w sieci głębokiej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest tożsama z jedną iteracją (batch).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Zbyt duża liczba epok może prowadzić do overfittingu.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1312,
      "question": "Które z poniższych metod nie są zazwyczaj stosowane do oceny modeli w nadzorowanym uczeniu maszynowym?",
      "options": [
        {
          "key": "a",
          "text": "Obszar pod krzywą ROC (AUC-ROC).",
          "correct": false
        },
        {
          "key": "b",
          "text": "Współczynnik korelacji Pearsona.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Accuracy.",
          "correct": false
        },
        {
          "key": "d",
          "text": "F1-score.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Log Loss (Cross-Entropy).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Średni błąd bezwzględny (MAE) dla regresji.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1313,
      "question": "Co można powiedzieć o modelu uczenia maszynowego w kontekście zjawiska nadmiernego dopasowania (przeuczenie, overfitting)?",
      "options": [
        {
          "key": "a",
          "text": "Model ma bardzo niską stratę na zbiorze treningowym, ale wysoką na testowym.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Model uczenia maszynowego jest zbyt dobrze dopasowany do danych treningowych.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Model jest zbyt prosty, aby opisać dane.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wynika z braku danych treningowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Model \"uczy się na pamięć\" szumu w danych treningowych.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest pożądane w systemach produkcyjnych.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1314,
      "question": "Czym może być spowodowane nadmiernie dopasowanie (przeuczenie, overfitting)?",
      "options": [
        {
          "key": "a",
          "text": "Zbyt duża liczba parametrów modelu w stosunku do małej liczby przykładów.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Zbyt skomplikowany model w stosunku do ilości i charakteru dostępnych danych.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Zbyt duża liczba epok trenowania.",
          "correct": true
        },
        {
          "key": "d",
          "text": "Zastosowanie regularyzacji.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Brak zbioru walidacyjnego.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Zbyt silne Dropout w sieciach neuronowych.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1315,
      "question": "Czym może być spowodowane niedouczenie (underfitting) modelu uczenia maszynowego?",
      "options": [
        {
          "key": "a",
          "text": "Model jest zbyt prosty, aby uchwycić zależności w danych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Zbyt krótkim czasem trenowania lub zbyt małą liczbą epok.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Zbyt dużą liczbą cech (wymiarów).",
          "correct": false
        },
        {
          "key": "d",
          "text": "Użyciem zbyt skomplikowanej sieci neuronowej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Model ma wysoki błąd zarówno na zbiorze treningowym, jak i testowym.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Można go naprawić poprzez dodanie regularyzacji L2.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1316,
      "question": "Jakie działania można podjąć, aby uniknąć nadmiernego dopasowania (przeuczenia, overfitting)?",
      "options": [
        {
          "key": "a",
          "text": "Regularyzacja (L1/L2), Dropout, Early Stopping, zwiększenie ilości danych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Zastosować większą liczbę cech.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Zwiększyć liczbę warstw sieci.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Usunąć zbiór walidacyjny.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Zastosować Cross-Validation.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Zmniejszyć siłę regularyzacji.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1317,
      "question": "Jakie działania można podjąć, aby uniknąć niedouczenia (underfitting)?",
      "options": [
        {
          "key": "a",
          "text": "Zwiększenie złożoności modelu, dodanie nowych cech, wydłużenie czasu trenowania.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Użyć prostszych modeli.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Zwiększyć siłę regularyzacji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Zmniejszyć liczbę neuronów w warstwach ukrytych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Usunąć szum z danych treningowych.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Zastosować inżynierię cech (feature engineering).",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1318,
      "question": "Jakie są przykłady zadań uczenia maszynowego stosowanych w uczeniu nadzorowanym?",
      "options": [
        {
          "key": "a",
          "text": "Klasyfikacja i Regresja.",
          "correct": true
        },
        {
          "key": "b",
          "text": "klasyfikacji",
          "correct": true
        },
        {
          "key": "c",
          "text": "Klasteryzacja (grupowanie).",
          "correct": false
        },
        {
          "key": "d",
          "text": "Redukcja wymiarowości.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wykrywanie anomalii (bez etykiet).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Przewidywanie wartości ciągłych (regresja).",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1319,
      "question": "Jakie są przykłady zadań uczenia maszynowego stosowanych w uczeniu nienadzorowanym?",
      "options": [
        {
          "key": "a",
          "text": "Klasteryzacja, Redukcja wymiarowości, Wykrywanie anomalii, Reguły asocjacyjne.",
          "correct": true
        },
        {
          "key": "b",
          "text": "redukcji wymiarowości",
          "correct": true
        },
        {
          "key": "c",
          "text": "Regresja logistyczna.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Przewidywanie szeregów czasowych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Grupowanie podobnych klientów bez znajomości ich etykiet.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Rozpoznawanie twarzy na zdjęciach (z etykietami).",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1320,
      "question": "Jedną z podstawowych architektur systemów agentowych jest architektura BDI. W kontekście systemów agentowych skrót BDI jest wyjaśniany jako:",
      "options": [
        {
          "key": "a",
          "text": "Beliefs (Przekonania), Desires (Pragnienia), Intentions (Intencje).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Belief-Desire-Intention",
          "correct": false
        },
        {
          "key": "c",
          "text": "Binary-Data-Interface",
          "correct": false
        },
        {
          "key": "d",
          "text": "Behavior-Driven-Integration",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest modelem architektury agentów inteligentnych.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Służy do budowy baz danych.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1321,
      "question": "Odwracalność automatów komórkowych:",
      "options": [
        {
          "key": "a",
          "text": "Automat jest odwracalny, jeśli każda konfiguracja ma dokładnie jednego poprzednika.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Dla automatów odwracalnych odwzorowanie realizowane przez funkcję przejścia nie może być bijekcją.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wszystkie automaty komórkowe są odwracalne.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Odwracalność zależy od liczby stanów komórki.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Gra w życie (Game of Life) jest automatem odwracalnym.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Automaty odwracalne zachowują informację.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1322,
      "question": "Twórcy automatów komórkowych:",
      "options": [
        {
          "key": "a",
          "text": "John von Neumann oraz Stanisław Ulam.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Jakob Laub oraz Philipp Lenard",
          "correct": false
        },
        {
          "key": "c",
          "text": "Alan Turing i Alonzo Church.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Claude Shannon i Norbert Wiener.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Stephen Wolfram.",
          "correct": false
        },
        {
          "key": "f",
          "text": "John Conway (twórca Gry w Życie).",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1323,
      "question": "Sąsiedztwa w automatach komórkowych:",
      "options": [
        {
          "key": "a",
          "text": "Sąsiedztwo von Neumanna (4 sąsiadów) oraz sąsiedztwo Moore'a (8 sąsiadów).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Dla siatki kwadratowej sąsiedztwo składające się z czterech komórek stykających się krawędziami nazywa się sąsiedztwem von Neumanna.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Sąsiedztwo Moore'a obejmuje tylko komórki stykające się rogami.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Sąsiedztwo jest zawsze definiowane dla całej siatki jednocześnie.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Istnieją sąsiedztwa o większym promieniu (np. r=2).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Sąsiedztwo von Neumanna obejmuje komórkę centralną.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1324,
      "question": "Emergencja w systemach złożonych:",
      "options": [
        {
          "key": "a",
          "text": "Zjawisko powstawania nowych, złożonych właściwości na poziomie makroskopowym.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Otrzymywaniu całościowego obrazu makroskopowego systemu na podstawie działania mikroskopowych reguł.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Polega na centralnym sterowaniu każdym elementem systemu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest synonimem chaosu deterministycznego.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Przykładem jest formowanie się kluczy ptaków lub mrowisk.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wymaga skomplikowanych reguł dla każdego agenta.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1325,
      "question": "Najprostszy agent, który prowadzi prostą adaptację swojego działania w zależności od zmian środowiska (bez efektów pamięci i uczenia się) określany jest jako:",
      "options": [
        {
          "key": "a",
          "text": "Podejmuje decyzje wyłącznie na podstawie aktualnego stanu środowiska.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Agent reaktywny",
          "correct": false
        },
        {
          "key": "c",
          "text": "Posiada rozbudowaną pamięć długotrwałą.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Planuje swoje działania z dużym wyprzedzeniem.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Nie posiada wewnętrznego modelu świata.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest przykładem agenta BDI.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1326,
      "question": "Najważniejszymi własnościami systemów złożonych (ang. complex systems) w domenie skali i czasu są:",
      "options": [
        {
          "key": "a",
          "text": "Emergencja, samoorganizacja, nieliniowość, sprzężenia zwrotne.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Emergencja",
          "correct": false
        },
        {
          "key": "c",
          "text": "Przewidywalność długoterminowa.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Centralne zarządzanie.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Adaptacyjność.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wrażliwość na warunki początkowe (efekt motyla).",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1327,
      "question": "Wskaż które zdania są prawdziwe w odniesieniu do homogenicznego i synchronicznego Automatu Komórkowego (CA)?",
      "options": [
        {
          "key": "a",
          "text": "Homogeniczny - te same reguły; Synchroniczny - jednoczesna aktualizacja.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Gra Life zaproponowana przez matematyka Johna Conwaya jest przykładem homogenicznego i synchronicznego automatu komórkowego.",
          "correct": true
        },
        {
          "key": "c",
          "text": "W grze Life reguły zmieniają się w każdej iteracji.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Gra Life wymaga interwencji użytkownika w każdym kroku.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wszystkie komórki w automacie synchronicznym zmieniają stan w tym samym momencie zegarowym.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Homogeniczność oznacza, że siatka musi być nieskończona.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1328,
      "question": "Własności homogenicznego automatu komórkowego:",
      "options": [
        {
          "key": "a",
          "text": "Identyczna reguła przejścia, identyczny zbiór stanów i identyczny kształt sąsiedztwa dla każdej komórki.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Reguła przejścia identyczna dla całej siatki.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Każda komórka ma inną liczbę sąsiadów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Siatka musi być zawsze skończona.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Zapewnia niezmienniczość reguł względem przesunięcia (translativity).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Stany komórek muszą być liczbami binarnymi.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1329,
      "question": "Niehomogeniczny Automat Komórkowy:",
      "options": [
        {
          "key": "a",
          "text": "Może posiadać różne reguły przejścia lub różne zbiory stanów dla poszczególnych komórek.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Niehomogeniczny automat komórkowy wyłącznie charakteryzuje się różnymi zbiorami stanów.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest zawsze odwracalny.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie może być symulowany na komputerze.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Pozwala na modelowanie środowisk o zróżnicowanych właściwościach fizycznych.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wymaga asynchronicznej aktualizacji.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1330,
      "question": "Symulacja zdarzeń dyskretnych (DES):",
      "options": [
        {
          "key": "a",
          "text": "Modeluje system jako sekwencyjną listę zdarzeń w czasie.",
          "correct": true
        },
        {
          "key": "b",
          "text": "DES stanowią alternatywną metodę modelowania wobec systemów Agent Based Modeling (ABM).",
          "correct": false
        },
        {
          "key": "c",
          "text": "Czas in DES płynie w sposób ciągły.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Służy wyłącznie do modelowania procesów chemicznych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Zdarzenia są umieszczane w kolejce priorytetowej (event list).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Stan systemu zmienia się płynnie między zdarzeniami.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1331,
      "question": "Periodyczne warunki brzegowe dla Automatu Komórkowego oznaczają następujące własności dla obiektu poruszającego się po siatce:",
      "options": [
        {
          "key": "a",
          "text": "Przeciwległe krawędzie siatki są ze sobą połączone.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Poruszający się obiekt definitywnie znika z siatki po osiągnięciu granicznych komórek.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Powodują odbicie się obiektu od ściany.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Są stosowane tylko w automatach 1D.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Siatka 2D z takimi warunkami ma topologię torusa.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Eliminują efekty brzegowe w symulacjach.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1332,
      "question": "Algorytmy poszukujące ekstremum funkcji:",
      "options": [
        {
          "key": "a",
          "text": "Gradient Descent, Adam, Algorytmy Genetyczne, Simulated Annealing.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Stochastic Gradient Descent",
          "correct": true
        },
        {
          "key": "c",
          "text": "K-Means",
          "correct": false
        },
        {
          "key": "d",
          "text": "PCA",
          "correct": false
        },
        {
          "key": "e",
          "text": "PSO (Particle Swarm Optimization).",
          "correct": true
        },
        {
          "key": "f",
          "text": "BFS (Breadth-First Search).",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1333,
      "question": "Algorytmy redukcji wymiarowości:",
      "options": [
        {
          "key": "a",
          "text": "PCA (Principal Component Analysis), t-SNE, UMAP, Autoenkodery.",
          "correct": true
        },
        {
          "key": "b",
          "text": "K-Nearest Neighbors",
          "correct": false
        },
        {
          "key": "c",
          "text": "Linear Regression",
          "correct": false
        },
        {
          "key": "d",
          "text": "Decision Trees",
          "correct": false
        },
        {
          "key": "e",
          "text": "LDA (Linear Discriminant Analysis).",
          "correct": false
        },
        {
          "key": "f",
          "text": "SVD (Singular Value Decomposition).",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1334,
      "question": "Metryki skuteczności modelu predykcyjnego:",
      "options": [
        {
          "key": "a",
          "text": "MSE (Mean Squared Error), MAE, R-squared (dla regresji); Accuracy, F1 (dla klasyfikacji).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wariancja",
          "correct": false
        },
        {
          "key": "c",
          "text": "Odchylenie standardowe wag.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Liczba iteracji.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Log-Loss.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Współczynnik Giniego.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1335,
      "question": "Uczenie częściowo nadzorowane (Semi-supervised Learning):",
      "options": [
        {
          "key": "a",
          "text": "Wykorzystuje małą ilość danych etykietowanych i dużą ilość danych nieetykietowanych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Nie potrzebuje etykiet.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Jest tożsame z uczeniem ze wzmocnieniem.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wymaga etykiet dla wszystkich przykładów.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest przydatne, gdy etykietowanie danych jest drogie lub czasochłonne.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Wykorzystuje techniki takie jak self-training lub co-training.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1336,
      "question": "Funkcje aktywacji w sieciach neuronowych:",
      "options": [
        {
          "key": "a",
          "text": "Sigmoid, ReLU, Tanh, Softmax.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Sigmoid",
          "correct": false
        },
        {
          "key": "c",
          "text": "Linear (tylko w regresji).",
          "correct": false
        },
        {
          "key": "d",
          "text": "Logarytmiczna.",
          "correct": false
        },
        {
          "key": "e",
          "text": "ELU (Exponential Linear Unit).",
          "correct": false
        },
        {
          "key": "f",
          "text": "Heaviside (funkcja skokowa).",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1337,
      "question": "Instancja odstająca (Outlier):",
      "options": [
        {
          "key": "a",
          "text": "Przykład w zbiorze danych, który znacząco odbiega od pozostałych obserwacji.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Inną nazwą instancji etykietowanej.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Element zawsze usuwany przed trenowaniem.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Środek ciężkości klastra.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Może negatywnie wpływać na modele takie jak regresja liniowa.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest zawsze wynikiem błędu pomiarowego.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1338,
      "question": "Algorytm K-Means:",
      "options": [
        {
          "key": "a",
          "text": "Jest algorytmem uczenia nienadzorowanego służącym do klasteryzacji.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Jest metodą uczenia nadzorowanego.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wymaga etykiet klas dla każdego punktu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Zawsze znajduje globalne optimum.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Dąży do minimalizacji wariancji wewnątrz klastrów.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest czuły na początkową inicjalizację środków klastrów.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1339,
      "question": "Dla cech X, Y uzyskano wartość współczynnika korelacji liniowej -0.95. Co on oznacza?",
      "options": [
        {
          "key": "a",
          "text": "Oznacza bardzo silną ujemną korelację liniową.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wzrostowi wartości cechy X towarzyszy wzrost wartości cechy Y.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Oznacza brak związku między cechami.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wskazuje na związek nieliniowy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Punkty na wykresie rozrzutu układają się blisko linii prostej o ujemnym nachyleniu.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Oznacza, że X powoduje Y (związek przyczynowo-skutkowy).",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1340,
      "question": "Mając uzupełnioną macierz błędów (confusion matrix), które metryki do oceny jakości modelu można obliczyć?",
      "options": [
        {
          "key": "a",
          "text": "Accuracy, Precision (Precyzja), Recall (Czułość), F1-score, Specificity.",
          "correct": true
        },
        {
          "key": "b",
          "text": "precyzję",
          "correct": false
        },
        {
          "key": "c",
          "text": "Średni błąd kwadratowy.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Współczynnik determinacji R2.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Matthews Correlation Coefficient (MCC).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Entropia krzyżowa.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1341,
      "question": "Algorytmy uczenia nadzorowanego:",
      "options": [
        {
          "key": "a",
          "text": "Regresja liniowa, SVM, Drzewa decyzyjne, k-NN, Sieci neuronowe.",
          "correct": true
        },
        {
          "key": "b",
          "text": "K-NearestNeighbors",
          "correct": true
        },
        {
          "key": "c",
          "text": "K-Means",
          "correct": false
        },
        {
          "key": "d",
          "text": "PCA",
          "correct": false
        },
        {
          "key": "e",
          "text": "Naive Bayes.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Random Forest.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1342,
      "question": "Algorytmy uczenia nienadzorowanego:",
      "options": [
        {
          "key": "a",
          "text": "K-Means, DBSCAN, PCA, Apriori, Autoenkodery.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Regresja Liniowa",
          "correct": false
        },
        {
          "key": "c",
          "text": "Random Forest",
          "correct": false
        },
        {
          "key": "d",
          "text": "Naive Bayes",
          "correct": false
        },
        {
          "key": "e",
          "text": "GMM (Gaussian Mixture Models).",
          "correct": true
        },
        {
          "key": "f",
          "text": "t-SNE.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1343,
      "question": "Wskaż poprawne właściwości odnoszące się do analizy składowych głównych (PCA).",
      "options": [
        {
          "key": "a",
          "text": "Metoda statystyczna służąca do redukcji wymiarowości.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Jest metodą nienadzorowaną.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Służy do klasyfikacji obrazów.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Wymaga danych w postaci tekstowej.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Maksymalizuje wariancję rzutowanych danych.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Składowe główne są skorelowane.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1344,
      "question": "Jakie zastrzeżenia przewidział Turing przeciwko sensowności zaproponowanego przez siebie testu?",
      "options": [
        {
          "key": "a",
          "text": "Turing rozważał m.in. argument z braku świadomości, argument z niepełnosprawności maszyny.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Maszyna cyfrowa jest w stanie zrobić tylko to, co nakazuje jej program.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Test Turinga jest niemożliwy do przeprowadzenia.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Maszyny nigdy nie będą umiały grać w szachy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Chiński Pokój Searla jest znanym argumentem przeciwko testowi Turinga.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Turing przewidywał, że maszyny nigdy nie przejdą testu.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1345,
      "question": "Parametr k w algorytmie kNN (k-Nearest Neighbors):",
      "options": [
        {
          "key": "a",
          "text": "Oznacza liczbę najbliższych sąsiadów branych pod uwagę przy klasyfikacji.",
          "correct": true
        },
        {
          "key": "b",
          "text": "k oznacza liczbę rozpoznawanych klas.",
          "correct": false
        },
        {
          "key": "c",
          "text": "k to liczba warstw w sieci.",
          "correct": false
        },
        {
          "key": "d",
          "text": "k to wymiarowość danych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Małe k może prowadzić do overfittingu.",
          "correct": false
        },
        {
          "key": "f",
          "text": "k musi być zawsze liczbą parzystą.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1346,
      "question": "W ramach klasyfikacji binarnej uzyskano następujące wyniki: TP = 90; TN = 30; FP = 10; FN = 70. Ile wynosi wartość predykcyjna dodatnia?",
      "options": [
        {
          "key": "a",
          "text": "PPV = TP / (TP + FP).",
          "correct": true
        },
        {
          "key": "b",
          "text": "0,5",
          "correct": false
        },
        {
          "key": "c",
          "text": "0,9",
          "correct": false
        },
        {
          "key": "d",
          "text": "0,7",
          "correct": false
        },
        {
          "key": "e",
          "text": "Dla TP=90 i FP=10 wynosi 0.9.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Jest tożsama z czułością (Recall).",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1347,
      "question": "Przewidywanie jednego ulubionego koloru danej osoby (z 5 możliwych: {żółty, różowy, niebieski, zielony, czerwony}) to:",
      "options": [
        {
          "key": "a",
          "text": "Jest to zadanie klasyfikacji.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Klasteryzacja",
          "correct": false
        },
        {
          "key": "c",
          "text": "Regresja",
          "correct": false
        },
        {
          "key": "d",
          "text": "Redukcja wymiarowości",
          "correct": false
        },
        {
          "key": "e",
          "text": "Zadanie uczenia nadzorowanego.",
          "correct": false
        },
        {
          "key": "f",
          "text": "Zadanie optymalizacji globalnej.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1348,
      "question": "Macierz pomyłek (Confusion Matrix):",
      "options": [
        {
          "key": "a",
          "text": "Jej rozmiar to N x N, gdzie N to liczba klas.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Macierz pomyłek zawsze ma rozmiar 2x2.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Pokazuje tylko błędy modelu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Nie pozwala na obliczenie czułości.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Przekątna macierzy zawiera liczby poprawnych predykcji.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Służy do oceny modeli regresji.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1349,
      "question": "Jakie parametry należy ustawić w algorytmie DBSCAN do grupowania danych?",
      "options": [
        {
          "key": "a",
          "text": "Epsilon (promień sąsiedztwa) oraz MinPts (minimalna liczba punktów).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Liczba iteracji.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Liczba klastrów k.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Współczynnik uczenia.",
          "correct": false
        },
        {
          "key": "e",
          "text": "DBSCAN nie wymaga podania liczby klastrów z góry.",
          "correct": false
        },
        {
          "key": "f",
          "text": "DBSCAN radzi sobie z klastrami o różnych gęstościach.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": false
    },
    {
      "id": 1350,
      "question": "Które z poniższych cech najlepiej opisują algorytm k-średnich (k-means)?",
      "options": [
        {
          "key": "a",
          "text": "Grupuje dane poprzez minimalizację sumy kwadratów odległości od środków klastrów.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wymaga określenia liczby klastrów na początku.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Jest odporny na wartości odstające.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Działa dobrze dla klastrów o dowolnych kształtach.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Jest algorytmem iteracyjnym.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Gwarantuje znalezienie globalnego minimum funkcji celu.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1351,
      "question": "Jakie diagramy, ze względu na swoje właściwości wizualne, są najbardziej efektywne do prezentacji wyników grupowania przez algorytm k- średnich (k-means)?",
      "options": [
        {
          "key": "a",
          "text": "Najlepiej widoczna na wykresie punktowym (scatter plot).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Wykres punktowy.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Wykres kołowy.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Histogram.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wykres łokcia (Elbow method) służy do wyboru optymalnego k.",
          "correct": true
        },
        {
          "key": "f",
          "text": "Dendrogram.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1352,
      "question": "Które z poniższych opcji opisują cechy lub zastosowania algorytmu grupowania aglomeracyjnego?",
      "options": [
        {
          "key": "a",
          "text": "Tworzy hierarchię klastrów (dendrogram).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Redukcja wymiarowości danych.",
          "correct": false
        },
        {
          "key": "c",
          "text": "Wymaga podania liczby klastrów przed startem.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Jest zawsze szybsze od k-means.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Może stosować różne kryteria łączenia (linkage).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest metodą uczenia nadzorowanego.",
          "correct": false
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1353,
      "question": "Które z poniższych stwierdzeń trafnie opisują metodę analizy głównych składowych (PCA)?",
      "options": [
        {
          "key": "a",
          "text": "Nowe cechy (składowe) są liniowymi kombinacjami cech oryginalnych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "PCA tworzy składowe, które są wzajemnie ortogonalne.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Zawsze zachowuje 100% wariancji danych.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Służy do usuwania brakujących danych.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Składowe główne są uporządkowane według ilości wyjaśnianej wariancji.",
          "correct": true
        },
        {
          "key": "f",
          "text": "PCA jest bardzo wrażliwe na skalowanie danych.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1354,
      "question": "Które z poniższych zastosowań są odpowiednie dla algorytmu Apriori?",
      "options": [
        {
          "key": "a",
          "text": "Służy do odkrywania częstych zbiorów elementów i reguł asocjacyjnych.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Analiza koszykowa w handlu detalicznym.",
          "correct": true
        },
        {
          "key": "c",
          "text": "Klasyfikacja spamu.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Rozpoznawanie twarzy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Wykorzystuje miary takie jak wsparcie (support), ufność (confidence) i przyrost (lift).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Jest stosowany w systemach rekomendacyjnych.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1355,
      "question": "Które z poniższych metod, algorytmów lub technik są stosowane w uczeniu nienadzorowanym?",
      "options": [
        {
          "key": "a",
          "text": "K-Means, Hierarchical Clustering, PCA, Autoenkodery, SOM.",
          "correct": true
        },
        {
          "key": "b",
          "text": "Autoenkodery, sieć Kohonena",
          "correct": true
        },
        {
          "key": "c",
          "text": "Regresja liniowa, k-NN",
          "correct": false
        },
        {
          "key": "d",
          "text": "Random Forest, XGBoost",
          "correct": false
        },
        {
          "key": "e",
          "text": "Analiza składowych niezależnych (ICA).",
          "correct": true
        },
        {
          "key": "f",
          "text": "SVD.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    },
    {
      "id": 1356,
      "question": "Elementy uczenia ze wzmocnieniem (Reinforcement Learning):",
      "options": [
        {
          "key": "a",
          "text": "Agent, Środowisko (Environment), Stan (State), Akcja (Action), Nagroda (Reward), Polityka (Policy).",
          "correct": true
        },
        {
          "key": "b",
          "text": "Polityka",
          "correct": true
        },
        {
          "key": "c",
          "text": "Etykieta klasy.",
          "correct": false
        },
        {
          "key": "d",
          "text": "Zbiór treningowy.",
          "correct": false
        },
        {
          "key": "e",
          "text": "Funkcja wartości (Value Function).",
          "correct": true
        },
        {
          "key": "f",
          "text": "Eksploracja vs Eksploatacja.",
          "correct": true
        }
      ],
      "topic": "machine_learning",
      "semester": 7,
      "courseName": "Uczenie maszynowe / Sztuczna inteligencja",
      "multipleCorrect": true
    }
  ]
}